{"version":3,"sources":["System/Text/Utility.js","System/Text/Utility.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","getHashCode","source","hash","length","i","l","ch","charCodeAt","repeat","count","result","EMPTY","isNaN","fromChars","chOrChars","_i","chOrChars_1","char","String","fromCharCode","escapeRegExp","replace","trim","chars","ignoreCase","escaped","join","RegExp","format","args","arguments","supplant","params","oIsArray","a","b","n","parseInt","r","Types_1","Type","STRING","NUMBER","BOOLEAN","hasMemberOfType","FUNCTION","toString","canMatch","match","isString","startsWith","pattern","m","isBoolean","indexOf","endsWith","lastIndexOf","Object","defineProperty","value"],"mappings":"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","file":"Utility.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../Types\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Types_1 = require(\"../Types\");\n    exports.EMPTY = '';\n    /**\n     * Returns a numerical (integer) hash code of the string.  Can be used for identifying inequality of contents, but two different strings in rare cases will have the same hash code.\n     * @param source\n     * @returns {number}\n     */\n    function getHashCode(source) {\n        var hash = 0 | 0;\n        if (source.length == 0)\n            return hash;\n        for (var i = 0, l = source.length; i < l; i++) {\n            var ch = source.charCodeAt(i);\n            hash = ((hash << 5) - hash) + ch;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return hash;\n    }\n    exports.getHashCode = getHashCode;\n    function repeat(source, count) {\n        var result = exports.EMPTY;\n        if (!isNaN(count)) {\n            for (var i = 0; i < count; i++) {\n                result += source;\n            }\n        }\n        return result;\n    }\n    exports.repeat = repeat;\n    function fromChars(chOrChars, count) {\n        if (count === void 0) { count = 1; }\n        if ((chOrChars) instanceof (Array)) {\n            var result = exports.EMPTY;\n            for (var _i = 0, chOrChars_1 = chOrChars; _i < chOrChars_1.length; _i++) {\n                var char = chOrChars_1[_i];\n                result += String.fromCharCode(char);\n            }\n            return result;\n        }\n        else {\n            return repeat(String.fromCharCode(chOrChars), count);\n        }\n    }\n    exports.fromChars = fromChars;\n    /**\n     * Escapes a RegExp sequence.\n     * @param source\n     * @returns {string}\n     */\n    function escapeRegExp(source) {\n        return source.replace(/[-[\\]\\/{}()*+?.\\\\^$|]/g, \"\\\\$&\");\n    }\n    exports.escapeRegExp = escapeRegExp;\n    /**\n     * Can trim any character or set of characters from the ends of a string.\n     * Uses a Regex escapement to replace them with empty.\n     * @param source\n     * @param chars A string or array of characters desired to be trimmed.\n     * @param ignoreCase\n     * @returns {string}\n     */\n    function trim(source, chars, ignoreCase) {\n        if (chars === exports.EMPTY)\n            return source;\n        if (chars) {\n            var escaped = escapeRegExp((chars) instanceof (Array) ? chars.join() : chars);\n            return source.replace(new RegExp('^[' + escaped + ']+|[' + escaped + ']+$', 'g' + (ignoreCase\n                ? 'i'\n                : '')), exports.EMPTY);\n        }\n        return source.replace(/^\\s+|\\s+$/g, exports.EMPTY);\n    }\n    exports.trim = trim;\n    /**\n     * Takes any arg\n     * @param source\n     * @param args\n     * @returns {string}\n     */\n    function format(source) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        return supplant(source, args);\n    }\n    exports.format = format;\n    //\n    /**\n     * This takes a string and replaces '{string}' with the respected parameter.\n     * Also allows for passing an array in order to use '{n}' notation.\n     * Not limited to an array's indexes.  For example, {length} is allowed.\n     * Based upon Crockford's supplant function.\n     * @param source\n     * @param params\n     * @returns {string}\n     */\n    function supplant(source, params) {\n        var oIsArray = (params) instanceof (Array);\n        return source.replace(/{([^{}]*)}/g, function (a, b) {\n            var n = b;\n            if (oIsArray) {\n                var i = parseInt(b);\n                if (!isNaN(i))\n                    n = i;\n            }\n            var r = params[n];\n            switch (typeof r) {\n                case Types_1.Type.STRING:\n                case Types_1.Type.NUMBER:\n                case Types_1.Type.BOOLEAN:\n                    return r;\n                default:\n                    return (r && Types_1.Type.hasMemberOfType(r, \"toString\", Types_1.Type.FUNCTION))\n                        ? r.toString()\n                        : a;\n            }\n        });\n    }\n    exports.supplant = supplant;\n    function canMatch(source, match) {\n        if (!Types_1.Type.isString(source) || !match)\n            return false;\n        if (source === match)\n            return true;\n        if (match.length < source.length)\n            return null;\n    }\n    /**\n     * Returns true if the pattern matches the beginning of the source.\n     * @param source\n     * @param pattern\n     * @returns {boolean}\n     */\n    function startsWith(source, pattern) {\n        var m = canMatch(source, pattern);\n        return Types_1.Type.isBoolean(m) ? m : source.indexOf(pattern) == 0;\n    }\n    exports.startsWith = startsWith;\n    /**\n     * Returns true if the pattern matches the end of the source.\n     * @param source\n     * @param pattern\n     * @returns {boolean}\n     */\n    function endsWith(source, pattern) {\n        var m = canMatch(source, pattern);\n        return Types_1.Type.isBoolean(m) ? m : source.lastIndexOf(pattern) == (source.length - pattern.length);\n    }\n    exports.endsWith = endsWith;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../Types\";\r\n\r\nexport const EMPTY:string = '';\r\n\r\n\r\n\r\n/**\r\n * Returns a numerical (integer) hash code of the string.  Can be used for identifying inequality of contents, but two different strings in rare cases will have the same hash code.\r\n * @param source\r\n * @returns {number}\r\n */\r\nexport function getHashCode(source:string):number\r\n{\r\n\tlet hash = 0 | 0;\r\n\tif(source.length==0) return hash;\r\n\tfor(let i = 0, l = source.length; i<l; i++)\r\n\t{\r\n\t\tlet ch = source.charCodeAt(i);\r\n\t\thash = ((hash<<5) - hash) + ch;\r\n\t\thash |= 0; // Convert to 32bit integer\r\n\t}\r\n\treturn hash;\r\n}\r\n\r\nexport function repeat(source:string, count:number):string\r\n{\r\n\tlet result = EMPTY;\r\n\tif(!isNaN(count))\r\n\t{\r\n\t\tfor(let i = 0; i<count; i++)\r\n\t\t{\r\n\t\t\tresult += source;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nexport function fromChars(ch:number, count:number):string\r\nexport function fromChars(chars:number[]):string\r\nexport function fromChars(chOrChars:any, count:number = 1):string\r\n{\r\n\tif((chOrChars)instanceof(Array))\r\n\t{\r\n\t\tlet result = EMPTY;\r\n\t\tfor(let char of chOrChars)\r\n\t\t{\r\n\t\t\tresult += String.fromCharCode(char);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn repeat(String.fromCharCode(chOrChars), count);\r\n\t}\r\n}\r\n\r\n/**\r\n * Escapes a RegExp sequence.\r\n * @param source\r\n * @returns {string}\r\n */\r\nexport function escapeRegExp(source:string):string\r\n{\r\n\treturn source.replace(/[-[\\]\\/{}()*+?.\\\\^$|]/g, \"\\\\$&\");\r\n}\r\n\r\n/**\r\n * Can trim any character or set of characters from the ends of a string.\r\n * Uses a Regex escapement to replace them with empty.\r\n * @param source\r\n * @param chars A string or array of characters desired to be trimmed.\r\n * @param ignoreCase\r\n * @returns {string}\r\n */\r\nexport function trim(source:string, chars?:string|string[], ignoreCase?:boolean):string\r\n{\r\n\tif(chars===EMPTY) return source;\r\n\tif(chars)\r\n\t{\r\n\t\tconst escaped = escapeRegExp((chars)instanceof(Array) ? chars.join() : <string>chars);\r\n\t\treturn source.replace(new RegExp('^[' + escaped + ']+|[' + escaped + ']+$', 'g' + (ignoreCase\r\n\t\t\t\t? 'i'\r\n\t\t\t\t: '')), EMPTY);\r\n\t}\r\n\r\n\treturn source.replace(/^\\s+|\\s+$/g, EMPTY);\r\n}\r\n\r\n/**\r\n * Takes any arg\r\n * @param source\r\n * @param args\r\n * @returns {string}\r\n */\r\nexport function format(source:string, ...args:any[])\r\n{\r\n\treturn supplant(source, args);\r\n}\r\n\r\n//\r\n\r\n/**\r\n * This takes a string and replaces '{string}' with the respected parameter.\r\n * Also allows for passing an array in order to use '{n}' notation.\r\n * Not limited to an array's indexes.  For example, {length} is allowed.\r\n * Based upon Crockford's supplant function.\r\n * @param source\r\n * @param params\r\n * @returns {string}\r\n */\r\nexport function supplant(source:string, params:{[key:string]:any}|any[]):string\r\n{\r\n\tconst oIsArray = (params)instanceof(Array);\r\n\treturn source.replace(/{([^{}]*)}/g,\r\n\t\t(a:string, b:string):any=>\r\n\t\t{\r\n\t\t\tlet n:any = b;\r\n\t\t\tif(oIsArray)\r\n\t\t\t{\r\n\t\t\t\tlet i = parseInt(b);\r\n\t\t\t\tif(!isNaN(i)) n = i;\r\n\t\t\t}\r\n\r\n\t\t\tlet r = (<any>params)[n];\r\n\t\t\tswitch(typeof r)\r\n\t\t\t{\r\n\t\t\t\tcase Type.STRING:\r\n\t\t\t\tcase Type.NUMBER:\r\n\t\t\t\tcase Type.BOOLEAN:\r\n\t\t\t\t\treturn r;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn (r && Type.hasMemberOfType(r, \"toString\", Type.FUNCTION))\r\n\t\t\t\t\t\t? r.toString()\r\n\t\t\t\t\t\t: a;\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n}\r\n\r\n\r\nfunction canMatch(source:string, match:string):boolean|null|void\r\n{\r\n\tif(!Type.isString(source) || !match) return false;\r\n\tif(source===match) return true;\r\n\tif(match.length<source.length) return null;\r\n}\r\n\r\n/**\r\n * Returns true if the pattern matches the beginning of the source.\r\n * @param source\r\n * @param pattern\r\n * @returns {boolean}\r\n */\r\nexport function startsWith(source:string, pattern:string):boolean\r\n{\r\n\tconst m = canMatch(source, pattern);\r\n\treturn Type.isBoolean(m) ? m : source.indexOf(pattern)==0;\r\n}\r\n\r\n/**\r\n * Returns true if the pattern matches the end of the source.\r\n * @param source\r\n * @param pattern\r\n * @returns {boolean}\r\n */\r\nexport function endsWith(source:string, pattern:string):boolean\r\n{\r\n\tconst m = canMatch(source, pattern);\r\n\treturn Type.isBoolean(m) ? m : source.lastIndexOf(pattern)==(source.length - pattern.length);\r\n}\r\n\r\n"]}
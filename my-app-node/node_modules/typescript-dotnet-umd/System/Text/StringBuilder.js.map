{"version":3,"sources":["System/Text/StringBuilder.js","System/Text/StringBuilder.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Object","defineProperty","value","Types_1","EMPTY","NEWLINE","StringBuilder","initial","_i","arguments","length","this","_latest","_partArray","appendThese","prototype","appendSingle","item","_","Type","OBJECT","FUNCTION","toString","push","items","forEach","s","append","appendLine","appendLines","i","get","enumerable","configurable","latest","join","delimiter","clear","dispose"],"mappings":";;;;;CAKA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,YAAaN,IAEhD,SAAUI,EAASF,GAClB,YACAM,QAAOC,eAAeP,EAAS,cAAgBQ,OAAO,GCT1D,IAAAC,GAAAP,EAAA,YAaMQ,EAAQ,GACRC,EAAU,OAEhBC,EAAA,WAQC,QAAAA,KDCW,ICDC,GAAAC,MAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,GAAAC,UAAAD,EAEXG,MAAKC,QAAU,KACfD,KAAKE,cACLF,KAAKG,YAAYP,GAkGnB,MA/FSD,GAAAS,UAAAC,aAAR,SAAqBC,GAEpB,GAAS,MAANA,EACH,CACC,GAAMC,GAAIP,IAEV,QADAO,EAAEN,QAAU,WACEK,IAEb,IAAKd,GAAAgB,KAAKC,OACV,IAAKjB,GAAAgB,KAAKE,SACTJ,EAAOA,EAAKK,WAGdJ,EAAEL,WAAWU,KAAKN,KAKpBX,EAAAS,UAAAD,YAAA,SAAYU,GAEX,GAAMN,GAAIP,IAEV,OADAa,GAAMC,QAAQ,SAAAC,GAAI,MAAAR,GAAEF,aAAaU,KAC1BR,GAGRZ,EAAAS,UAAAY,OAAA,WDJW,ICIJ,GAAAH,MAAAhB,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAgB,EAAAhB,GAAAC,UAAAD,EAGN,OADAG,MAAKG,YAAYU,GACVb,MAGRL,EAAAS,UAAAa,WAAA,WDFW,ICEA,GAAAJ,MAAAhB,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAgB,EAAAhB,GAAAC,UAAAD,EAGV,OADAG,MAAKkB,YAAYL,GACVb,MAGRL,EAAAS,UAAAc,YAAA,SAAYL,GAEX,GAAMN,GAAIP,IAWV,OAVAa,GAAMC,QACL,SAAAK,GAEO,MAAHA,IAEFZ,EAAEF,aAAac,GACfZ,EAAEL,WAAWU,KAAKlB,MAIda,GAeRlB,OAAAC,eAAIK,EAAAS,UAAA,WDROgB,ICQX,WAEC,MAAgC,KAAzBpB,KAAKE,WAAWH,QDPbsB,YAAY,EACZC,cAAc,ICSzB3B,EAAAS,UAAAO,SAAA,WAEC,GAAIY,GAASvB,KAAKC,OAIlB,OAHW,OAARsB,IACFvB,KAAKC,QAAUsB,EAASvB,KAAKE,WAAWsB,KAAK/B,IAEvC8B,GAGR5B,EAAAS,UAAAoB,KAAA,SAAKC,GAEJ,MAAOzB,MAAKE,WAAWsB,KAAKC,IAG7B9B,EAAAS,UAAAsB,MAAA,WAEC1B,KAAKE,WAAWH,OAAS,EACzBC,KAAKC,QAAU,MAGhBN,EAAAS,UAAAuB,QAAA,WAEC3B,KAAK0B,SAGP/B,IA9GaZ,GAAAY,cAAAA,EAgHbZ,EAAAA,WAAeY","file":"StringBuilder.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * .NET Reference: http://referencesource.microsoft.com/#mscorlib/system/text/StringBuilder.cs\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../Types\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Types_1 = require(\"../Types\");\n    /*****************************\n     * IMPORTANT NOTES ABOUT PERFORMANCE:\n     * http://jsperf.com/string-concatenation-looped\n     * http://jsperf.com/adding-strings-to-an-array\n     * http://jsperf.com/string-concatenation-versus-array-operations-with-join\n     *\n     * It is clearly inefficient to use a StringBuilder or LinkedList to build a string when you have a small set of string portions.\n     * StringBuilder will really show it's benefit likely somewhere above 1000 items.\n     *****************************/\n    var EMPTY = \"\";\n    var NEWLINE = \"\\r\\n\";\n    var StringBuilder = /** @class */ (function () {\n        function StringBuilder() {\n            var initial = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                initial[_i] = arguments[_i];\n            }\n            this._latest = null;\n            this._partArray = [];\n            this.appendThese(initial);\n        }\n        StringBuilder.prototype.appendSingle = function (item) {\n            if (item != null) {\n                var _ = this;\n                _._latest = null;\n                switch (typeof item) {\n                    case Types_1.Type.OBJECT:\n                    case Types_1.Type.FUNCTION:\n                        item = item.toString();\n                        break;\n                }\n                _._partArray.push(item); // Other primitive types can keep their format since a number or boolean is a smaller footprint than a string.\n            }\n        };\n        StringBuilder.prototype.appendThese = function (items) {\n            var _ = this;\n            items.forEach(function (s) { return _.appendSingle(s); });\n            return _;\n        };\n        StringBuilder.prototype.append = function () {\n            var items = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                items[_i] = arguments[_i];\n            }\n            this.appendThese(items);\n            return this;\n        };\n        StringBuilder.prototype.appendLine = function () {\n            var items = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                items[_i] = arguments[_i];\n            }\n            this.appendLines(items);\n            return this;\n        };\n        StringBuilder.prototype.appendLines = function (items) {\n            var _ = this;\n            items.forEach(function (i) {\n                if (i != null) {\n                    _.appendSingle(i);\n                    _._partArray.push(NEWLINE);\n                }\n            });\n            return _;\n        };\n        Object.defineProperty(StringBuilder.prototype, \"isEmpty\", {\n            /** /// These methods can only efficiently be added if not using a single array.\n             insert(index: number, value: string, count: number = 1): StringBuilder\n             {\n        \r\n            }\n        \r\n             remove(startIndex:number, length:number): StringBuilder\n             {\n        \r\n            }\n             /**/\n            get: function () {\n                return this._partArray.length === 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        StringBuilder.prototype.toString = function () {\n            var latest = this._latest;\n            if (latest == null)\n                this._latest = latest = this._partArray.join(EMPTY);\n            return latest;\n        };\n        StringBuilder.prototype.join = function (delimiter) {\n            return this._partArray.join(delimiter);\n        };\n        StringBuilder.prototype.clear = function () {\n            this._partArray.length = 0;\n            this._latest = null;\n        };\n        StringBuilder.prototype.dispose = function () {\n            this.clear();\n        };\n        return StringBuilder;\n    }());\n    exports.StringBuilder = StringBuilder;\n    exports.default = StringBuilder;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * .NET Reference: http://referencesource.microsoft.com/#mscorlib/system/text/StringBuilder.cs\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../Types\";\r\nimport {IDisposable} from \"../Disposable/IDisposable\";\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/string-concatenation-looped\r\n * http://jsperf.com/adding-strings-to-an-array\r\n * http://jsperf.com/string-concatenation-versus-array-operations-with-join\r\n *\r\n * It is clearly inefficient to use a StringBuilder or LinkedList to build a string when you have a small set of string portions.\r\n * StringBuilder will really show it's benefit likely somewhere above 1000 items.\r\n *****************************/\r\n\r\nconst EMPTY = \"\";\r\nconst NEWLINE = \"\\r\\n\";\r\n\r\nexport class StringBuilder implements IDisposable\r\n\t// Adding IDisposable allows for use with System.using();\r\n\t// ... and since this may end up being a large array container, might be a good idea to allow for flexible cleanup.\r\n{\r\n\t//noinspection JSMismatchedCollectionQueryUpdate\r\n\tprivate readonly _partArray:any[];\r\n\tprivate _latest:string|null; // AKA persistentString\r\n\r\n\tconstructor(...initial:any[])\r\n\t{\r\n\t\tthis._latest = null;\r\n\t\tthis._partArray = [];\r\n\t\tthis.appendThese(initial);\r\n\t}\r\n\r\n\tprivate appendSingle(item:any):void\r\n\t{\r\n\t\tif(item!=null)\r\n\t\t{\r\n\t\t\tconst _ = this;\r\n\t\t\t_._latest = null;\r\n\t\t\tswitch(typeof item)\r\n\t\t\t{\r\n\t\t\t\tcase Type.OBJECT:\r\n\t\t\t\tcase Type.FUNCTION:\r\n\t\t\t\t\titem = item.toString();\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t_._partArray.push(item); // Other primitive types can keep their format since a number or boolean is a smaller footprint than a string.\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tappendThese(items:any[]):StringBuilder\r\n\t{\r\n\t\tconst _ = this;\r\n\t\titems.forEach(s=> _.appendSingle(s));\r\n\t\treturn _;\r\n\t}\r\n\r\n\tappend(...items:any[]):StringBuilder\r\n\t{\r\n\t\tthis.appendThese(items);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tappendLine(...items:any[]):StringBuilder\r\n\t{\r\n\t\tthis.appendLines(items);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tappendLines(items:any[]):StringBuilder\r\n\t{\r\n\t\tconst _ = this;\r\n\t\titems.forEach(\r\n\t\t\ti=>\r\n\t\t\t{\r\n\t\t\t\tif(i!=null)\r\n\t\t\t\t{\r\n\t\t\t\t\t_.appendSingle(i);\r\n\t\t\t\t\t_._partArray.push(NEWLINE);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\treturn _;\r\n\t}\r\n\r\n\t/** /// These methods can only efficiently be added if not using a single array.\r\n\t insert(index: number, value: string, count: number = 1): StringBuilder\r\n\t {\r\n\r\n\t}\r\n\r\n\t remove(startIndex:number, length:number): StringBuilder\r\n\t {\r\n\r\n\t}\r\n\t /**/\r\n\r\n\tget isEmpty():boolean\r\n\t{\r\n\t\treturn this._partArray.length===0;\r\n\t}\r\n\r\n\ttoString():string\r\n\t{\r\n\t\tlet latest = this._latest;\r\n\t\tif(latest==null)\r\n\t\t\tthis._latest = latest = this._partArray.join(EMPTY);\r\n\r\n\t\treturn latest;\r\n\t}\r\n\r\n\tjoin(delimiter:string):string\r\n\t{\r\n\t\treturn this._partArray.join(delimiter);\r\n\t}\r\n\r\n\tclear():void\r\n\t{\r\n\t\tthis._partArray.length = 0;\r\n\t\tthis._latest = null;\r\n\t}\r\n\r\n\tdispose():void\r\n\t{\r\n\t\tthis.clear();\r\n\t}\r\n\r\n}\r\n\r\nexport default StringBuilder;\r\n"]}
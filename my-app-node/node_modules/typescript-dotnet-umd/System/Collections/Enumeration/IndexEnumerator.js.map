{"version":3,"sources":["System/Collections/Enumeration/IndexEnumerator.js","System/Collections/Enumeration/IndexEnumerator.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Object","defineProperty","value","EnumeratorBase_1","extends_1","__extends","IndexEnumerator","_super","sourceFactory","source","_this","this","call","len","length","Error","isFinite","step","pointer","Math","floor","yielder","isNaN","yieldBreak","current","yieldReturn","_isEndless","EnumeratorBase"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,mBAAoB,oBAAqBN,IAE5E,SAAUI,EAASF,GAClB,YACAM,QAAOC,eAAeP,EAAS,cAAgBQ,OAAO,GCT1D,IAAAC,GAAAP,EAAA,oBACAQ,EAAAR,EAAA,oBAEMS,EAAYD,EAAAA,WAUlBE,EAAA,SAAAC,GAGC,QAAAD,GACCE,GADD,GAIKC,GAJLC,EAAAC,ID6CW,OCxCVD,GAAAH,EAAAK,KAAAD,KACC,WAGC,GADAF,EAASD,IACNC,GAAUA,EAAOA,OACpB,CACC,GAAMI,GAAMJ,EAAOK,MACnB,IAAGD,EAAI,EACN,KAAM,IAAIE,OAAM,iCAEjB,KAAIC,SAASH,GACZ,KAAM,IAAIE,OAAM,4BAEjB,IAAGF,GAAqB,IAAdJ,EAAOQ,KAChB,KAAM,IAAIF,OAAM,0CACjB,IAAIG,GAAUT,EAAOS,OACrB,IAAIA,GAEC,GAAGA,GAASC,KAAKC,MAAMF,GAC3B,KAAM,IAAIH,OAAM,0CAA4CG,EAAU,sBAFtEA,GAAU,CAGXT,GAAOS,QAAUA,CAEjB,IAAID,GAAOR,EAAOQ,IAClB,IAAIA,GAEC,GAAGA,GAAME,KAAKC,MAAMH,GACxB,KAAM,IAAIF,OAAM,uCAAyCE,EAAO,sBAFhEA,GAAO,CAGRR,GAAOQ,KAAOA,IAIhB,SAACI,GAEA,GAAIR,GAAOJ,GAAUA,EAAOA,OAAUA,EAAOK,OAAS,CACtD,KAAID,GAAOS,MAAMT,GAChB,MAAOQ,GAAQE,YAChB,IAAMC,GAAkBf,EAAOS,OAI/B,OAHmB,OAAhBT,EAAOS,UAAeT,EAAOS,QAAU,GACtCT,EAAOQ,OAAMR,EAAOQ,KAAO,GAC/BR,EAAOS,QAAUT,EAAOS,QAAUT,EAAOQ,KACjCO,EAAQX,GAAOW,GAAS,EAC7BH,EAAQI,YAAYhB,EAAOA,OAAOe,IAClCH,EAAQE,cAGZ,WAEId,IAEFA,EAAOA,OAAc,SAGvBE,KACDD,EAAKgB,YAAa,EDbDhB,ECenB,MA/DwCL,GAAAC,EAAAC,GA+DxCD,GA/DwCH,EAAAwB,eAA3BjC,GAAAY,gBAAAA,EAiEbZ,EAAAA,WAAeY","file":"IndexEnumerator.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./EnumeratorBase\", \"../../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var EnumeratorBase_1 = require(\"./EnumeratorBase\");\n    var extends_1 = require(\"../../../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var IndexEnumerator = /** @class */ (function (_super) {\n        __extends(IndexEnumerator, _super);\n        function IndexEnumerator(sourceFactory) {\n            var _this = this;\n            var source;\n            _this = _super.call(this, function () {\n                source = sourceFactory();\n                if (source && source.source) {\n                    var len = source.length;\n                    if (len < 0)\n                        throw new Error(\"length must be zero or greater\");\n                    if (!isFinite(len))\n                        throw new Error(\"length must finite number\");\n                    if (len && source.step === 0)\n                        throw new Error(\"Invalid IndexEnumerator step value (0).\");\n                    var pointer = source.pointer;\n                    if (!pointer)\n                        pointer = 0;\n                    else if (pointer != Math.floor(pointer))\n                        throw new Error(\"Invalid IndexEnumerator pointer value (\" + pointer + \") has decimal.\");\n                    source.pointer = pointer;\n                    var step = source.step;\n                    if (!step)\n                        step = 1;\n                    else if (step != Math.floor(step))\n                        throw new Error(\"Invalid IndexEnumerator step value (\" + step + \") has decimal.\");\n                    source.step = step;\n                }\n            }, function (yielder) {\n                var len = (source && source.source) ? source.length : 0;\n                if (!len || isNaN(len))\n                    return yielder.yieldBreak();\n                var current = source.pointer;\n                if (source.pointer == null)\n                    source.pointer = 0; // should never happen but is in place to negate compiler warnings.\n                if (!source.step)\n                    source.step = 1; // should never happen but is in place to negate compiler warnings.\n                source.pointer = source.pointer + source.step;\n                return (current < len && current >= 0)\n                    ? yielder.yieldReturn(source.source[current])\n                    : yielder.yieldBreak();\n            }, function () {\n                if (source) {\n                    source.source = null;\n                }\n            }) || this;\n            _this._isEndless = false;\n            return _this;\n        }\n        return IndexEnumerator;\n    }(EnumeratorBase_1.EnumeratorBase));\n    exports.IndexEnumerator = IndexEnumerator;\n    exports.default = IndexEnumerator;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {EnumeratorBase} from \"./EnumeratorBase\";\r\nimport __extendsImport from \"../../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nexport interface IndexEnumeratorSource<T> {\r\n\tsource:{ [index:number]:T };\r\n\tlength:number;\r\n\tstep?:number\r\n\r\n\tpointer?:number;\r\n}\r\n\r\nexport class IndexEnumerator<T> extends EnumeratorBase<T>\r\n{\r\n\r\n\tconstructor(\r\n\t\tsourceFactory:() => IndexEnumeratorSource<T>)\r\n\t{\r\n\r\n\t\tlet source:IndexEnumeratorSource<T>;\r\n\t\tsuper(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tsource = sourceFactory();\r\n\t\t\t\tif(source && source.source)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst len = source.length;\r\n\t\t\t\t\tif(len<0) // Null is allowed but will exit immediately.\r\n\t\t\t\t\t\tthrow new Error(\"length must be zero or greater\");\r\n\r\n\t\t\t\t\tif(!isFinite(len))\r\n\t\t\t\t\t\tthrow new Error(\"length must finite number\");\r\n\r\n\t\t\t\t\tif(len && source.step===0)\r\n\t\t\t\t\t\tthrow new Error(\"Invalid IndexEnumerator step value (0).\");\r\n\t\t\t\t\tlet pointer = source.pointer;\r\n\t\t\t\t\tif(!pointer)\r\n\t\t\t\t\t\tpointer = 0;\r\n\t\t\t\t\telse if(pointer!=Math.floor(pointer))\r\n\t\t\t\t\t\tthrow new Error(\"Invalid IndexEnumerator pointer value (\" + pointer + \") has decimal.\");\r\n\t\t\t\t\tsource.pointer = pointer;\r\n\r\n\t\t\t\t\tlet step = source.step;\r\n\t\t\t\t\tif(!step)\r\n\t\t\t\t\t\tstep = 1;\r\n\t\t\t\t\telse if(step!=Math.floor(step))\r\n\t\t\t\t\t\tthrow new Error(\"Invalid IndexEnumerator step value (\" + step + \") has decimal.\");\r\n\t\t\t\t\tsource.step = step;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\tlet len = (source && source.source) ? source.length : 0;\r\n\t\t\t\tif(!len || isNaN(len))\r\n\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\tconst current = <number>source.pointer;\r\n\t\t\t\tif(source.pointer==null) source.pointer = 0; // should never happen but is in place to negate compiler warnings.\r\n\t\t\t\tif(!source.step) source.step = 1; // should never happen but is in place to negate compiler warnings.\r\n\t\t\t\tsource.pointer = source.pointer + source.step;\r\n\t\t\t\treturn (current<len && current>=0)\r\n\t\t\t\t\t? yielder.yieldReturn(source.source[current])\r\n\t\t\t\t\t: yielder.yieldBreak();\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tif(source)\r\n\t\t\t\t{\r\n\t\t\t\t\tsource.source = <any>null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\tthis._isEndless = false;\r\n\t}\r\n}\r\n\r\nexport default IndexEnumerator;"]}
{"version":3,"sources":["System/Collections/Enumeration/Randomizer.js","System/Collections/Enumeration/Randomizer.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Object","defineProperty","value","SimpleEnumerableBase_1","Enumerator_1","Randomizer","_super","source","_allowReset","_this","call","this","_buffer","toArray","_pointer","length","__extends","prototype","_canMoveNext","p","isNaN","moveNext","_","i","Math","floor","random","b","last","_current","incrementIndex","reset","dispose","NaN","getIsEndless","SimpleEnumerableBase"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,yBAA0B,gBAAiBN,IAE9E,SAAUI,EAASF,GAClB,YACAM,QAAOC,eAAeP,EAAS,cAAgBQ,OAAO,GCT1D,IAAAC,GAAAP,EAAA,0BAEAQ,EAAAR,EAAA,gBAMAS,EAAA,SAAAC,GAKC,QAAAD,GACCE,EACiBC,GAAA,SAAAA,IAAAA,GAAA,EAFlB,IAAAC,GAICH,EAAAI,KAAAC,OAAOA,IDOG,OCTOF,GAAAD,YAAAA,EAGjBC,EAAKG,QAAUR,EAAAS,QAAQN,GACvBE,EAAKK,SAAWL,EAAKG,QAAQG,ODKZN,EC2DnB,MA3EmCO,WAAAX,EAAAC,GAcxBD,EAAAY,UAAAC,aAAV,WAEC,GAAMC,GAAIR,KAAKG,QACf,QAAQM,MAAMD,IAAMA,EAAE,GAGvBd,EAAAY,UAAAI,SAAA,WAEC,GAAMC,GAAIX,IACV,IAAGW,EAAEJ,eACL,CACC,GACCC,GAAIR,KAAKG,SACTS,EAAIC,KAAKC,MAAMD,KAAKE,SAASP,GAC7BQ,EAAIhB,KAAKC,QACTV,EAAQyB,EAAEJ,GACVK,EAAOT,EAAI,CAYZ,OATAQ,GAAEJ,GAAKI,EAAEC,GACTD,EAAEC,GAAa,KAEXjB,KAAKH,aAAeoB,EAAK,IAAI,IAChCD,EAAEZ,OAASa,GAEZjB,KAAKG,SAAWc,EAChBN,EAAEO,SAAW3B,EACboB,EAAEQ,kBACK,EAGR,OAAO,GAGRzB,EAAAY,UAAAc,MAAA,WAEC,IAAGpB,KAAKH,YAOP,KAAM,uEALN,KAAIG,KAAKC,QAAS,KAAM,gDACxBD,MAAKG,SAAWH,KAAKC,QAAQG,OAC7BT,EAAAW,UAAMc,MAAKrB,KAAAC,OAMbN,EAAAY,UAAAe,QAAA,WAEC1B,EAAAW,UAAMc,MAAKrB,KAAAC,KACX,IAAIgB,GAAIhB,KAAKC,OACPD,MAAMC,QAAU,KACtBD,KAAKG,SAAWmB,IACbN,IAAGA,EAAEZ,OAAS,IAGRV,EAAAY,UAAAiB,aAAV,WAEC,OAAO,GAIT7B,GA3EmCF,EAAAgC,qBAAtBzC,GAAAW,WAAAA","file":"Randomizer.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./SimpleEnumerableBase\", \"./Enumerator\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var SimpleEnumerableBase_1 = require(\"./SimpleEnumerableBase\");\n    var Enumerator_1 = require(\"./Enumerator\");\n    /**\n     * Creates a randomized version of the source.\n     * Note: An iterator will always require a arrayCopy (buffer) to pull random results one by one.\n     */\n    var Randomizer = /** @class */ (function (_super) {\n        __extends(Randomizer, _super);\n        function Randomizer(source, _allowReset) {\n            if (_allowReset === void 0) { _allowReset = false; }\n            var _this = _super.call(this) || this;\n            _this._allowReset = _allowReset;\n            _this._buffer = Enumerator_1.toArray(source);\n            _this._pointer = _this._buffer.length;\n            return _this;\n        }\n        Randomizer.prototype._canMoveNext = function () {\n            var p = this._pointer;\n            return !isNaN(p) && p > 0;\n        };\n        Randomizer.prototype.moveNext = function () {\n            var _ = this;\n            if (_._canMoveNext()) {\n                var p = this._pointer, // Where were we?\n                i = Math.floor(Math.random() * p), // Pick one.\n                b = this._buffer, value = b[i], last = p - 1;\n                b[i] = b[last]; // Take the last one and put it here.\n                b[last] = null; // clear possible reference.\n                if (!this._allowReset && last % 32 == 0)\n                    b.length = last;\n                this._pointer = last;\n                _._current = value;\n                _.incrementIndex();\n                return true;\n            }\n            return false;\n        };\n        Randomizer.prototype.reset = function () {\n            if (this._allowReset) {\n                if (!this._buffer)\n                    throw \"Randomizer cannot be reset.  Already disposed.\";\n                this._pointer = this._buffer.length;\n                _super.prototype.reset.call(this);\n            }\n            else\n                throw \"Reset not allowed.  To allow for reset, specify so when constructing.\";\n        };\n        Randomizer.prototype.dispose = function () {\n            _super.prototype.reset.call(this); // Note... don't call this.reset() :|\n            var b = this._buffer;\n            this._buffer = null;\n            this._pointer = NaN;\n            if (b)\n                b.length = 0;\n        };\n        Randomizer.prototype.getIsEndless = function () {\n            return false;\n        };\n        return Randomizer;\n    }(SimpleEnumerableBase_1.SimpleEnumerableBase));\n    exports.Randomizer = Randomizer;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {SimpleEnumerableBase} from \"./SimpleEnumerableBase\";\r\nimport {ForEachEnumerable} from \"./ForEachEnumerable\";\r\nimport {toArray} from \"./Enumerator\";\r\n\r\n/**\r\n * Creates a randomized version of the source.\r\n * Note: An iterator will always require a arrayCopy (buffer) to pull random results one by one.\r\n */\r\nexport class Randomizer<T> extends SimpleEnumerableBase<T>\r\n{\r\n\tprivate readonly _buffer:T[];\r\n\tprivate _pointer:number;\r\n\r\n\tconstructor(\r\n\t\tsource:ForEachEnumerable<T>,\r\n\t\tprivate readonly _allowReset:boolean = false)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._buffer = toArray(source);\r\n\t\tthis._pointer = this._buffer.length;\r\n\t}\r\n\r\n\tprotected _canMoveNext():boolean\r\n\t{\r\n\t\tconst p = this._pointer;\r\n\t\treturn !isNaN(p) && p>0;\r\n\t}\r\n\r\n\tmoveNext():boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tif(_._canMoveNext())\r\n\t\t{\r\n\t\t\tconst\r\n\t\t\t\tp = this._pointer, // Where were we?\r\n\t\t\t\ti = Math.floor(Math.random()*p), // Pick one.\r\n\t\t\t\tb = this._buffer,\r\n\t\t\t\tvalue = b[i],\r\n\t\t\t\tlast = p - 1;\r\n\r\n\r\n\t\t\tb[i] = b[last]; // Take the last one and put it here.\r\n\t\t\tb[last] = <any>null; // clear possible reference.\r\n\r\n\t\t\tif(!this._allowReset && last%32==0) // Shrink?\r\n\t\t\t\tb.length = last;\r\n\r\n\t\t\tthis._pointer = last;\r\n\t\t\t_._current = value;\r\n\t\t\t_.incrementIndex();\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\treset():void\r\n\t{\r\n\t\tif(this._allowReset)\r\n\t\t{\r\n\t\t\tif(!this._buffer) throw \"Randomizer cannot be reset.  Already disposed.\";\r\n\t\t\tthis._pointer = this._buffer.length;\r\n\t\t\tsuper.reset();\r\n\t\t}\r\n\t\telse\r\n\t\t\tthrow \"Reset not allowed.  To allow for reset, specify so when constructing.\";\r\n\t}\r\n\r\n\tdispose():void\r\n\t{\r\n\t\tsuper.reset(); // Note... don't call this.reset() :|\r\n\t\tlet b = this._buffer;\r\n\t\t(<any>this)._buffer = null;\r\n\t\tthis._pointer = NaN;\r\n\t\tif(b) b.length = 0;\r\n\t}\r\n\r\n\tprotected getIsEndless():boolean\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n}"]}
{"version":3,"sources":["System/Collections/LinkedList.js","System/Collections/LinkedList.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","ensureExternal","node","list","ArgumentNullException_1","ArgumentNullException","external","LinkedListNode","getInternal","InvalidOperationException_1","InvalidOperationException","n","_nodeInternal","detachExternal","e","_list","VOID0","Object","defineProperty","value","Compare_1","LinkedNodeList_1","CollectionBase_1","extends_1","__extends","InternalNode","previous","next","this","prototype","assertDetached","LinkedList","_super","source","equalityComparer","areEqual","_this","call","_listInternal","LinkedNodeList","_importEntries","assertVersion","version","_onDispose","l","dispose","getCount","li","unsafeCount","_addInternal","entry","addNode","_removeInternal","max","Infinity","_","equals","_equalityComparer","removedCount","forEach","_removeNodeInternal","_clearInternal","clear","action","useCopy","throwIfDisposed","i","getEnumerator","valueEnumeratorFrom","_findFirst","first","_findLast","prev","last","removeOnce","remove","get","enumerable","configurable","getValueAt","index","getNodeAt","find","findLast","addFirst","assertModifiable","addNodeBefore","_signalModification","addLast","add","removeNode","removeFirst","removeLast","removeAt","addBefore","before","addAfter","after","addNodeAfter","CollectionBase","throwIfDetached","Error","set"],"mappings":";;;;;CAKA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,aAAc,mBAAoB,0CAA2C,sCAAuC,mBAAoB,iBAAkBN,IAE7L,SAAUI,EAASF,GAClB,YC2CJ,SAAAM,GACCC,EACAC,GAEA,IAAID,EACH,MAAO,KACR,KAAIC,EACH,KAAM,IAAIC,GAAAC,sBAAsB,OAEjC,IAAIC,GAAWJ,EAAKI,QAIpB,OAHIA,KACHJ,EAAKI,SAAWA,EAAW,GAAIC,GAAkBJ,EAAMD,IAEjDI,GAAY,KAGpB,QAAAE,GAAwBN,EAAyBC,GAEhD,IAAID,EACH,KAAM,IAAIE,GAAAC,sBAAsB,OACjC,KAAIF,EACH,KAAM,IAAIC,GAAAC,sBAAsB,OAEjC,IAAGH,EAAKC,MAAMA,EACb,KAAM,IAAIM,GAAAC,0BACT,8CAEF,IAAIC,GAA0BT,EAAMU,aACpC,KAAID,EACH,KAAM,IAAIF,GAAAC,0BACT,8BAEF,OAAOC,GAGR,QAAAE,GAAwBX,GAEvB,GAAGA,EACH,CACC,GAAMY,GAAQZ,EAAKI,QAChBQ,KAEFA,EAAEC,MAAQC,EACVF,EAAEF,cAAgBI,GAEnBd,EAAKI,SAAWU,GDvFdC,OAAOC,eAAevB,EAAS,cAAgBwB,OAAO,GCT1D,IAAAC,GAAAvB,EAAA,cACAwB,EAAAxB,EAAA,oBACAY,EAAAZ,EAAA,2CACAO,EAAAP,EAAA,uCACAyB,EAAAzB,EAAA,oBAOA0B,EAAA1B,EAAA,iBAEM2B,EAAYD,EAAAA,WAEZP,EAAkB,OAcxBS,EAAA,WAGC,QAAAA,GACQN,EACAO,EACAC,GAFAC,KAAAT,MAAAA,EACAS,KAAAF,SAAAA,EACAE,KAAAD,KAAAA,EAcT,MARCF,GAAAI,UAAAC,eAAA,WAEC,GAAGF,KAAKD,MAAQC,KAAKF,SACpB,KAAM,IAAIjB,GAAAC,0BACT,wCACF,QAAO,GAGTe,KAmDAM,EAAA,SAAAC,GAKC,QAAAD,GACCE,EACAC,GAAA,SAAAA,IAAAA,EAAyCd,EAAAe,SAF1C,IAAAC,GAICJ,EAAAK,KAAAT,KAAMZ,EAAOkB,IAAiBN,ID3BpB,OC4BVQ,GAAKE,cAAgB,GAAIjB,GAAAkB,eACzBH,EAAKI,eAAeP,GD7BHG,ECqRnB,MAlQQZ,GAAAO,EAAAC,GAaGD,EAAAF,UAAAY,cAAV,SAAwBC,GAEvB,MAAGd,MAAKU,cACAV,KAAKU,cAAcG,cAAcC,GAEjCV,EAAAH,UAAMY,cAAaJ,KAAAT,KAACc,IAGnBX,EAAAF,UAAAc,WAAV,WAECX,EAAAH,UAAMc,WAAUN,KAAAT,KAChB,IAAMgB,GAAIhB,KAAKU,aACTV,MAAMU,cAAgB,KAC5BM,EAAEC,WAGOd,EAAAF,UAAAiB,SAAV,WAEC,GAAMC,GAAKnB,KAAKU,aAChB,OAAOS,GAAKA,EAAGC,YAAc,GAGpBjB,EAAAF,UAAAoB,aAAV,SAAuBC,GAGtB,MADAtB,MAAKU,cAAca,QAAQ,GAAI1B,GAAayB,KACrC,GAGEnB,EAAAF,UAAAuB,gBAAV,SAA0BF,EAASG,GAAA,SAAAA,IAAAA,EAAAC,EAAAA,EAElC,IAAMC,GAAS3B,KACT4B,EAASD,EAAEE,kBACXtD,EAASoD,EAAEjB,cACboB,EAAe,CAUnB,OARAvD,GAAKwD,QAAQ,SAAAzD,GAKZ,MAHGA,IAAQsD,EAAON,EAAOhD,EAAKiB,QAAUoC,EAAEK,oBAAoB1D,IAC7DwD,IAEMA,EAAaL,IAClB,GAEIK,GAGE3B,EAAAF,UAAAgC,eAAV,WAEC,GAAM1D,GAAOyB,KAAKU,aAElB,OADAnC,GAAKwD,QAAQ,SAAAzD,GAAM,MAAAW,GAAeX,KAC3BC,EAAK2D,SAKb/B,EAAAF,UAAA8B,QAAA,SAAQI,EACPC,GAGA,MAHA,UAAAA,IAAAA,GAAA,GAEApC,KAAKqC,kBACED,EACJhC,EAAAH,UAAM8B,QAAOtB,KAAAT,KAACmC,EAAQC,GACtBpC,KAAKU,cAAcqB,QAAQ,SAACzD,EAAMgE,GAAI,MAAAH,GAAY7D,EAAKiB,MAAO+C,MAMlEnC,EAAAF,UAAAsC,cAAA,WAGC,MADAvC,MAAKqC,kBACE5C,EAAAkB,eAAe6B,oBAA4BxC,KAAKU,gBAKhDP,EAAAF,UAAAwC,WAAR,SAAmBnB,GAQlB,IALA,GACCK,GAAS3B,KACT4B,EAASD,EAAEE,kBAER9B,EAAW4B,EAAEjB,eAAiBiB,EAAEjB,cAAcgC,MAC5C3C,GACN,CACC,GAAG6B,EAAON,EAAOvB,EAAKR,OACrB,MAAOQ,EACRA,GAAOA,EAAKA,KAEb,MAAO,OAGAI,EAAAF,UAAA0C,UAAR,SAAkBrB,GAQjB,IALA,GACCK,GAAS3B,KACT4B,EAASD,EAAEE,kBAERe,EAAWjB,EAAEjB,eAAiBiB,EAAEjB,cAAcmC,KAC5CD,GACN,CACC,GAAGhB,EAAON,EAAOsB,EAAKrD,OACrB,MAAOqD,EACRA,GAAOA,EAAK9C,SAEb,MAAO,OAGRK,EAAAF,UAAA6C,WAAA,SAAWxB,GAEV,MAA+B,KAAxBtB,KAAK+C,OAAOzB,EAAO,IAG3BjC,OAAAC,eAAIa,EAAAF,UAAA,SDpEO+C,ICoEX,WAEC,GAAM7B,GAAKnB,KAAKU,aAChB,OAAOS,IAAM9C,EAAe8C,EAAGuB,MAAO1C,ODnE5BiD,YAAY,EACZC,cAAc,ICqEzB7D,OAAAC,eAAIa,EAAAF,UAAA,cDlEO+C,ICkEX,WAEC,GAAM7B,GAAKnB,KAAKU,cAAepC,EAAO6C,GAAMA,EAAGuB,KAC/C,OAAOpE,GAAOA,EAAKiB,MAAQH,GDjEjB6D,YAAY,EACZC,cAAc,ICmEzB7D,OAAAC,eAAIa,EAAAF,UAAA,QDhEO+C,ICgEX,WAEC,GAAM7B,GAAKnB,KAAKU,aAChB,OAAOrC,GAAe8C,EAAG0B,KAAM7C,OD/DrBiD,YAAY,EACZC,cAAc,ICiEzB7D,OAAAC,eAAIa,EAAAF,UAAA,aD9DO+C,IC8DX,WAEC,GAAM7B,GAAKnB,KAAKU,cAAepC,EAAO6C,GAAMA,EAAG0B,IAC/C,OAAOvE,GAAOA,EAAKiB,MAAQH,GD7DjB6D,YAAY,EACZC,cAAc,ICkEzB/C,EAAAF,UAAAkD,WAAA,SAAWC,GAEV,GAAMjC,GAAKnB,KAAKU,cAAepC,EAAO6C,GAAMA,EAAGkC,UAAUD,EACzD,OAAO9E,GAAOA,EAAKiB,MAAQH,GAG5Be,EAAAF,UAAAoD,UAAA,SAAUD,GAET,GAAMjC,GAAKnB,KAAKU,aAChB,OAAOS,IAAM9C,EAAe8C,EAAGkC,UAAUD,GAAQpD,OAGlDG,EAAAF,UAAAqD,KAAA,SAAKhC,GAEJ,GAAMH,GAAKnB,KAAKU,aAChB,OAAOS,IAAM9C,EAAe2B,KAAKyC,WAAWnB,GAAQtB,OAGrDG,EAAAF,UAAAsD,SAAA,SAASjC,GAER,GAAMH,GAAKnB,KAAKU,aAChB,OAAOS,IAAM9C,EAAe2B,KAAK2C,UAAUrB,GAAQtB,OAGpDG,EAAAF,UAAAuD,SAAA,SAASlC,GAKR,MAHAtB,MAAKyD,mBACLzD,KAAKU,cAAcgD,cAAc,GAAI7D,GAAayB,IAClDtB,KAAK2D,qBAAoB,GAClB3D,MAGRG,EAAAF,UAAA2D,QAAA,SAAQtC,GAEP,MAAOtB,MAAK6D,IAAIvC,IAGTnB,EAAAF,UAAA+B,oBAAR,SAA4B1D,GAE3B,GAAMqD,GAAI3B,IACV,UAAG1B,IAAQqD,EAAEjB,cAAcoD,WAAWxF,MAErCW,EAAeX,GACfqD,EAAEgC,qBAAoB,IACf,IAKTxD,EAAAF,UAAA8D,YAAA,WAEC,GAAMpC,GAAI3B,IAEV,OADA2B,GAAE8B,mBACK9B,EAAEK,oBAAoBL,EAAEjB,cAAcgC,QAG9CvC,EAAAF,UAAA+D,WAAA,WAEC,GAAMrC,GAAI3B,IAEV,OADA2B,GAAE8B,mBACK9B,EAAEK,oBAAoBL,EAAEjB,cAAcmC,OAG9C1C,EAAAF,UAAAgE,SAAA,SAASb,GAER,GAAMzB,GAAI3B,IAEV,OADA2B,GAAE8B,mBACK9B,EAAEK,oBAAoBL,EAAEjB,cAAc2C,UAAUD,KAIxDjD,EAAAF,UAAA6D,WAAA,SAAWxF,GAEV,GAAMqD,GAAI3B,IAEV,OADA2B,GAAE8B,mBACK9B,EAAEK,oBAAoBpD,EAAYN,EAAMqD,KAGhDxB,EAAAF,UAAAiE,UAAA,SAAUC,EAA2B7C,GAEpC,GAAMK,GAAI3B,IAQV,OAPA2B,GAAE8B,mBACF9B,EAAEjB,cAAcgD,cACf,GAAI7D,GAAayB,GACjB1C,EAAYuF,EAAQxC,IAGrBA,EAAEgC,qBAAoB,GACf3D,MAGRG,EAAAF,UAAAmE,SAAA,SAASC,EAA0B/C,GAElC,GAAMK,GAAI3B,IAQV,OAPA2B,GAAE8B,mBACF9B,EAAEjB,cAAc4D,aACf,GAAIzE,GAAayB,GACjB1C,EAAYyF,EAAO1C,IAGpBA,EAAEgC,qBAAoB,GACf3D,MAGTG,GAlQQT,EAAA6E,eADKxG,GAAAoC,WAAAA,CAsQb,IAAAxB,GAAA,WAEC,QAAAA,GACSQ,EACAH,GADAgB,KAAAb,MAAAA,EACAa,KAAAhB,cAAAA,EAoEV,MAhESL,GAAAsB,UAAAuE,gBAAR,WAEC,IAAIxE,KAAKb,MACR,KAAM,IAAIsF,OAAM,sEAGlBpF,OAAAC,eAAIX,EAAAsB,UAAA,QDrGO+C,ICqGX,WAEC,MAAOhD,MAAKb,ODpGF8D,YAAY,EACZC,cAAc,ICsGzB7D,OAAAC,eAAIX,EAAAsB,UAAA,YDnGO+C,ICmGX,WAGC,MADAhD,MAAKwE,kBACEnG,EAAe2B,KAAKhB,cAAcc,SAAUE,KAAKb,QDlG9C8D,YAAY,EACZC,cAAc,ICoGzB7D,OAAAC,eAAIX,EAAAsB,UAAA,QDjGO+C,ICiGX,WAGC,MADAhD,MAAKwE,kBACEnG,EAAe2B,KAAKhB,cAAce,KAAMC,KAAKb,QDhG1C8D,YAAY,EACZC,cAAc,ICkGzB7D,OAAAC,eAAIX,EAAAsB,UAAA,SD/FO+C,IC+FX,WAGC,MADAhD,MAAKwE,kBACExE,KAAKhB,cAAcO,OD9FhBmF,ICiGX,SAAU1G,GAETgC,KAAKwE,kBACLxE,KAAKhB,cAAcO,MAAQvB,GDhGjBiF,YAAY,EACZC,cAAc,ICkGzBvE,EAAAsB,UAAAiE,UAAA,SAAU5C,GAIT,MAFAtB,MAAKwE,kBACLxE,KAAKb,MAAM+E,UAAUlE,KAAMsB,GACpBtB,MAGRrB,EAAAsB,UAAAmE,SAAA,SAAS9C,GAIR,MAFAtB,MAAKwE,kBACLxE,KAAKb,MAAMiF,SAASpE,KAAMsB,GACnBtB,MAIRrB,EAAAsB,UAAA8C,OAAA,WAEC,GAAMpB,GAAQ3B,KACRzB,EAAOoD,EAAExC,KACZZ,IAAMA,EAAKuF,WAAW9D,MACzB2B,EAAExC,MAAQC,EACVuC,EAAE3C,cAAgBI,GAGnBT,EAAAsB,UAAAgB,QAAA,WAECjB,KAAK+C,UAGPpE,IAEAZ,GAAAA,WAAeoC","file":"LinkedList.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../Compare\", \"./LinkedNodeList\", \"../Exceptions/InvalidOperationException\", \"../Exceptions/ArgumentNullException\", \"./CollectionBase\", \"../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Compare_1 = require(\"../Compare\");\n    var LinkedNodeList_1 = require(\"./LinkedNodeList\");\n    var InvalidOperationException_1 = require(\"../Exceptions/InvalidOperationException\");\n    var ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\n    var CollectionBase_1 = require(\"./CollectionBase\");\n    var extends_1 = require(\"../../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var VOID0 = void 0;\n    /*****************************\n     * IMPORTANT NOTES ABOUT PERFORMANCE:\n     * http://jsperf.com/simulating-a-queue\n     *\n     * Adding to an array is very fast, but modifying is slow.\n     * LinkedList wins when modifying contents.\n     * http://stackoverflow.com/questions/166884/array-versus-linked-list\n     *****************************/\n    /*\n     * An internal node is used to manage the order without exposing underlying link chain to the consumer.\n     */\n    var InternalNode = /** @class */ (function () {\n        function InternalNode(value, previous, next) {\n            this.value = value;\n            this.previous = previous;\n            this.next = next;\n        }\n        InternalNode.prototype.assertDetached = function () {\n            if (this.next || this.previous)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Adding a node that is already placed.\");\n            return true;\n        };\n        return InternalNode;\n    }());\n    function ensureExternal(node, list) {\n        if (!node)\n            return null;\n        if (!list)\n            throw new ArgumentNullException_1.ArgumentNullException(\"list\");\n        var external = node.external;\n        if (!external)\n            node.external = external = new LinkedListNode(list, node);\n        return external || null;\n    }\n    function getInternal(node, list) {\n        if (!node)\n            throw new ArgumentNullException_1.ArgumentNullException(\"node\");\n        if (!list)\n            throw new ArgumentNullException_1.ArgumentNullException(\"list\");\n        if (node.list != list)\n            throw new InvalidOperationException_1.InvalidOperationException(\"Provided node does not belong to this list.\");\n        var n = node._nodeInternal;\n        if (!n)\n            throw new InvalidOperationException_1.InvalidOperationException(\"Provided node is not valid.\");\n        return n;\n    }\n    function detachExternal(node) {\n        if (node) {\n            var e = node.external;\n            if (e) {\n                e._list = VOID0;\n                e._nodeInternal = VOID0;\n            }\n            node.external = VOID0;\n        }\n    }\n    var LinkedList = /** @class */ (function (_super) {\n        __extends(LinkedList, _super);\n        function LinkedList(source, equalityComparer) {\n            if (equalityComparer === void 0) { equalityComparer = Compare_1.areEqual; }\n            var _this = _super.call(this, VOID0, equalityComparer) || this;\n            _this._listInternal = new LinkedNodeList_1.LinkedNodeList();\n            _this._importEntries(source);\n            return _this;\n        }\n        LinkedList.prototype.assertVersion = function (version) {\n            if (this._listInternal)\n                return this._listInternal.assertVersion(version);\n            else\n                return _super.prototype.assertVersion.call(this, version);\n        };\n        LinkedList.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            var l = this._listInternal;\n            this._listInternal = null;\n            l.dispose();\n        };\n        LinkedList.prototype.getCount = function () {\n            var li = this._listInternal;\n            return li ? li.unsafeCount : 0;\n        };\n        LinkedList.prototype._addInternal = function (entry) {\n            this._listInternal.addNode(new InternalNode(entry));\n            return true;\n        };\n        LinkedList.prototype._removeInternal = function (entry, max) {\n            if (max === void 0) { max = Infinity; }\n            var _ = this, equals = _._equalityComparer, list = _._listInternal;\n            var removedCount = 0;\n            list.forEach(function (node) {\n                if (node && equals(entry, node.value) && _._removeNodeInternal(node))\n                    removedCount++;\n                return removedCount < max;\n            }, true /* override versioning check */);\n            return removedCount;\n        };\n        LinkedList.prototype._clearInternal = function () {\n            var list = this._listInternal;\n            list.forEach(function (node) { return detachExternal(node); });\n            return list.clear();\n        };\n        LinkedList.prototype.forEach = function (action, useCopy) {\n            if (useCopy === void 0) { useCopy = false; }\n            this.throwIfDisposed();\n            return useCopy\n                ? _super.prototype.forEach.call(this, action, useCopy)\n                : this._listInternal.forEach(function (node, i) { return action(node.value, i); });\n        };\n        // #endregion\n        // #region IEnumerable<T>\n        LinkedList.prototype.getEnumerator = function () {\n            this.throwIfDisposed();\n            return LinkedNodeList_1.LinkedNodeList.valueEnumeratorFrom(this._listInternal);\n        };\n        // #endregion\n        LinkedList.prototype._findFirst = function (entry) {\n            //noinspection UnnecessaryLocalVariableJS\n            var _ = this, equals = _._equalityComparer;\n            var next = _._listInternal && _._listInternal.first;\n            while (next) {\n                if (equals(entry, next.value))\n                    return next;\n                next = next.next;\n            }\n            return null;\n        };\n        LinkedList.prototype._findLast = function (entry) {\n            //noinspection UnnecessaryLocalVariableJS\n            var _ = this, equals = _._equalityComparer;\n            var prev = _._listInternal && _._listInternal.last;\n            while (prev) {\n                if (equals(entry, prev.value))\n                    return prev;\n                prev = prev.previous;\n            }\n            return null;\n        };\n        LinkedList.prototype.removeOnce = function (entry) {\n            return this.remove(entry, 1) !== 0;\n        };\n        Object.defineProperty(LinkedList.prototype, \"first\", {\n            get: function () {\n                var li = this._listInternal;\n                return li && ensureExternal(li.first, this);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedList.prototype, \"firstValue\", {\n            get: function () {\n                var li = this._listInternal, node = li && li.first;\n                return node ? node.value : VOID0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedList.prototype, \"last\", {\n            get: function () {\n                var li = this._listInternal;\n                return ensureExternal(li.last, this);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedList.prototype, \"lastValue\", {\n            get: function () {\n                var li = this._listInternal, node = li && li.last;\n                return node ? node.value : VOID0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // get methods are available for convenience but is an n*index operation.\n        LinkedList.prototype.getValueAt = function (index) {\n            var li = this._listInternal, node = li && li.getNodeAt(index);\n            return node ? node.value : VOID0;\n        };\n        LinkedList.prototype.getNodeAt = function (index) {\n            var li = this._listInternal;\n            return li && ensureExternal(li.getNodeAt(index), this);\n        };\n        LinkedList.prototype.find = function (entry) {\n            var li = this._listInternal;\n            return li && ensureExternal(this._findFirst(entry), this);\n        };\n        LinkedList.prototype.findLast = function (entry) {\n            var li = this._listInternal;\n            return li && ensureExternal(this._findLast(entry), this);\n        };\n        LinkedList.prototype.addFirst = function (entry) {\n            this.assertModifiable();\n            this._listInternal.addNodeBefore(new InternalNode(entry));\n            this._signalModification(true);\n            return this;\n        };\n        LinkedList.prototype.addLast = function (entry) {\n            return this.add(entry);\n        };\n        LinkedList.prototype._removeNodeInternal = function (node) {\n            var _ = this;\n            if (node && _._listInternal.removeNode(node)) {\n                detachExternal(node);\n                _._signalModification(true);\n                return true;\n            }\n            return false;\n        };\n        LinkedList.prototype.removeFirst = function () {\n            var _ = this;\n            _.assertModifiable();\n            return _._removeNodeInternal(_._listInternal.first);\n        };\n        LinkedList.prototype.removeLast = function () {\n            var _ = this;\n            _.assertModifiable();\n            return _._removeNodeInternal(_._listInternal.last);\n        };\n        LinkedList.prototype.removeAt = function (index) {\n            var _ = this;\n            _.assertModifiable();\n            return _._removeNodeInternal(_._listInternal.getNodeAt(index));\n        };\n        // Returns true if successful and false if not found (already removed).\n        LinkedList.prototype.removeNode = function (node) {\n            var _ = this;\n            _.assertModifiable();\n            return _._removeNodeInternal(getInternal(node, _));\n        };\n        LinkedList.prototype.addBefore = function (before, entry) {\n            var _ = this;\n            _.assertModifiable();\n            _._listInternal.addNodeBefore(new InternalNode(entry), getInternal(before, _));\n            _._signalModification(true);\n            return this;\n        };\n        LinkedList.prototype.addAfter = function (after, entry) {\n            var _ = this;\n            _.assertModifiable();\n            _._listInternal.addNodeAfter(new InternalNode(entry), getInternal(after, _));\n            _._signalModification(true);\n            return this;\n        };\n        return LinkedList;\n    }(CollectionBase_1.CollectionBase));\n    exports.LinkedList = LinkedList;\n    // Use an internal node class to prevent mucking up the LinkedList.\n    var LinkedListNode = /** @class */ (function () {\n        function LinkedListNode(_list, _nodeInternal) {\n            this._list = _list;\n            this._nodeInternal = _nodeInternal;\n        }\n        LinkedListNode.prototype.throwIfDetached = function () {\n            if (!this._list)\n                throw new Error(\"This node has been detached from its list and is no longer valid.\");\n        };\n        Object.defineProperty(LinkedListNode.prototype, \"list\", {\n            get: function () {\n                return this._list;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedListNode.prototype, \"previous\", {\n            get: function () {\n                this.throwIfDetached();\n                return ensureExternal(this._nodeInternal.previous, this._list);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedListNode.prototype, \"next\", {\n            get: function () {\n                this.throwIfDetached();\n                return ensureExternal(this._nodeInternal.next, this._list);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedListNode.prototype, \"value\", {\n            get: function () {\n                this.throwIfDetached();\n                return this._nodeInternal.value;\n            },\n            set: function (v) {\n                this.throwIfDetached();\n                this._nodeInternal.value = v;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LinkedListNode.prototype.addBefore = function (entry) {\n            this.throwIfDetached();\n            this._list.addBefore(this, entry);\n            return this;\n        };\n        LinkedListNode.prototype.addAfter = function (entry) {\n            this.throwIfDetached();\n            this._list.addAfter(this, entry);\n            return this;\n        };\n        LinkedListNode.prototype.remove = function () {\n            var _ = this;\n            var list = _._list;\n            if (list)\n                list.removeNode(this);\n            _._list = VOID0;\n            _._nodeInternal = VOID0;\n        };\n        LinkedListNode.prototype.dispose = function () {\n            this.remove();\n        };\n        return LinkedListNode;\n    }());\n    exports.default = LinkedList;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {areEqual} from \"../Compare\";\r\nimport {LinkedNodeList} from \"./LinkedNodeList\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {CollectionBase} from \"./CollectionBase\";\r\nimport {ILinkedListNode, ILinkedNode, INodeWithValue} from \"./ILinkedListNode\";\r\nimport {IEnumerator} from \"./Enumeration/IEnumerator\";\r\nimport {ActionWithIndex, EqualityComparison, PredicateWithIndex} from \"../FunctionTypes\";\r\nimport {ILinkedList} from \"./ILinkedList\";\r\nimport {IEnumerableOrArray} from \"./IEnumerableOrArray\";\r\nimport {IDisposable} from \"../Disposable/IDisposable\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/*\r\n * An internal node is used to manage the order without exposing underlying link chain to the consumer.\r\n */\r\nclass InternalNode<T>\r\nimplements ILinkedNode<InternalNode<T>>, INodeWithValue<T>\r\n{\r\n\tconstructor(\r\n\t\tpublic value:T,\r\n\t\tpublic previous?:InternalNode<T>|null,\r\n\t\tpublic next?:InternalNode<T>|null)\r\n\t{\r\n\t}\r\n\r\n\texternal?:ILinkedListNode<T>;\r\n\r\n\tassertDetached():true|never\r\n\t{\r\n\t\tif(this.next || this.previous)\r\n\t\t\tthrow new InvalidOperationException(\r\n\t\t\t\t\"Adding a node that is already placed.\");\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\nfunction ensureExternal<T>(\r\n\tnode:InternalNode<T>|null|undefined,\r\n\tlist:LinkedList<T>):ILinkedListNode<T>|null\r\n{\r\n\tif(!node)\r\n\t\treturn null;\r\n\tif(!list)\r\n\t\tthrow new ArgumentNullException(\"list\");\r\n\r\n\tlet external = node.external;\r\n\tif(!external)\r\n\t\tnode.external = external = new LinkedListNode<T>(list, node);\r\n\r\n\treturn external || null;\r\n}\r\n\r\nfunction getInternal<T>(node:ILinkedListNode<T>, list:LinkedList<T>):InternalNode<T>\r\n{\r\n\tif(!node)\r\n\t\tthrow new ArgumentNullException(\"node\");\r\n\tif(!list)\r\n\t\tthrow new ArgumentNullException(\"list\");\r\n\r\n\tif(node.list!=list)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node does not belong to this list.\");\r\n\r\n\tlet n:InternalNode<T> = (<any>node)._nodeInternal;\r\n\tif(!n)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node is not valid.\");\r\n\r\n\treturn n;\r\n}\r\n\r\nfunction detachExternal(node:InternalNode<any>):void\r\n{\r\n\tif(node)\r\n\t{\r\n\t\tconst e:any = node.external;\r\n\t\tif(e)\r\n\t\t{\r\n\t\t\te._list = VOID0;\r\n\t\t\te._nodeInternal = VOID0;\r\n\t\t}\r\n\t\tnode.external = VOID0;\r\n\t}\r\n}\r\n\r\nexport class LinkedList<T>\r\nextends CollectionBase<T> implements ILinkedList<T>\r\n{\r\n\tprivate readonly _listInternal:LinkedNodeList<InternalNode<T>>;\r\n\r\n\tconstructor(\r\n\t\tsource?:IEnumerableOrArray<T>,\r\n\t\tequalityComparer:EqualityComparison<T> = areEqual)\r\n\t{\r\n\t\tsuper(VOID0, equalityComparer);\r\n\t\tthis._listInternal = new LinkedNodeList<InternalNode<T>>();\r\n\t\tthis._importEntries(source);\r\n\t}\r\n\r\n\tprotected assertVersion(version:number):true|never\r\n\t{\r\n\t\tif(this._listInternal)\r\n\t\t\treturn this._listInternal.assertVersion(version);\r\n\t\telse // In case it's been disposed.\r\n\t\t\treturn super.assertVersion(version);\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tconst l = this._listInternal;\r\n\t\t(<any>this)._listInternal = null;\r\n\t\tl.dispose();\r\n\t}\r\n\r\n\tprotected getCount():number\r\n\t{\r\n\t\tconst li = this._listInternal;\r\n\t\treturn li ? li.unsafeCount : 0;\r\n\t}\r\n\r\n\tprotected _addInternal(entry:T):boolean\r\n\t{\r\n\t\tthis._listInternal.addNode(new InternalNode(entry));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprotected _removeInternal(entry:T, max:number = Infinity):number\r\n\t{\r\n\t\tconst _      = this,\r\n\t\t      equals = _._equalityComparer,\r\n\t\t      list   = _._listInternal;\r\n\t\tlet removedCount = 0;\r\n\r\n\t\tlist.forEach(node=>\r\n\t\t{\r\n\t\t\tif(node && equals(entry, node.value) && _._removeNodeInternal(node))\r\n\t\t\t\tremovedCount++;\r\n\r\n\t\t\treturn removedCount<max;\r\n\t\t}, true /* override versioning check */);\r\n\r\n\t\treturn removedCount;\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tconst list = this._listInternal;\r\n\t\tlist.forEach(node=>detachExternal(node));\r\n\t\treturn list.clear();\r\n\t}\r\n\r\n\tforEach(action:ActionWithIndex<T>, useCopy?:boolean):number;\r\n\tforEach(action:PredicateWithIndex<T>, useCopy?:boolean):number;\r\n\tforEach(action:ActionWithIndex<T> | PredicateWithIndex<T>,\r\n\t\tuseCopy:boolean = false):number\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn useCopy\r\n\t\t\t? super.forEach(action, useCopy)\r\n\t\t\t: this._listInternal.forEach((node, i)=>action(<any>node.value, i));\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region IEnumerable<T>\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn LinkedNodeList.valueEnumeratorFrom<T>(<any>this._listInternal);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tprivate _findFirst(entry:T):InternalNode<T>|null\r\n\t{\r\n\t\t//noinspection UnnecessaryLocalVariableJS\r\n\t\tconst\r\n\t\t\t_      = this,\r\n\t\t\tequals = _._equalityComparer;\r\n\r\n\t\tlet next:any = _._listInternal && _._listInternal.first;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\tif(equals(entry, next.value))\r\n\t\t\t\treturn next;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate _findLast(entry:T):InternalNode<T>|null\r\n\t{\r\n\t\t//noinspection UnnecessaryLocalVariableJS\r\n\t\tconst\r\n\t\t\t_      = this,\r\n\t\t\tequals = _._equalityComparer;\r\n\r\n\t\tlet prev:any = _._listInternal && _._listInternal.last;\r\n\t\twhile(prev)\r\n\t\t{\r\n\t\t\tif(equals(entry, prev.value))\r\n\t\t\t\treturn prev;\r\n\t\t\tprev = prev.previous;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tremoveOnce(entry:T):boolean\r\n\t{\r\n\t\treturn this.remove(entry, 1)!==0;\r\n\t}\r\n\r\n\tget first():ILinkedListNode<T>|null\r\n\t{\r\n\t\tconst li = this._listInternal;\r\n\t\treturn li && ensureExternal(li.first, this);\r\n\t}\r\n\r\n\tget firstValue():T | undefined\r\n\t{\r\n\t\tconst li = this._listInternal, node = li && li.first;\r\n\t\treturn node ? node.value : VOID0;\r\n\t}\r\n\r\n\tget last():ILinkedListNode<T>|null\r\n\t{\r\n\t\tconst li = this._listInternal;\r\n\t\treturn ensureExternal(li.last, this);\r\n\t}\r\n\r\n\tget lastValue():T | undefined\r\n\t{\r\n\t\tconst li = this._listInternal, node = li && li.last;\r\n\t\treturn node ? node.value : VOID0;\r\n\t}\r\n\r\n\t// get methods are available for convenience but is an n*index operation.\r\n\r\n\r\n\tgetValueAt(index:number):T | undefined\r\n\t{\r\n\t\tconst li = this._listInternal, node = li && li.getNodeAt(index);\r\n\t\treturn node ? node.value : VOID0;\r\n\t}\r\n\r\n\tgetNodeAt(index:number):ILinkedListNode<T> | null\r\n\t{\r\n\t\tconst li = this._listInternal;\r\n\t\treturn li && ensureExternal(li.getNodeAt(index), this);\r\n\t}\r\n\r\n\tfind(entry:T):ILinkedListNode<T> | null\r\n\t{\r\n\t\tconst li = this._listInternal;\r\n\t\treturn li && ensureExternal(this._findFirst(entry), this);\r\n\t}\r\n\r\n\tfindLast(entry:T):ILinkedListNode<T> | null\r\n\t{\r\n\t\tconst li = this._listInternal;\r\n\t\treturn li && ensureExternal(this._findLast(entry), this);\r\n\t}\r\n\r\n\taddFirst(entry:T):this\r\n\t{\r\n\t\tthis.assertModifiable();\r\n\t\tthis._listInternal.addNodeBefore(new InternalNode(entry));\r\n\t\tthis._signalModification(true);\r\n\t\treturn this;\r\n\t}\r\n\r\n\taddLast(entry:T):this\r\n\t{\r\n\t\treturn this.add(entry);\r\n\t}\r\n\r\n\tprivate _removeNodeInternal(node:InternalNode<T>|null|undefined):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tif(node && _._listInternal.removeNode(node))\r\n\t\t{\r\n\t\t\tdetachExternal(node);\r\n\t\t\t_._signalModification(true);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveFirst():boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.assertModifiable();\r\n\t\treturn _._removeNodeInternal(_._listInternal.first);\r\n\t}\r\n\r\n\tremoveLast():boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.assertModifiable();\r\n\t\treturn _._removeNodeInternal(_._listInternal.last);\r\n\t}\r\n\r\n\tremoveAt(index:number):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.assertModifiable();\r\n\t\treturn _._removeNodeInternal(_._listInternal.getNodeAt(index));\r\n\t}\r\n\r\n\t// Returns true if successful and false if not found (already removed).\r\n\tremoveNode(node:ILinkedListNode<T>):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.assertModifiable();\r\n\t\treturn _._removeNodeInternal(getInternal(node, _));\r\n\t}\r\n\r\n\taddBefore(before:ILinkedListNode<T>, entry:T):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.assertModifiable();\r\n\t\t_._listInternal.addNodeBefore(\r\n\t\t\tnew InternalNode(entry),\r\n\t\t\tgetInternal(before, _)\r\n\t\t);\r\n\r\n\t\t_._signalModification(true);\r\n\t\treturn this;\r\n\t}\r\n\r\n\taddAfter(after:ILinkedListNode<T>, entry:T):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.assertModifiable();\r\n\t\t_._listInternal.addNodeAfter(\r\n\t\t\tnew InternalNode(entry),\r\n\t\t\tgetInternal(after, _)\r\n\t\t);\r\n\r\n\t\t_._signalModification(true);\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\n// Use an internal node class to prevent mucking up the LinkedList.\r\nclass LinkedListNode<T> implements ILinkedListNode<T>, IDisposable\r\n{\r\n\tconstructor(\r\n\t\tprivate _list:LinkedList<T>,\r\n\t\tprivate _nodeInternal:InternalNode<T>)\r\n\t{\r\n\t}\r\n\r\n\tprivate throwIfDetached():void\r\n\t{\r\n\t\tif(!this._list)\r\n\t\t\tthrow new Error(\"This node has been detached from its list and is no longer valid.\");\r\n\t}\r\n\r\n\tget list():LinkedList<T>\r\n\t{\r\n\t\treturn this._list;\r\n\t}\r\n\r\n\tget previous():ILinkedListNode<T>|null\r\n\t{\r\n\t\tthis.throwIfDetached();\r\n\t\treturn ensureExternal(this._nodeInternal.previous, this._list);\r\n\t}\r\n\r\n\tget next():ILinkedListNode<T>|null\r\n\t{\r\n\t\tthis.throwIfDetached();\r\n\t\treturn ensureExternal(this._nodeInternal.next, this._list);\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\tthis.throwIfDetached();\r\n\t\treturn this._nodeInternal.value;\r\n\t}\r\n\r\n\tset value(v:T)\r\n\t{\r\n\t\tthis.throwIfDetached();\r\n\t\tthis._nodeInternal.value = v;\r\n\t}\r\n\r\n\taddBefore(entry:T):this\r\n\t{\r\n\t\tthis.throwIfDetached();\r\n\t\tthis._list.addBefore(this, entry);\r\n\t\treturn this;\r\n\t}\r\n\r\n\taddAfter(entry:T):this\r\n\t{\r\n\t\tthis.throwIfDetached();\r\n\t\tthis._list.addAfter(this, entry);\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tremove():void\r\n\t{\r\n\t\tconst _:any = this;\r\n\t\tconst list = _._list;\r\n\t\tif(list) list.removeNode(this);\r\n\t\t_._list = VOID0;\r\n\t\t_._nodeInternal = VOID0;\r\n\t}\r\n\r\n\tdispose():void\r\n\t{\r\n\t\tthis.remove();\r\n\t}\r\n\r\n}\r\n\r\nexport default LinkedList;\r\n"]}
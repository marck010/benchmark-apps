{"version":3,"sources":["System/Collections/Array/Compare.js","System/Collections/Array/Compare.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","validateSize","a","b","len","length","areAllEqual","arrays","strict","equalityComparer","Values","areEqual","Error","Types_1","Type","isFunction","first","i","l","isBoolean","internalSort","comparer","Array","sort","areEquivalent","compare","Object","defineProperty","value"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,gBAAiB,eAAgBN,IAEpE,SAAUI,EAASF,GAClB,YCCJ,SAAAM,GAAsBC,EAAkBC,GAGvC,GAAGD,GAAKC,GAAKD,IAAIC,IAAMD,IAAMC,EAC5B,OAAO,CAGR,KAAID,IAAMC,EACT,OAAO,CAER,IAAMC,GAAMF,EAAEG,MACd,OAAGD,KAAMD,EAAEE,SAIF,IAAND,GAIIA,GAUR,QAAAE,GACCC,EACAC,EACAC,GAEA,GAHA,SAAAD,IAAAA,GAAA,GACA,SAAAC,IAAAA,EAA2CC,EAAOC,WAE9CJ,EACH,KAAM,IAAIK,OAAM,kDACjB,IAAGL,EAAOF,OAAO,EAChB,KAAM,IAAIO,OAAM,8CAEdC,GAAAC,KAAKC,WAAWP,KAClBC,EAAmBD,EACnBA,GAAS,EAIV,KAAI,GADEQ,GAAQT,EAAO,GACbU,EAAI,EAAGC,EAAIX,EAAOF,OAAQY,EAAEC,EAAGD,IAEtC,IAAIN,EAASK,EAAOT,EAAOU,GAAIT,EAAQC,GACtC,OAAO,CAET,QAAO,EAgBR,QAAAE,GACCT,EAAgBC,EAChBK,EACAC,GADA,SAAAD,IAAAA,GAAA,GACA,SAAAC,IAAAA,EAAyCC,EAAOC,SAEhD,IAAMP,GAAMH,EAAaC,EAAGC,EAC5B,IAAGU,EAAAC,KAAKK,UAAUf,GAAM,MAAgBA,EAErCS,GAAAC,KAAKC,WAAWP,KAClBC,EAAmBD,EACnBA,GAAS,EAGV,KAAI,GAAIS,GAAI,EAAGA,EAAEb,EAAKa,IAErB,IAAIR,EAAiBP,EAAEe,GAAId,EAAEc,GAAIT,GAChC,OAAO,CAGT,QAAO,EAIR,QAAAY,GAAyBlB,EAAgBmB,GAExC,IAAInB,GAAKA,EAAEG,OAAO,EAAG,MAAOH,EAE5B,IACIC,GADEC,EAAMF,EAAEG,MAEXD,GAAI,MACND,EAAI,GAAImB,OAAMlB,IAGdD,KACAA,EAAEE,OAASD,EAEZ,KAAI,GAAIa,GAAI,EAAGA,EAAEb,EAAKa,IAErBd,EAAEc,GAAKf,EAAEe,EAIV,OADAd,GAAEoB,KAAKF,GACAlB,EAMR,QAAAqB,GACCtB,EAAgBC,EAChBkB,GAAA,SAAAA,IAAAA,EAAyBX,EAAOe,QAEhC,IAAMrB,GAAMH,EAAaC,EAAGC,EAC5B,IAAGU,EAAAC,KAAKK,UAAUf,GAAM,MAAgBA,EAIxCF,GAAIkB,EAAalB,EAAGmB,GACpBlB,EAAIiB,EAAajB,EAAGkB,EAEpB,KAAI,GAAIJ,GAAI,EAAGA,EAAEb,EAAKa,IAErB,GAA0B,IAAvBI,EAASnB,EAAEe,GAAId,EAAEc,IACnB,OAAO,CAGT,QAAO,EDpIJS,OAAOC,eAAehC,EAAS,cAAgBiC,OAAO,GCT1D,IAAAlB,GAAAb,EAAA,iBACAgB,EAAAhB,EAAA,cAqCAF,GAAAW,YAAAA,EAqCAX,EAAAgB,SAAAA,EAgDAhB,EAAA6B,cAAAA","file":"Compare.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../../Compare\", \"../../Types\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Values = require(\"../../Compare\");\n    var Types_1 = require(\"../../Types\");\n    /*  validateSize: Utility for quick validation/invalidation of array equality.\n        Why this way?  Why not pass a closure for the last return?\n        Reason: Performance and avoiding the creation of new functions/closures. */\n    function validateSize(a, b) {\n        // Both valid and are same object, or both are null/undefined.\n        if (a && b && a === b || !a && !b)\n            return true;\n        // At this point, at least one has to be non-null.\n        if (!a || !b)\n            return false;\n        var len = a.length;\n        if (len !== b.length)\n            return false;\n        // If both are arrays and have zero length, they are equal.\n        if (len === 0)\n            return true;\n        // Return the length for downstream processing.\n        return len;\n    }\n    function areAllEqual(arrays, strict, equalityComparer) {\n        if (strict === void 0) { strict = true; }\n        if (equalityComparer === void 0) { equalityComparer = Values.areEqual; }\n        if (!arrays)\n            throw new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\n        if (arrays.length < 2)\n            throw new Error(\"Cannot compare a set of arrays less than 2.\");\n        if (Types_1.Type.isFunction(strict)) {\n            equalityComparer = strict;\n            strict = true;\n        }\n        var first = arrays[0];\n        for (var i = 1, l = arrays.length; i < l; i++) {\n            if (!areEqual(first, arrays[i], strict, equalityComparer))\n                return false;\n        }\n        return true;\n    }\n    exports.areAllEqual = areAllEqual;\n    function areEqual(a, b, strict, equalityComparer) {\n        if (strict === void 0) { strict = true; }\n        if (equalityComparer === void 0) { equalityComparer = Values.areEqual; }\n        var len = validateSize(a, b);\n        if (Types_1.Type.isBoolean(len))\n            return len;\n        if (Types_1.Type.isFunction(strict)) {\n            equalityComparer = strict;\n            strict = true;\n        }\n        for (var i = 0; i < len; i++) {\n            if (!equalityComparer(a[i], b[i], strict))\n                return false;\n        }\n        return true;\n    }\n    exports.areEqual = areEqual;\n    function internalSort(a, comparer) {\n        if (!a || a.length < 2)\n            return a;\n        var len = a.length;\n        var b;\n        if (len > 65536)\n            b = new Array(len);\n        else {\n            b = [];\n            b.length = len;\n        }\n        for (var i = 0; i < len; i++) {\n            b[i] = a[i];\n        }\n        b.sort(comparer);\n        return b;\n    }\n    function areEquivalent(a, b, comparer) {\n        if (comparer === void 0) { comparer = Values.compare; }\n        var len = validateSize(a, b);\n        if (Types_1.Type.isBoolean(len))\n            return len;\n        // There might be a better more performant way to do this, but for the moment, this\n        // works quite well.\n        a = internalSort(a, comparer);\n        b = internalSort(b, comparer);\n        for (var i = 0; i < len; i++) {\n            if (comparer(a[i], b[i]) !== 0)\n                return false;\n        }\n        return true;\n    }\n    exports.areEquivalent = areEquivalent;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport * as Values from \"../../Compare\";\r\nimport {Type} from \"../../Types\";\r\nimport {Primitive} from \"../../Primitive\";\r\nimport {Comparison, EqualityComparison} from \"../../FunctionTypes\";\r\nimport {IComparable} from \"../../IComparable\";\r\n\r\n/*  validateSize: Utility for quick validation/invalidation of array equality.\r\n\tWhy this way?  Why not pass a closure for the last return?\r\n\tReason: Performance and avoiding the creation of new functions/closures. */\r\nfunction validateSize(a:ArrayLike<any>, b:ArrayLike<any>):boolean|number\r\n{\r\n\t// Both valid and are same object, or both are null/undefined.\r\n\tif(a && b && a===b || !a && !b)\r\n\t\treturn true;\r\n\r\n\t// At this point, at least one has to be non-null.\r\n\tif(!a || !b)\r\n\t\treturn false;\r\n\r\n\tconst len = a.length;\r\n\tif(len!==b.length)\r\n\t\treturn false;\r\n\r\n\t// If both are arrays and have zero length, they are equal.\r\n\tif(len===0)\r\n\t\treturn true;\r\n\r\n\t// Return the length for downstream processing.\r\n\treturn len;\r\n}\r\n\r\nexport function areAllEqual(\r\n\tarrays:ArrayLike<ArrayLike<any>>,\r\n\tequalityComparer?:EqualityComparison<any>):boolean\r\nexport function areAllEqual(\r\n\tarrays:ArrayLike<ArrayLike<any>>,\r\n\tstrict:boolean,\r\n\tequalityComparer?:EqualityComparison<any>):boolean\r\nexport function areAllEqual(\r\n\tarrays:ArrayLike<ArrayLike<any>>,\r\n\tstrict:boolean|EqualityComparison<any> = true,\r\n\tequalityComparer:EqualityComparison<any> = Values.areEqual):boolean\r\n{\r\n\tif(!arrays)\r\n\t\tthrow new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\r\n\tif(arrays.length<2)\r\n\t\tthrow new Error(\"Cannot compare a set of arrays less than 2.\");\r\n\r\n\tif(Type.isFunction(strict)) {\r\n\t\tequalityComparer = strict;\r\n\t\tstrict = true;\r\n\t}\r\n\r\n\tconst first = arrays[0];\r\n\tfor(let i = 1, l = arrays.length; i<l; i++)\r\n\t{\r\n\t\tif(!areEqual(first, arrays[i], strict, equalityComparer))\r\n\t\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * Compares two arrays for equality.\r\n * @param a\r\n * @param b\r\n * @param equalityComparer\r\n */\r\nexport function areEqual<T>(\r\n\ta:ArrayLike<T>, b:ArrayLike<T>,\r\n\tequalityComparer?:EqualityComparison<T>):boolean\r\nexport function areEqual<T>(\r\n\ta:ArrayLike<T>, b:ArrayLike<T>,\r\n\tstrict:boolean,\r\n\tequalityComparer?:EqualityComparison<T>):boolean\r\nexport function areEqual<T>(\r\n\ta:ArrayLike<T>, b:ArrayLike<T>,\r\n\tstrict:boolean|EqualityComparison<T> = true,\r\n\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n{\r\n\tconst len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\tif(Type.isFunction(strict)) {\r\n\t\tequalityComparer = strict;\r\n\t\tstrict = true;\r\n\t}\r\n\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tif(!equalityComparer(a[i], b[i], strict))\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction internalSort<T>(a:ArrayLike<T>, comparer:Comparison<T>):ArrayLike<T>\r\n{\r\n\tif(!a || a.length<2) return a;\r\n\r\n\tconst len = a.length;\r\n\tlet b:T[];\r\n\tif(len>65536)\r\n\t\tb = new Array(len);\r\n\telse\r\n\t{\r\n\t\tb = [];\r\n\t\tb.length = len;\r\n\t}\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tb[i] = a[i];\r\n\t}\r\n\r\n\tb.sort(comparer);\r\n\treturn b;\r\n}\r\n\r\nexport function areEquivalent<T extends Primitive>(a:ArrayLike<T>, b:ArrayLike<T>):boolean;\r\nexport function areEquivalent<T>(a:ArrayLike<IComparable<T>>, b:ArrayLike<IComparable<T>>):boolean;\r\nexport function areEquivalent<T>(a:ArrayLike<T>, b:ArrayLike<T>, comparer:Comparison<T>):boolean;\r\nexport function areEquivalent<T>(\r\n\ta:ArrayLike<T>, b:ArrayLike<T>,\r\n\tcomparer:Comparison<T> = Values.compare):boolean\r\n{\r\n\tconst len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\t// There might be a better more performant way to do this, but for the moment, this\r\n\t// works quite well.\r\n\ta = internalSort(a, comparer);\r\n\tb = internalSort(b, comparer);\r\n\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tif(comparer(a[i], b[i])!==0)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n"]}
{"version":3,"sources":["System/Collections/Array/Sorting/createComparer.js","System/Collections/Array/Sorting/createComparer.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","ensureArray","value","createComparer","selector","order","equivalentToNaN","NaN","nanHasEquivalent","Types_1","Type","isTrueNaN","a","b","aValue","bValue","len","Math","min","length","oArray","i","vA","vB","o","r","Compare_1","compare","Object","defineProperty"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,iBAAkB,oBAAqBN,IAE1E,SAAUI,EAASF,GAClB,YCDJ,SAAAM,GAAwBC,GAEvB,MAAO,aAAiB,OAChBA,GACDA,GA0BR,QAAAC,GACCC,EACAC,EACAC,GADA,SAAAD,IAAAA,EAAA,GACA,SAAAC,IAAAA,EAAAC,IAEA,IAAMC,IAAoBC,EAAAC,KAAKC,UAAUL,EAEzC,OAAO,UAACM,EAAWC,GAQlB,IAAI,GALEC,GAASb,EAAYG,EAASQ,IAC9BG,EAASd,EAAYG,EAASS,IAC9BG,EAAMC,KAAKC,IAAIJ,EAAOK,OAAQJ,EAAOI,QAErCC,EAAS,YAAiB,OAAUf,EAAQ,KAC1CgB,EAAI,EAAGA,EAAEL,EAAKK,IACtB,CACC,GAAIC,GAAKR,EAAOO,GACZE,EAAKR,EAAOM,GACVG,EAAIJ,EACNC,EAAED,EAAOD,OAASC,EAAOC,GAAI,EACvBhB,CAEPG,KAECC,EAAAC,KAAKC,UAAUW,KACjBA,EAAKhB,GACHG,EAAAC,KAAKC,UAAUY,KACjBA,EAAKjB,GAIP,IAAMmB,GAAIC,EAAAC,QAAQL,EAAIC,EACtB,IAAI,IAADE,EACF,MAAOD,GAAEC,EAIX,MAAO,IDlELG,OAAOC,eAAelC,EAAS,cAAgBO,OAAO,GCT1D,IAAAO,GAAAZ,EAAA,kBACA6B,EAAA7B,EAAA,mBAoCAF,GAAAQ,eAAAA","file":"createComparer.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../../../Types\", \"../../../Compare\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Types_1 = require(\"../../../Types\");\n    var Compare_1 = require(\"../../../Compare\");\n    function ensureArray(value) {\n        return (value) instanceof (Array)\n            ? value\n            : [value];\n    }\n    /**\n     * A factory function that creates a comparer to be used in multi-dimensional sorting.\n     *\n     * <h4>Example</h4>\n     * ```typescript\n     * var myArray = [{a:1:b:2},{a:3,b:4},{a:1,b:3}];\n     *\n     * // First sort by a, then by b.\n     * myArray.sort(\n     *   createComparer(\n     *     (e)=> [e.a, e.b],\n     *     [Order.Ascending, Order.Descending]\n     *   )\n     * );\n     *\n     * // result: [{a:1,b:3},{a:1:b:2},{a:3,b:4}]\n     * ```\n     *\n     * @param selector\n     * @param order\n     * @param equivalentToNaN\n     * @returns {(a:TSource, b:TSource)=>CompareResult}\n     */\n    function createComparer(selector, order, equivalentToNaN) {\n        if (order === void 0) { order = 1 /* Ascending */; }\n        if (equivalentToNaN === void 0) { equivalentToNaN = NaN; }\n        var nanHasEquivalent = !Types_1.Type.isTrueNaN(equivalentToNaN);\n        return function (a, b) {\n            // Use an array always to ensure a single code path.\n            var aValue = ensureArray(selector(a));\n            var bValue = ensureArray(selector(b));\n            var len = Math.min(aValue.length, bValue.length);\n            var oArray = (order) instanceof (Array) ? order : null;\n            for (var i = 0; i < len; i++) {\n                var vA = aValue[i], vB = bValue[i];\n                var o = oArray\n                    ? (i < oArray.length ? oArray[i] : 1 /* Ascending */)\n                    : order;\n                if (nanHasEquivalent) {\n                    if (Types_1.Type.isTrueNaN(vA))\n                        vA = equivalentToNaN;\n                    if (Types_1.Type.isTrueNaN(vB))\n                        vB = equivalentToNaN;\n                }\n                var r = Compare_1.compare(vA, vB);\n                if (r !== 0 /* Equal */)\n                    return o * r;\n            }\n            return 0;\n        };\n    }\n    exports.createComparer = createComparer;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../../../Types\";\r\nimport {compare} from \"../../../Compare\";\r\nimport {Primitive} from \"../../../Primitive\";\r\nimport {Comparison, Selector} from \"../../../FunctionTypes\";\r\nimport {CompareResult} from \"../../../CompareResult\";\r\nimport {Order} from \"../../Sorting/Order\";\r\n\r\nfunction ensureArray<T>(value:T|T[]):T[]\r\n{\r\n\treturn (value)instanceof(Array)\r\n\t\t? <T[]>value\r\n\t\t: [<T>value];\r\n}\r\n\r\n/**\r\n * A factory function that creates a comparer to be used in multi-dimensional sorting.\r\n *\r\n * <h4>Example</h4>\r\n * ```typescript\r\n * var myArray = [{a:1:b:2},{a:3,b:4},{a:1,b:3}];\r\n *\r\n * // First sort by a, then by b.\r\n * myArray.sort(\r\n *   createComparer(\r\n *     (e)=> [e.a, e.b],\r\n *     [Order.Ascending, Order.Descending]\r\n *   )\r\n * );\r\n *\r\n * // result: [{a:1,b:3},{a:1:b:2},{a:3,b:4}]\r\n * ```\r\n *\r\n * @param selector\r\n * @param order\r\n * @param equivalentToNaN\r\n * @returns {(a:TSource, b:TSource)=>CompareResult}\r\n */\r\nexport function createComparer<TSource,TSelect extends Primitive>(\r\n\tselector:Selector<TSource,TSelect|TSelect[]>,\r\n\torder:Order | Order[] = Order.Ascending,\r\n\tequivalentToNaN:any = NaN):Comparison<TSource>\r\n{\r\n\tconst nanHasEquivalent = !Type.isTrueNaN(equivalentToNaN);\r\n\r\n\treturn (a:TSource, b:TSource):CompareResult=>\r\n\t{\r\n\t\t// Use an array always to ensure a single code path.\r\n\t\tconst aValue = ensureArray(selector(a));\r\n\t\tconst bValue = ensureArray(selector(b));\r\n\t\tconst len = Math.min(aValue.length, bValue.length);\r\n\r\n\t\tconst oArray = (order)instanceof(Array) ? order : null;\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tlet vA = aValue[i],\r\n\t\t\t    vB = bValue[i];\r\n\t\t\tconst o = oArray\r\n\t\t\t\t? (i<oArray.length ? oArray[i] : Order.Ascending)\r\n\t\t\t\t: <Order>order;\r\n\r\n\t\t\tif(nanHasEquivalent)\r\n\t\t\t{\r\n\t\t\t\tif(Type.isTrueNaN(vA))\r\n\t\t\t\t\tvA = equivalentToNaN;\r\n\t\t\t\tif(Type.isTrueNaN(vB))\r\n\t\t\t\t\tvB = equivalentToNaN;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst r = compare(vA, vB);\r\n\t\t\tif(r!==CompareResult.Equal)\r\n\t\t\t\treturn o*r;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t};\r\n}\r\n\r\n"]}
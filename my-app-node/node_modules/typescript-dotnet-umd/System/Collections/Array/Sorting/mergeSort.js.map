{"version":3,"sources":["System/Collections/Array/Sorting/mergeSort.js","System/Collections/Array/Sorting/mergeSort.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","mergeSort","target","ArgumentNullException_1","ArgumentNullException","len","length","sort","Utility_1","initialize","start","end","temp","middle","Math","floor","i_1","k","i","j","Object","defineProperty","value"],"mappings":";;;;;;CAMA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,4CAA6C,cAAeN,IAE/F,SAAUI,EAASF,GAClB,YCGJ,SAAAM,GAAoFC,GAEnF,IAAIA,EAAQ,KAAM,IAAIC,GAAAC,sBAAsB,SAC5C,IAAMC,GAAMH,EAAOI,MACnB,OAAOD,GAAI,EAAIH,EAASK,EAAKL,EAAQ,EAAGG,EAAKG,EAAAC,WAAcJ,IAG5D,QAAAE,GACCL,EACAQ,EACAC,EACAC,GAEA,GAAGD,EAAMD,EAAM,EACf,CAEC,GAAMG,GAASC,KAAKC,OAAOL,EAAQC,GAAK,EACxCJ,GAAKL,EAAQQ,EAAOG,EAAQD,GAC5BL,EAAKL,EAAQW,EAAQF,EAAKC,EAG1B,KAAI,GAAII,GAAI,EAAGX,EAAMH,EAAOI,OAAQU,EAAEX,EAAKW,IAE1CJ,EAAKI,GAAKd,EAAOc,EAOlB,KAHA,GAAIC,GAAIP,EAAOQ,EAAIR,EAAOS,EAAIN,EAGxBK,EAAEL,GAAUM,EAAER,GAEnBT,EAAOe,KACJL,EAAKM,GAAGN,EAAKO,GACbP,EAAKO,KACLP,EAAKM,IAIT,MAAMA,EAAEL,GAEPX,EAAOe,KAAOL,EAAKM,KAKrB,MAAOhB,GDhDJkB,OAAOC,eAAe1B,EAAS,cAAgB2B,OAAO,GCR1D,IAAAnB,GAAAN,EAAA,6CACAW,EAAAX,EAAA,aASAF,GAAAM,UAAAA","file":"mergeSort.js","sourcesContent":["/*!\n * @author Sebastian Belmar / https://github.com/sebabelmar/\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * https://en.wikipedia.org/wiki/Merge_sort\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../../../Exceptions/ArgumentNullException\", \"../Utility\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ArgumentNullException_1 = require(\"../../../Exceptions/ArgumentNullException\");\n    var Utility_1 = require(\"../Utility\");\n    /**\n     * Merge internalSort O(n log (n))\n     * Warning: Uses recursion.\n     * @param target\n     * @returns {number[]}\n     */\n    function mergeSort(target) {\n        if (!target)\n            throw new ArgumentNullException_1.ArgumentNullException(\"target\");\n        var len = target.length;\n        return len < 2 ? target : sort(target, 0, len, Utility_1.initialize(len));\n    }\n    exports.mergeSort = mergeSort;\n    function sort(target, start, end, temp) {\n        if (end - start > 1) {\n            // Step 1: Sort the left and right parts.\n            var middle = Math.floor((start + end) / 2);\n            sort(target, start, middle, temp);\n            sort(target, middle, end, temp);\n            // Step 2: Copy the original array\n            for (var i_1 = 0, len = target.length; i_1 < len; i_1++) {\n                temp[i_1] = target[i_1];\n            }\n            // Step 3: Create variables to traverse\n            var k = start, i = start, j = middle;\n            // Step 4: Merge: Move from the temp to target integers in order\n            while (i < middle && j < end) {\n                target[k++]\n                    = temp[i] > temp[j]\n                        ? temp[j++]\n                        : temp[i++];\n            }\n            // Step 5: Finalize merging in case right side of the array is bigger.\n            while (i < middle) {\n                target[k++] = temp[i++];\n            }\n        }\n        return target;\n    }\n});\n","/*!\r\n * @author Sebastian Belmar / https://github.com/sebabelmar/\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * https://en.wikipedia.org/wiki/Merge_sort\r\n */\r\n\r\nimport {Primitive} from \"../../../Primitive\";\r\nimport {ArgumentNullException} from \"../../../Exceptions/ArgumentNullException\";\r\nimport {initialize} from \"../Utility\";\r\nimport {ArrayLikeWritable} from \"../ArrayLikeWritable\";\r\n\r\n/**\r\n * Merge internalSort O(n log (n))\r\n * Warning: Uses recursion.\r\n * @param target\r\n * @returns {number[]}\r\n */\r\nexport function mergeSort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(target:TArray):TArray\r\n{\r\n\tif(!target) throw new ArgumentNullException(\"target\");\r\n\tconst len = target.length;\r\n\treturn len<2 ? target : sort(target, 0, len, initialize<T>(len));\r\n}\r\n\r\nfunction sort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(\r\n\ttarget:TArray,\r\n\tstart:number,\r\n\tend:number,\r\n\ttemp:ArrayLikeWritable<T>):TArray\r\n{\r\n\tif(end - start>1)\r\n\t{\r\n\t\t// Step 1: Sort the left and right parts.\r\n\t\tconst middle = Math.floor((start + end)/2);\r\n\t\tsort(target, start, middle, temp);\r\n\t\tsort(target, middle, end, temp);\r\n\r\n\t\t// Step 2: Copy the original array\r\n\t\tfor(let i = 0, len = target.length; i<len; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = target[i];\r\n\t\t}\r\n\r\n\t\t// Step 3: Create variables to traverse\r\n\t\tlet k = start, i = start, j = middle;\r\n\r\n\t\t// Step 4: Merge: Move from the temp to target integers in order\r\n\t\twhile(i<middle && j<end)\r\n\t\t{\r\n\t\t\ttarget[k++]\r\n\t\t\t\t= temp[i]>temp[j]\r\n\t\t\t\t? temp[j++]\r\n\t\t\t\t: temp[i++];\r\n\t\t}\r\n\r\n\t\t// Step 5: Finalize merging in case right side of the array is bigger.\r\n\t\twhile(i<middle)\r\n\t\t{\r\n\t\t\ttarget[k++] = temp[i++];\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn target\r\n}\r\n"]}
{"version":3,"sources":["System/Collections/Array/Procedure.js","System/Collections/Array/Procedure.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","sum","source","ignoreNaN","length","result","_i","_a","n","isNaN","_b","_c","NaN","average","count","product","found","quotient","len","i","ifSet","start","predicate","min","Infinity","max","Object","defineProperty","value"],"mappings":"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","file":"Procedure.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function sum(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        if (!source || !source.length)\n            return 0;\n        var result = 0;\n        if (ignoreNaN) {\n            for (var _i = 0, _a = source; _i < _a.length; _i++) {\n                var n = _a[_i];\n                if (!isNaN(n))\n                    result += n;\n            }\n        }\n        else {\n            for (var _b = 0, _c = source; _b < _c.length; _b++) {\n                var n = _c[_b];\n                if (isNaN(n))\n                    return NaN;\n                result += n;\n            }\n        }\n        return result;\n    }\n    exports.sum = sum;\n    function average(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        if (!source || !source.length)\n            return NaN;\n        var result = 0, count;\n        if (ignoreNaN) {\n            count = 0;\n            for (var _i = 0, _a = source; _i < _a.length; _i++) {\n                var n = _a[_i];\n                if (!isNaN(n)) {\n                    result += n;\n                    count++;\n                }\n            }\n        }\n        else {\n            count = source.length;\n            for (var _b = 0, _c = source; _b < _c.length; _b++) {\n                var n = _c[_b];\n                if (isNaN(n))\n                    return NaN;\n                result += n;\n            }\n        }\n        return (!count || isNaN(result)) ? NaN : (result / count);\n    }\n    exports.average = average;\n    function product(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        if (!source || !source.length)\n            return NaN;\n        var result = 1;\n        if (ignoreNaN) {\n            var found = false;\n            for (var _i = 0, _a = source; _i < _a.length; _i++) {\n                var n = _a[_i];\n                if (!isNaN(n)) {\n                    result *= n;\n                    found = true;\n                }\n            }\n            if (!found)\n                return NaN;\n        }\n        else {\n            for (var _b = 0, _c = source; _b < _c.length; _b++) {\n                var n = _c[_b];\n                if (isNaN(n))\n                    return NaN;\n                result *= n;\n            }\n        }\n        return result;\n    }\n    exports.product = product;\n    /**\n     * Takes the first number and divides it by all following.\n     * @param source\n     * @param ignoreNaN Will cause this skip any NaN values.\n     * @returns {number}\n     */\n    function quotient(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        var len = source ? source.length : 0;\n        if (len < 2)\n            return NaN;\n        var result = source[0];\n        var found = false;\n        for (var i = 1; i < len; i++) {\n            var n = source[i];\n            if (n === 0) {\n                return NaN;\n            }\n            if (isNaN(n)) {\n                if (!ignoreNaN) {\n                    return NaN;\n                }\n            }\n            else {\n                result /= n;\n                if (!found)\n                    found = true;\n            }\n        }\n        return found ? result : NaN;\n    }\n    exports.quotient = quotient;\n    function ifSet(source, start, ignoreNaN, predicate) {\n        if (!source || !source.length)\n            return NaN;\n        var result = start;\n        if (ignoreNaN) {\n            var found = false;\n            for (var _i = 0, _a = source; _i < _a.length; _i++) {\n                var n = _a[_i];\n                if (!isNaN(n)) {\n                    if (predicate(n, result))\n                        result = n;\n                    if (!found)\n                        found = true;\n                }\n            }\n            if (!found)\n                return NaN;\n        }\n        else {\n            for (var _b = 0, _c = source; _b < _c.length; _b++) {\n                var n = _c[_b];\n                if (isNaN(n))\n                    return NaN;\n                if (predicate(n, result))\n                    result = n;\n            }\n        }\n        return result;\n    }\n    function min(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        return ifSet(source, +Infinity, ignoreNaN, function (n, result) { return n < result; });\n    }\n    exports.min = min;\n    function max(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        return ifSet(source, -Infinity, ignoreNaN, function (n, result) { return n > result; });\n    }\n    exports.max = max;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nexport function sum(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn 0;\r\n\r\n\tlet result = 0;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(!isNaN(n)) result += n;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(isNaN(n)) return NaN;\r\n\t\t\tresult += n;\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nexport function average(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tlet result = 0, count:number;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tcount = 0;\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(!isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tresult += n;\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcount = source.length;\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(isNaN(n)) return NaN;\r\n\t\t\tresult += n;\r\n\t\t}\r\n\t}\r\n\r\n\treturn (!count || isNaN(result)) ? NaN : (result/count);\r\n}\r\n\r\nexport function product(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tlet result = 1;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tlet found = false;\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(!isNaN(n)){\r\n\t\t\t\tresult *= n;\r\n\t\t\t\tfound = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!found)\r\n\t\t\treturn NaN;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(isNaN(n)) return NaN;\r\n\t\t\tresult *= n;\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Takes the first number and divides it by all following.\r\n * @param source\r\n * @param ignoreNaN Will cause this skip any NaN values.\r\n * @returns {number}\r\n */\r\nexport function quotient(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\tconst len = source ? source.length : 0;\r\n\tif(len<2)\r\n\t\treturn NaN;\r\n\r\n\tlet result = source[0];\r\n\r\n\tlet found = false;\r\n\tfor(let i=1;i<len;i++)\r\n\t{\r\n\t\tlet n = source[i];\r\n\t\tif(n===0)\r\n\t\t{\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\t\tif(isNaN(n))\r\n\t\t{\r\n\t\t\tif(!ignoreNaN)\r\n\t\t\t{\r\n\t\t\t\treturn NaN;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tresult /= n;\r\n\t\t\tif(!found) found = true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn found ? result : NaN;\r\n}\r\n\r\n\r\nfunction ifSet(\r\n\tsource:ArrayLike<number>,\r\n\tstart:number,\r\n\tignoreNaN:boolean,\r\n\tpredicate:(n:number, result:number) => boolean):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tlet result = start;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tlet found = false;\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(!isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tif(predicate(n, result))\r\n\t\t\t\t\tresult = n;\r\n\t\t\t\tif(!found) found = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!found)\r\n\t\t\treturn NaN;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor(let n of <number[]>source)\r\n\t\t{\r\n\t\t\tif(isNaN(n))\r\n\t\t\t\treturn NaN;\r\n\r\n\t\t\tif(predicate(n, result))\r\n\t\t\t\tresult = n;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function min(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\treturn ifSet(source, +Infinity, ignoreNaN, (n, result) => n<result);\r\n}\r\n\r\nexport function max(source:ArrayLike<number>, ignoreNaN:boolean = false):number\r\n{\r\n\treturn ifSet(source, -Infinity, ignoreNaN, (n, result) => n>result);\r\n}\r\n"]}
{"version":3,"sources":["System/Collections/LinkedNodeList.js","System/Collections/LinkedNodeList.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","assertValidDetached","node","propName","ArgumentNullException_1","ArgumentNullException","next","previous","InvalidOperationException_1","InvalidOperationException","Object","defineProperty","value","Utility_1","ArgumentException_1","EnumeratorBase_1","extends_1","LinkedNodeList","this","_first","_last","unsafeCount","_version","prototype","assertVersion","version","get","enumerable","configurable","i","forEach","action","ignoreVersioning","_","current","first","index","map","selector","result","push","clear","n","cF","cL","console","warn","dispose","contains","indexOf","getNodeAt","find","condition","c","removeFirst","removeNode","removeLast","prev","a","b","ArgumentException","format","removed","addNode","addNodeAfter","addNodeBefore","before","after","replace","replacement","valueEnumeratorFrom","list","EnumeratorBase","yielder","yieldReturn","yieldBreak","copyValues","array"],"mappings":"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","file":"LinkedNodeList.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../Text/Utility\", \"../Exceptions/InvalidOperationException\", \"../Exceptions/ArgumentException\", \"../Exceptions/ArgumentNullException\", \"./Enumeration/EnumeratorBase\", \"../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Utility_1 = require(\"../Text/Utility\");\n    var InvalidOperationException_1 = require(\"../Exceptions/InvalidOperationException\");\n    var ArgumentException_1 = require(\"../Exceptions/ArgumentException\");\n    var ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\n    var EnumeratorBase_1 = require(\"./Enumeration/EnumeratorBase\");\n    var extends_1 = require(\"../../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    /*****************************\n     * IMPORTANT NOTES ABOUT PERFORMANCE:\n     * http://jsperf.com/simulating-a-queue\n     *\n     * Adding to an array is very fast, but modifying is slow.\n     * LinkedList wins when modifying contents.\n     * http://stackoverflow.com/questions/166884/array-versus-linked-list\n     *****************************/\n    /**\n     * This class is useful for managing a list of linked nodes, but it does not protect against modifying individual links.\n     * If the consumer modifies a link (sets the previous or next value) it will effectively break the collection.\n     *\n     * It is possible to declare a node type of any kind as long as it contains a previous and next value that can reference another node.\n     * Although not as safe as the included LinkedList, this class has less overhead and is more flexible.\n     *\n     * The count (or length) of this LinkedNodeList is not tracked since it could be corrupted at any time.\n     */\n    var LinkedNodeList = /** @class */ (function () {\n        function LinkedNodeList() {\n            this._first = null;\n            this._last = null;\n            this.unsafeCount = 0;\n            this._version = 0;\n        }\n        LinkedNodeList.prototype.assertVersion = function (version) {\n            if (version !== this._version)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Collection was modified.\");\n            return true;\n        };\n        Object.defineProperty(LinkedNodeList.prototype, \"first\", {\n            /**\n             * The first node.  Will be null if the collection is empty.\n             */\n            get: function () {\n                return this._first;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedNodeList.prototype, \"last\", {\n            /**\n             * The last node.\n             */\n            get: function () {\n                return this._last;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedNodeList.prototype, \"count\", {\n            /**\n             * Iteratively counts the number of linked nodes and returns the value.\n             * @returns {number}\n             */\n            get: function () {\n                var next = this._first;\n                var i = 0;\n                while (next) {\n                    i++;\n                    next = next.next;\n                }\n                return i;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LinkedNodeList.prototype.forEach = function (action, ignoreVersioning) {\n            var _ = this;\n            var current = null, next = _.first; // Be sure to track the next node so if current node is removed.\n            var version = _._version;\n            var index = 0;\n            do {\n                if (!ignoreVersioning)\n                    _.assertVersion(version);\n                current = next;\n                next = current && current.next;\n            } while (current\n                && action(current, index++) !== false);\n            return index;\n        };\n        LinkedNodeList.prototype.map = function (selector) {\n            if (!selector)\n                throw new ArgumentNullException_1.ArgumentNullException('selector');\n            var result = [];\n            this.forEach(function (node, i) {\n                result.push(selector(node, i));\n            });\n            return result;\n        };\n        /**\n         * Erases the linked node's references to each other and returns the number of nodes.\n         * @returns {number}\n         */\n        LinkedNodeList.prototype.clear = function () {\n            var _ = this;\n            var n, cF = 0, cL = 0;\n            // First, clear in the forward direction.\n            n = _._first;\n            _._first = null;\n            while (n) {\n                cF++;\n                var current = n;\n                n = n.next;\n                current.next = null;\n            }\n            // Last, clear in the reverse direction.\n            n = _._last;\n            _._last = null;\n            while (n) {\n                cL++;\n                var current = n;\n                n = n.previous;\n                current.previous = null;\n            }\n            if (cF !== cL)\n                console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing. Forward: ' + cF + \", Reverse: \" + cL);\n            _._version++;\n            _.unsafeCount = 0;\n            return cF;\n        };\n        /**\n         * Clears the list.\n         */\n        LinkedNodeList.prototype.dispose = function () {\n            this.clear();\n        };\n        /**\n         * Iterates the list to see if a node exists.\n         * @param node\n         * @returns {boolean}\n         */\n        LinkedNodeList.prototype.contains = function (node) {\n            return this.indexOf(node) != -1;\n        };\n        /**\n         * Gets the index of a particular node.\n         * @param index\n         */\n        LinkedNodeList.prototype.getNodeAt = function (index) {\n            if (index < 0)\n                return null;\n            var next = this._first;\n            var i = 0;\n            while (next && i++ < index) {\n                next = next.next || null;\n            }\n            return next;\n        };\n        LinkedNodeList.prototype.find = function (condition) {\n            var node = null;\n            this.forEach(function (n, i) {\n                if (condition(n, i)) {\n                    node = n;\n                    return false;\n                }\n            });\n            return node;\n        };\n        /**\n         * Iterates the list to find the specified node and returns its index.\n         * @param node\n         * @returns {boolean}\n         */\n        LinkedNodeList.prototype.indexOf = function (node) {\n            if (node && (node.previous || node.next)) {\n                var index = 0;\n                var c = void 0, n = this._first;\n                do {\n                    c = n;\n                    if (c === node)\n                        return index;\n                    index++;\n                } while ((n = c && c.next));\n            }\n            return -1;\n        };\n        /**\n         * Removes the first node and returns true if successful.\n         * @returns {boolean}\n         */\n        LinkedNodeList.prototype.removeFirst = function () {\n            return !!this._first && this.removeNode(this._first);\n        };\n        /**\n         * Removes the last node and returns true if successful.\n         * @returns {boolean}\n         */\n        LinkedNodeList.prototype.removeLast = function () {\n            return !!this._last && this.removeNode(this._last);\n        };\n        /**\n         * Removes the specified node.\n         * Returns true if successful and false if not found (already removed).\n         * @param node\n         * @returns {boolean}\n         */\n        LinkedNodeList.prototype.removeNode = function (node) {\n            if (node == null)\n                throw new ArgumentNullException_1.ArgumentNullException('node');\n            var _ = this;\n            var prev = node.previous || null, next = node.next || null;\n            var a = false, b = false;\n            if (prev)\n                prev.next = next;\n            else if (_._first == node)\n                _._first = next;\n            else\n                a = true;\n            if (next)\n                next.previous = prev;\n            else if (_._last == node)\n                _._last = prev;\n            else\n                b = true;\n            if (a !== b) {\n                throw new ArgumentException_1.ArgumentException('node', Utility_1.format(\"Provided node is has no {0} reference but is not the {1} node!\", a ? \"previous\" : \"next\", a ? \"first\" : \"last\"));\n            }\n            var removed = !a && !b;\n            if (removed) {\n                _._version++;\n                _.unsafeCount--;\n                node.previous = null;\n                node.next = null;\n            }\n            return removed;\n        };\n        /**\n         * Adds a node to the end of the list.\n         * @param node\n         * @returns {LinkedNodeList}\n         */\n        LinkedNodeList.prototype.addNode = function (node) {\n            this.addNodeAfter(node);\n            return this;\n        };\n        /**\n         * Inserts a node before the specified 'before' node.\n         * If no 'before' node is specified, it inserts it as the first node.\n         * @param node\n         * @param before\n         * @returns {LinkedNodeList}\n         */\n        LinkedNodeList.prototype.addNodeBefore = function (node, before) {\n            if (before === void 0) { before = null; }\n            assertValidDetached(node);\n            var _ = this;\n            if (!before) {\n                before = _._first;\n            }\n            if (before) {\n                var prev = before.previous;\n                node.previous = prev;\n                node.next = before;\n                before.previous = node;\n                if (prev)\n                    prev.next = node;\n                if (before == _._first)\n                    _._first = node;\n            }\n            else {\n                _._first = _._last = node;\n            }\n            _._version++;\n            _.unsafeCount++;\n            return this;\n        };\n        /**\n         * Inserts a node after the specified 'after' node.\n         * If no 'after' node is specified, it appends it as the last node.\n         * @param node\n         * @param after\n         * @returns {LinkedNodeList}\n         */\n        LinkedNodeList.prototype.addNodeAfter = function (node, after) {\n            if (after === void 0) { after = null; }\n            assertValidDetached(node);\n            var _ = this;\n            if (!after) {\n                after = _._last;\n            }\n            if (after) {\n                var next = after.next;\n                node.next = next;\n                node.previous = after;\n                after.next = node;\n                if (next)\n                    next.previous = node;\n                if (after == _._last)\n                    _._last = node;\n            }\n            else {\n                _._first = _._last = node;\n            }\n            _._version++;\n            _.unsafeCount++;\n            return _;\n        };\n        /**\n         * Takes and existing node and replaces it.\n         * @param node\n         * @param replacement\n         * @returns {any}\n         */\n        LinkedNodeList.prototype.replace = function (node, replacement) {\n            if (node == null)\n                throw new ArgumentNullException_1.ArgumentNullException('node');\n            if (node == replacement)\n                return this;\n            assertValidDetached(replacement, 'replacement');\n            var _ = this;\n            replacement.previous = node.previous;\n            replacement.next = node.next;\n            if (node.previous)\n                node.previous.next = replacement;\n            if (node.next)\n                node.next.previous = replacement;\n            if (node == _._first)\n                _._first = replacement;\n            if (node == _._last)\n                _._last = replacement;\n            _._version++;\n            return _;\n        };\n        LinkedNodeList.valueEnumeratorFrom = function (list) {\n            if (!list)\n                throw new ArgumentNullException_1.ArgumentNullException('list');\n            var current, next, version;\n            return new EnumeratorBase_1.EnumeratorBase(function () {\n                // Initialize anchor...\n                current = null;\n                next = list.first;\n                version = list._version;\n            }, function (yielder) {\n                if (next) {\n                    list.assertVersion(version);\n                    current = next;\n                    next = current && current.next;\n                    return yielder.yieldReturn(current.value);\n                }\n                return yielder.yieldBreak();\n            });\n        };\n        LinkedNodeList.copyValues = function (list, array, index) {\n            if (index === void 0) { index = 0; }\n            if (list && list.first) {\n                if (!array)\n                    throw new ArgumentNullException_1.ArgumentNullException('array');\n                list.forEach(function (node, i) {\n                    array[index + i] = node.value;\n                });\n            }\n            return array;\n        };\n        return LinkedNodeList;\n    }());\n    exports.LinkedNodeList = LinkedNodeList;\n    function assertValidDetached(node, propName) {\n        if (propName === void 0) { propName = 'node'; }\n        if (node == null)\n            throw new ArgumentNullException_1.ArgumentNullException(propName);\n        if (node.next || node.previous)\n            throw new InvalidOperationException_1.InvalidOperationException(\"Cannot add a node to a LinkedNodeList that is already linked.\");\n    }\n    exports.default = LinkedNodeList;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {format} from \"../Text/Utility\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {EnumeratorBase} from \"./Enumeration/EnumeratorBase\";\r\nimport {ILinkedNode, ILinkedNodeWithValue} from \"./ILinkedListNode\";\r\nimport {IEnumerateEach} from \"./Enumeration/IEnumerateEach\";\r\nimport {IDisposable} from \"../Disposable/IDisposable\";\r\nimport {ILinkedNodeList} from \"./ILinkedList\";\r\nimport {IEnumerator} from \"./Enumeration/IEnumerator\";\r\nimport {ActionWithIndex, PredicateWithIndex, Selector, SelectorWithIndex} from \"../FunctionTypes\";\r\nimport {ArrayLikeWritable} from \"./Array/ArrayLikeWritable\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/**\r\n * This class is useful for managing a list of linked nodes, but it does not protect against modifying individual links.\r\n * If the consumer modifies a link (sets the previous or next value) it will effectively break the collection.\r\n *\r\n * It is possible to declare a node type of any kind as long as it contains a previous and next value that can reference another node.\r\n * Although not as safe as the included LinkedList, this class has less overhead and is more flexible.\r\n *\r\n * The count (or length) of this LinkedNodeList is not tracked since it could be corrupted at any time.\r\n */\r\nexport class LinkedNodeList<TNode extends ILinkedNode<TNode>>\r\nimplements ILinkedNodeList<TNode>, IEnumerateEach<TNode>, IDisposable\r\n{\r\n\r\n\tprivate _first:TNode|null;\r\n\tprivate _last:TNode|null;\r\n\tunsafeCount:number;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tthis._first = null;\r\n\t\tthis._last = null;\r\n\t\tthis.unsafeCount = 0;\r\n\t\tthis._version = 0;\r\n\t}\r\n\r\n\tprivate _version:number;\r\n\r\n\tassertVersion(version:number):true|never\r\n\t{\r\n\t\tif(version!==this._version)\r\n\t\t\tthrow new InvalidOperationException(\"Collection was modified.\");\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * The first node.  Will be null if the collection is empty.\r\n\t */\r\n\tget first():TNode|null\r\n\t{\r\n\t\treturn this._first;\r\n\t}\r\n\r\n\t/**\r\n\t * The last node.\r\n\t */\r\n\tget last():TNode|null\r\n\t{\r\n\t\treturn this._last;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Iteratively counts the number of linked nodes and returns the value.\r\n\t * @returns {number}\r\n\t */\r\n\tget count():number\r\n\t{\r\n\r\n\t\tlet next:TNode|null|undefined = this._first;\r\n\r\n\t\tlet i:number = 0;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\ti++;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn i;\r\n\t}\r\n\r\n\t// Note, no need for 'useCopy' since this avoids any modification conflict.\r\n\t// If iterating over a arrayCopy is necessary, a arrayCopy should be made manually.\r\n\tforEach(\r\n\t\taction:ActionWithIndex<TNode>, ignoreVersioning?:boolean):number\r\n\tforEach(\r\n\t\taction:PredicateWithIndex<TNode>, ignoreVersioning?:boolean):number\r\n\tforEach(\r\n\t\taction:ActionWithIndex<TNode> | PredicateWithIndex<TNode>, ignoreVersioning?:boolean):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet current:TNode|null|undefined = null,\r\n\t\t    next:TNode|null|undefined = _.first; // Be sure to track the next node so if current node is removed.\r\n\r\n\t\tconst version = _._version;\r\n\t\tlet index:number = 0;\r\n\t\tdo {\r\n\t\t\tif(!ignoreVersioning) _.assertVersion(version);\r\n\t\t\tcurrent = next;\r\n\t\t\tnext = current && current.next;\r\n\t\t}\r\n\t\twhile(current\r\n\t\t&& <any>action(current, index++)!==false);\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\tmap<T>(selector:Selector<TNode,T>):T[]\r\n\tmap<T>(selector:SelectorWithIndex<TNode,T>):T[]\r\n\tmap<T>(selector:SelectorWithIndex<TNode,T>):T[]\r\n\t{\r\n\t\tif(!selector) throw new ArgumentNullException('selector');\r\n\r\n\t\tconst result:T[] = [];\r\n\t\tthis.forEach((node, i)=>\r\n\t\t{\r\n\t\t\tresult.push(selector(node, i));\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Erases the linked node's references to each other and returns the number of nodes.\r\n\t * @returns {number}\r\n\t */\r\n\tclear():number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet n:TNode|null|undefined, cF:number = 0, cL:number = 0;\r\n\r\n\t\t// First, clear in the forward direction.\r\n\t\tn = _._first;\r\n\t\t_._first = null;\r\n\r\n\t\twhile(n)\r\n\t\t{\r\n\t\t\tcF++;\r\n\t\t\tlet current = n;\r\n\t\t\tn = n.next;\r\n\t\t\tcurrent.next = null;\r\n\t\t}\r\n\r\n\t\t// Last, clear in the reverse direction.\r\n\t\tn = _._last;\r\n\t\t_._last = null;\r\n\r\n\t\twhile(n)\r\n\t\t{\r\n\t\t\tcL++;\r\n\t\t\tlet current = n;\r\n\t\t\tn = n.previous;\r\n\t\t\tcurrent.previous = null;\r\n\t\t}\r\n\r\n\t\tif(cF!==cL) console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing. Forward: ' + cF + \", Reverse: \" + cL);\r\n\r\n\t\t_._version++;\r\n\t\t_.unsafeCount = 0;\r\n\r\n\t\treturn cF;\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the list.\r\n\t */\r\n\tdispose():void\r\n\t{\r\n\t\tthis.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to see if a node exists.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tcontains(node:TNode):boolean\r\n\t{\r\n\t\treturn this.indexOf(node)!= -1;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the index of a particular node.\r\n\t * @param index\r\n\t */\r\n\tgetNodeAt(index:number):TNode|null\r\n\t{\r\n\t\tif(index<0)\r\n\t\t\treturn null;\r\n\r\n\t\tlet next = this._first;\r\n\r\n\t\tlet i:number = 0;\r\n\t\twhile(next && i++<index)\r\n\t\t{\r\n\t\t\tnext = next.next || null;\r\n\t\t}\r\n\r\n\t\treturn next;\r\n\r\n\t}\r\n\r\n\tfind(condition:PredicateWithIndex<TNode>):TNode|null\r\n\t{\r\n\t\tlet node:TNode|null = null;\r\n\t\tthis.forEach((n, i)=>\r\n\t\t{\r\n\t\t\tif(condition(n, i))\r\n\t\t\t{\r\n\t\t\t\tnode = n;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn node;\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to find the specified node and returns its index.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tindexOf(node:TNode):number\r\n\t{\r\n\t\tif(node && (node.previous || node.next))\r\n\t\t{\r\n\r\n\t\t\tlet index = 0;\r\n\t\t\tlet c:TNode|null|undefined,\r\n\t\t\t    n:TNode|null|undefined = this._first;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tc = n;\r\n\t\t\t\tif(c===node) return index;\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t\twhile((n = c && c.next));\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the first node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveFirst():boolean\r\n\t{\r\n\t\treturn !!this._first && this.removeNode(this._first);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the last node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveLast():boolean\r\n\t{\r\n\t\treturn !!this._last && this.removeNode(this._last);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Removes the specified node.\r\n\t * Returns true if successful and false if not found (already removed).\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveNode(node:TNode):boolean\r\n\t{\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tconst _ = this;\r\n\t\tconst prev:TNode|null = node.previous || null,\r\n\t\t      next:TNode|null = node.next || null;\r\n\r\n\t\tlet a:boolean = false,\r\n\t\t    b:boolean = false;\r\n\r\n\t\tif(prev) prev.next = next;\r\n\t\telse if(_._first==node) _._first = next;\r\n\t\telse a = true;\r\n\r\n\t\tif(next) next.previous = prev;\r\n\t\telse if(_._last==node) _._last = prev;\r\n\t\telse b = true;\r\n\r\n\t\tif(a!==b)\r\n\t\t{\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'node', format(\r\n\t\t\t\t\t\"Provided node is has no {0} reference but is not the {1} node!\",\r\n\t\t\t\t\ta ? \"previous\" : \"next\", a ? \"first\" : \"last\"\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tconst removed = !a && !b;\r\n\t\tif(removed)\r\n\t\t{\r\n\t\t\t_._version++;\r\n\t\t\t_.unsafeCount--;\r\n\t\t\tnode.previous = null;\r\n\t\t\tnode.next = null;\r\n\t\t}\r\n\t\treturn removed;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a node to the end of the list.\r\n\t * @param node\r\n\t * @returns {LinkedNodeList}\r\n\t */\r\n\taddNode(node:TNode):this\r\n\t{\r\n\t\tthis.addNodeAfter(node);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a node before the specified 'before' node.\r\n\t * If no 'before' node is specified, it inserts it as the first node.\r\n\t * @param node\r\n\t * @param before\r\n\t * @returns {LinkedNodeList}\r\n\t */\r\n\taddNodeBefore(node:TNode, before:TNode|null = null):this\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!before)\r\n\t\t{\r\n\t\t\tbefore = _._first;\r\n\t\t}\r\n\r\n\t\tif(before)\r\n\t\t{\r\n\t\t\tlet prev = before.previous;\r\n\t\t\tnode.previous = prev;\r\n\t\t\tnode.next = before;\r\n\r\n\t\t\tbefore.previous = node;\r\n\t\t\tif(prev) prev.next = node;\r\n\t\t\tif(before==_._first) _._first = node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\r\n\t\t_._version++;\r\n\t\t_.unsafeCount++;\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a node after the specified 'after' node.\r\n\t * If no 'after' node is specified, it appends it as the last node.\r\n\t * @param node\r\n\t * @param after\r\n\t * @returns {LinkedNodeList}\r\n\t */\r\n\taddNodeAfter(node:TNode, after:TNode|null = null):this\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!after)\r\n\t\t{\r\n\t\t\tafter = _._last;\r\n\t\t}\r\n\r\n\t\tif(after)\r\n\t\t{\r\n\t\t\tlet next = after.next;\r\n\t\t\tnode.next = next;\r\n\t\t\tnode.previous = after;\r\n\r\n\t\t\tafter.next = node;\r\n\t\t\tif(next) next.previous = node;\r\n\t\t\tif(after==_._last) _._last = node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\r\n\t\t_._version++;\r\n\t\t_.unsafeCount++;\r\n\r\n\t\treturn _;\r\n\t}\r\n\r\n\t/**\r\n\t * Takes and existing node and replaces it.\r\n\t * @param node\r\n\t * @param replacement\r\n\t * @returns {any}\r\n\t */\r\n\treplace(node:TNode, replacement:TNode):this\r\n\t{\r\n\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tif(node==replacement) return this;\r\n\r\n\t\tassertValidDetached(replacement, 'replacement');\r\n\r\n\t\tconst _ = this;\r\n\t\treplacement.previous = node.previous;\r\n\t\treplacement.next = node.next;\r\n\r\n\t\tif(node.previous) node.previous.next = replacement;\r\n\t\tif(node.next) node.next.previous = replacement;\r\n\r\n\t\tif(node==_._first) _._first = replacement;\r\n\t\tif(node==_._last) _._last = replacement;\r\n\r\n\t\t_._version++;\r\n\r\n\t\treturn _;\r\n\t}\r\n\r\n\tstatic valueEnumeratorFrom<T>(list:LinkedNodeList<ILinkedNodeWithValue<T>>):IEnumerator<T>\r\n\t{\r\n\r\n\t\tif(!list) throw new ArgumentNullException('list');\r\n\r\n\t\tlet current:ILinkedNodeWithValue<T>|null|undefined,\r\n\t\t    next:ILinkedNodeWithValue<T>|null|undefined,\r\n\t\t    version:number;\r\n\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t// Initialize anchor...\r\n\t\t\t\tcurrent = null;\r\n\t\t\t\tnext = list.first;\r\n\t\t\t\tversion = list._version;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\tif(next)\r\n\t\t\t\t{\r\n\t\t\t\t\tlist.assertVersion(version);\r\n\r\n\t\t\t\t\tcurrent = next;\r\n\t\t\t\t\tnext = current && current.next;\r\n\t\t\t\t\treturn yielder.yieldReturn(current.value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic copyValues<T,TDestination extends ArrayLikeWritable<any>>(\r\n\t\tlist:LinkedNodeList<ILinkedNodeWithValue<T>>,\r\n\t\tarray:TDestination,\r\n\t\tindex:number = 0):TDestination\r\n\t{\r\n\t\tif(list && list.first)\r\n\t\t{\r\n\t\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\t\tlist.forEach(\r\n\t\t\t\t(node, i) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tarray[index + i] = node.value;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n}\r\n\r\nfunction assertValidDetached<TNode extends ILinkedNode<TNode>>(\r\n\tnode:TNode,\r\n\tpropName:string = 'node')\r\n{\r\n\r\n\tif(node==null)\r\n\t\tthrow new ArgumentNullException(propName);\r\n\r\n\tif(node.next || node.previous)\r\n\t\tthrow new InvalidOperationException(\"Cannot add a node to a LinkedNodeList that is already linked.\");\r\n\r\n}\r\n\r\nexport default LinkedNodeList;"]}
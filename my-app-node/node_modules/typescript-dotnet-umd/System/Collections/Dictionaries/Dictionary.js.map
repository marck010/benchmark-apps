{"version":3,"sources":["System/Collections/Dictionaries/Dictionary.js","System/Collections/Dictionaries/Dictionary.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","linkedNodeList","recycle","linkedListPool","ObjectPool_1","ObjectPool","LinkedNodeList_1","LinkedNodeList","r","clear","add","take","Object","defineProperty","value","Compare_1","Types_1","EnumeratorBase_1","getIdentifier_1","DictionaryBase_1","extends_1","__extends","VOID0","HashEntry","key","previous","next","this","Dictionary","_super","_keyGenerator","_this","call","_entries","_buckets","prototype","_onDispose","_","_hashGenerator","getCount","unsafeCount","_getBucket","hash","createIfMissing","Type","isPrimitiveOrSymbol","console","warn","buckets","bucket","_getBucketEntry","comparer","compareKey","getIdentifier","find","e","_getEntry","getValue","_setValueInternal","entries","bucketEntry","b","old","areEqual","x","removeNode","y","count","Error","entry","addNode","_clearInternal","hasOwnProperty","getEnumerator","throwIfDisposed","ver","currentEntry","EnumeratorBase","_version","first","yielder","assertVersion","result","yieldReturn","yieldBreak","getKeys","push","getValues"],"mappings":"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","file":"Dictionary.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Original: http://linqjs.codeplex.com/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../../Compare\", \"../../Types\", \"../Enumeration/EnumeratorBase\", \"../LinkedNodeList\", \"../../Disposable/ObjectPool\", \"./getIdentifier\", \"./DictionaryBase\", \"../../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Compare_1 = require(\"../../Compare\");\n    var Types_1 = require(\"../../Types\");\n    var EnumeratorBase_1 = require(\"../Enumeration/EnumeratorBase\");\n    var LinkedNodeList_1 = require(\"../LinkedNodeList\");\n    var ObjectPool_1 = require(\"../../Disposable/ObjectPool\");\n    var getIdentifier_1 = require(\"./getIdentifier\");\n    var DictionaryBase_1 = require(\"./DictionaryBase\");\n    var extends_1 = require(\"../../../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var VOID0 = void 0;\n    // LinkedList for Dictionary\n    var HashEntry = /** @class */ (function () {\n        function HashEntry(key, value, previous, next) {\n            this.key = key;\n            this.value = value;\n            this.previous = previous;\n            this.next = next;\n        }\n        return HashEntry;\n    }());\n    var linkedListPool;\n    //noinspection JSUnusedLocalSymbols\n    function linkedNodeList(recycle) {\n        if (!linkedListPool)\n            linkedListPool\n                = new ObjectPool_1.ObjectPool(20, function () { return new LinkedNodeList_1.LinkedNodeList(); }, function (r) { return r.clear(); });\n        if (!recycle)\n            return linkedListPool.take();\n        linkedListPool.add(recycle);\n    }\n    var Dictionary = /** @class */ (function (_super) {\n        __extends(Dictionary, _super);\n        function Dictionary(_keyGenerator) {\n            var _this = _super.call(this) || this;\n            _this._keyGenerator = _keyGenerator;\n            _this._entries = linkedNodeList();\n            _this._buckets = {};\n            return _this;\n        }\n        Dictionary.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            var _ = this;\n            _._entries = null;\n            _._buckets = null;\n            _._hashGenerator = null;\n        };\n        Dictionary.prototype.getCount = function () {\n            return this._entries && this._entries.unsafeCount || 0;\n        };\n        Dictionary.prototype._getBucket = function (hash, createIfMissing) {\n            if (hash == null || !createIfMissing && !this.getCount())\n                return null;\n            if (!Types_1.Type.isPrimitiveOrSymbol(hash))\n                console.warn(\"Key type not indexable and could cause Dictionary to be extremely slow.\");\n            var buckets = this._buckets;\n            var bucket = buckets[hash];\n            if (createIfMissing && !bucket)\n                buckets[hash]\n                    = bucket\n                        = linkedNodeList();\n            return bucket || null;\n        };\n        Dictionary.prototype._getBucketEntry = function (key, hash, bucket) {\n            if (key == null || !this.getCount())\n                return null;\n            var _ = this, comparer = _._keyGenerator, compareKey = comparer ? comparer(key) : key;\n            if (!bucket)\n                bucket = _._getBucket(hash || getIdentifier_1.getIdentifier(compareKey));\n            return bucket\n                && (comparer\n                    ? bucket.find(function (e) { return comparer(e.key) === compareKey; })\n                    : bucket.find(function (e) { return e.key === compareKey; }));\n        };\n        Dictionary.prototype._getEntry = function (key) {\n            var e = this._getBucketEntry(key);\n            return e && e.value;\n        };\n        Dictionary.prototype.getValue = function (key) {\n            var e = this._getEntry(key);\n            return e ? e.value : VOID0;\n        };\n        Dictionary.prototype._setValueInternal = function (key, value) {\n            var _ = this;\n            var buckets = _._buckets, entries = _._entries, compareKey = _._keyGenerator ? _._keyGenerator(key) : key, hash = getIdentifier_1.getIdentifier(compareKey);\n            var bucket = _._getBucket(hash);\n            var bucketEntry = bucket && _._getBucketEntry(key, hash, bucket);\n            // Entry exits? Delete or update\n            if (bucketEntry) {\n                var b = bucket;\n                if (value === VOID0) {\n                    var x = b.removeNode(bucketEntry), y = entries.removeNode(bucketEntry.value);\n                    if (x && !b.count) {\n                        delete buckets[hash];\n                        linkedNodeList(b);\n                        bucket = null;\n                    }\n                    if (x !== y)\n                        throw \"Entries and buckets are out of sync.\";\n                    if (x)\n                        return true;\n                }\n                else {\n                    // We don't expose the internal hash entries so replacing the value is ok.\n                    var old = bucketEntry.value.value;\n                    bucketEntry.value.value = value;\n                    return !Compare_1.areEqual(value, old);\n                }\n            }\n            else if (value !== VOID0) {\n                if (!bucket)\n                    bucket = _._getBucket(hash, true);\n                if (!bucket)\n                    throw new Error(\"\\\"\" + hash + \"\\\" cannot be added to lookup table.\");\n                var entry = new HashEntry(key, value);\n                entries.addNode(entry);\n                bucket.addNode(new HashEntry(key, entry));\n                return true;\n            }\n            return false;\n        };\n        Dictionary.prototype._clearInternal = function () {\n            var _ = this;\n            var buckets = _._buckets;\n            // Ensure reset and clean...\n            for (var key in buckets) {\n                if (buckets.hasOwnProperty(key)) {\n                    var bucket = buckets[key];\n                    delete buckets[key];\n                    linkedNodeList(bucket);\n                }\n            }\n            return _._entries.clear();\n        };\n        /*\n         * Note: super.getEnumerator() works perfectly well,\n         * but enumerating the internal linked node list is much more efficient.\n         */\n        Dictionary.prototype.getEnumerator = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var ver, currentEntry;\n            return new EnumeratorBase_1.EnumeratorBase(function () {\n                _.throwIfDisposed();\n                ver = _._version;\n                currentEntry = _._entries.first;\n            }, function (yielder) {\n                if (currentEntry) {\n                    _.throwIfDisposed();\n                    _.assertVersion(ver);\n                    var result = { key: currentEntry.key, value: currentEntry.value };\n                    currentEntry = currentEntry.next || null;\n                    return yielder.yieldReturn(result);\n                }\n                return yielder.yieldBreak();\n            });\n        };\n        Dictionary.prototype.getKeys = function () {\n            var _ = this;\n            var result = [];\n            var e = _._entries && _._entries.first;\n            while (e) {\n                result.push(e.key);\n                e = e.next;\n            }\n            return result;\n        };\n        Dictionary.prototype.getValues = function () {\n            var _ = this;\n            var result = [];\n            var e = _._entries && _._entries.first;\n            while (e) {\n                result.push(e.value);\n                e = e.next;\n            }\n            return result;\n        };\n        return Dictionary;\n    }(DictionaryBase_1.default));\n    exports.Dictionary = Dictionary;\n    exports.default = Dictionary;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Original: http://linqjs.codeplex.com/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {areEqual} from \"../../Compare\";\r\nimport {Type} from \"../../Types\";\r\nimport {EnumeratorBase} from \"../Enumeration/EnumeratorBase\";\r\nimport {LinkedNodeList} from \"../LinkedNodeList\";\r\nimport {ObjectPool} from \"../../Disposable/ObjectPool\";\r\nimport {IMap} from \"./IDictionary\";\r\nimport {IKeyValuePair} from \"../../KeyValuePair\";\r\nimport {getIdentifier} from \"./getIdentifier\";\r\nimport {IEnumerator} from \"../Enumeration/IEnumerator\";\r\nimport {ILinkedNode} from \"../ILinkedListNode\";\r\nimport {HashSelector} from \"../../FunctionTypes\";\r\nimport DictionaryBase from \"./DictionaryBase\";\r\nimport __extendsImport from \"../../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\n\r\nexport interface IHashEntry<TKey, TValue>\r\nextends ILinkedNode<IHashEntry<TKey, TValue>>, IKeyValuePair<TKey,TValue>\r\n{\r\n\r\n}\r\n// LinkedList for Dictionary\r\nclass HashEntry<TKey, TValue>\r\nimplements IHashEntry<TKey, TValue>\r\n{\r\n\tconstructor(\r\n\t\tpublic key:TKey,\r\n\t\tpublic value:TValue,\r\n\t\tpublic previous?:IHashEntry<TKey, TValue>|null,\r\n\t\tpublic next?:IHashEntry<TKey, TValue>|null)\r\n\t{\r\n\r\n\t}\r\n}\r\n\r\ntype HashEntryLinkedList<TKey,TValue> = LinkedNodeList<IHashEntry<TKey,IHashEntry<TKey,TValue>>>;\r\n\r\nlet linkedListPool:ObjectPool<LinkedNodeList<any>>;\r\nfunction linkedNodeList():LinkedNodeList<any>;\r\nfunction linkedNodeList(recycle?:LinkedNodeList<any>):void;\r\n//noinspection JSUnusedLocalSymbols\r\nfunction linkedNodeList(recycle?:LinkedNodeList<any>):LinkedNodeList<any>|void\r\n{\r\n\tif(!linkedListPool)\r\n\t\tlinkedListPool\r\n\t\t\t= new ObjectPool<LinkedNodeList<any>>(20, ()=>new LinkedNodeList<any>(), r=>r.clear());\r\n\tif(!recycle) return linkedListPool.take();\r\n\tlinkedListPool.add(recycle);\r\n}\r\n\r\n\r\n\r\nexport class Dictionary<TKey, TValue> extends DictionaryBase<TKey, TValue>\r\n{\r\n\t// Retains the order...\r\n\tprivate readonly _entries:LinkedNodeList<IHashEntry<TKey, TValue>>;\r\n\tprivate readonly _buckets:IMap<LinkedNodeList<IHashEntry<TKey, IHashEntry<TKey, TValue>>>>;\r\n\r\n\tconstructor(\r\n\t\tprivate readonly _keyGenerator?:HashSelector<TKey>)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._entries = linkedNodeList();\r\n\t\tthis._buckets = {};\r\n\t}\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tconst _ = (<any>this);\r\n\t\t_._entries = null;\r\n\t\t_._buckets = null;\r\n\t\t_._hashGenerator = null;\r\n\t}\r\n\r\n\tprotected getCount():number\r\n\t{\r\n\t\treturn this._entries && this._entries.unsafeCount || 0;\r\n\t}\r\n\r\n\tprivate _getBucket(\r\n\t\thash:string|number|symbol,\r\n\t\tcreateIfMissing?:boolean):HashEntryLinkedList<TKey,TValue>|null\r\n\t{\r\n\t\tif(hash==null || !createIfMissing && !this.getCount())\r\n\t\t\treturn null;\r\n\r\n\t\tif(!Type.isPrimitiveOrSymbol(hash))\r\n\t\t\tconsole.warn(\"Key type not indexable and could cause Dictionary to be extremely slow.\");\r\n\r\n\t\tconst buckets = this._buckets;\r\n\t\tlet bucket = buckets[hash];\r\n\r\n\t\tif(createIfMissing && !bucket)\r\n\t\t\tbuckets[hash]\r\n\t\t\t\t= bucket\r\n\t\t\t\t= linkedNodeList();\r\n\r\n\t\treturn bucket || null;\r\n\t}\r\n\r\n\tprivate _getBucketEntry(\r\n\t\tkey:TKey,\r\n\t\thash?:string|number|symbol,\r\n\t\tbucket?:HashEntryLinkedList<TKey,TValue>|null):IHashEntry<TKey,IHashEntry<TKey,TValue>>|null\r\n\t{\r\n\t\tif(key==null || !this.getCount())\r\n\t\t\treturn null;\r\n\r\n\t\tconst _          = this,\r\n\t\t      comparer   = _._keyGenerator,\r\n\t\t      compareKey = comparer ? comparer(key) : key;\r\n\r\n\t\tif(!bucket) bucket = _._getBucket(hash || getIdentifier(compareKey));\r\n\r\n\t\treturn bucket\r\n\t\t\t&& (comparer\r\n\t\t\t\t? bucket.find(e=>comparer!(e.key)===compareKey)\r\n\t\t\t\t: bucket.find(e=>e.key===compareKey)\r\n\t\t\t);\r\n\t}\r\n\r\n\tprotected _getEntry(key:TKey):IHashEntry<TKey,TValue>|null\r\n\t{\r\n\t\tconst e = this._getBucketEntry(key);\r\n\t\treturn e && e.value;\r\n\t}\r\n\r\n\tgetValue(key:TKey):TValue|undefined\r\n\t{\r\n\t\tconst e = this._getEntry(key);\r\n\t\treturn e ? e.value : VOID0;\r\n\t}\r\n\r\n\tprotected _setValueInternal(key:TKey, value:TValue|undefined):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst buckets    = _._buckets,\r\n\t\t      entries    = _._entries,\r\n\t\t      compareKey = _._keyGenerator ? _._keyGenerator(key) : key,\r\n\t\t      hash       = getIdentifier(compareKey);\r\n\t\tlet bucket = _._getBucket(hash);\r\n\t\tconst bucketEntry = bucket && _._getBucketEntry(key, hash, bucket);\r\n\r\n\t\t// Entry exits? Delete or update\r\n\t\tif(bucketEntry)\r\n\t\t{\r\n\t\t\tconst b = <HashEntryLinkedList<TKey,TValue>>bucket;\r\n\t\t\tif(value===VOID0)\r\n\t\t\t{\r\n\t\t\t\tlet x = b.removeNode(bucketEntry),\r\n\t\t\t\t    y = entries.removeNode(bucketEntry.value);\r\n\r\n\t\t\t\tif(x && !b.count)\r\n\t\t\t\t{\r\n\t\t\t\t\tdelete buckets[hash];\r\n\t\t\t\t\tlinkedNodeList(b);\r\n\t\t\t\t\tbucket = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(x!==y) throw \"Entries and buckets are out of sync.\";\r\n\r\n\t\t\t\tif(x) return true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// We don't expose the internal hash entries so replacing the value is ok.\r\n\t\t\t\tconst old = bucketEntry.value.value;\r\n\t\t\t\tbucketEntry.value.value = value;\r\n\t\t\t\treturn !areEqual(value, old);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse if(value!==VOID0)\r\n\t\t{\r\n\t\t\tif(!bucket) bucket = _._getBucket(hash, true);\r\n\t\t\tif(!bucket) throw new Error(`\"${hash}\" cannot be added to lookup table.`);\r\n\t\t\tlet entry = new HashEntry(key, value);\r\n\t\t\tentries.addNode(entry);\r\n\t\t\tbucket.addNode(new HashEntry(key, entry));\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst buckets = _._buckets;\r\n\r\n\t\t// Ensure reset and clean...\r\n\t\tfor(let key in buckets)\r\n\t\t{\r\n\t\t\tif(buckets.hasOwnProperty(key))\r\n\t\t\t{\r\n\t\t\t\tlet bucket = buckets[key];\r\n\t\t\t\tdelete buckets[key];\r\n\t\t\t\tlinkedNodeList(bucket);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn _._entries.clear();\r\n\t}\r\n\r\n\t/*\r\n\t * Note: super.getEnumerator() works perfectly well,\r\n\t * but enumerating the internal linked node list is much more efficient.\r\n\t */\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tlet ver:number, currentEntry:IHashEntry<TKey, TValue>|null;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\tver = _._version;\r\n\t\t\t\tcurrentEntry = _._entries.first;\r\n\t\t\t},\r\n\t\t\t(yielder) =>\r\n\t\t\t{\r\n\t\t\t\tif(currentEntry)\r\n\t\t\t\t{\r\n\t\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\t\t_.assertVersion(ver);\r\n\t\t\t\t\tconst result = {key: currentEntry.key, value: currentEntry.value};\r\n\t\t\t\t\tcurrentEntry = currentEntry.next || null;\r\n\t\t\t\t\treturn yielder.yieldReturn(result);\r\n\t\t\t\t}\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tprotected getKeys():TKey[]\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst result:TKey[] = [];\r\n\t\tlet e:any = _._entries && _._entries.first;\r\n\t\twhile(e)\r\n\t\t{\r\n\t\t\tresult.push(e.key);\r\n\t\t\te = e.next;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprotected getValues():TValue[]\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst result:TValue[] = [];\r\n\t\tlet e:any = _._entries && _._entries.first;\r\n\t\twhile(e)\r\n\t\t{\r\n\t\t\tresult.push(e.value);\r\n\t\t\te = e.next;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n}\r\n\r\nexport default Dictionary;"]}
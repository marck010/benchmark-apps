{"version":3,"sources":["System/Collections/Dictionaries/DictionaryBase.js","System/Collections/Dictionaries/DictionaryBase.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Object","defineProperty","value","Compare_1","Enumerator_1","CollectionBase_1","EnumeratorBase_1","ArgumentNullException_1","InvalidOperationException_1","KeyValueExtract_1","extends_1","KeyNotFoundException_1","__extends","VOID0","DictionaryBase","_super","source","call","this","prototype","_onValueModified","key","old","_addInternal","item","_this","ArgumentNullException","extractKeyValue","addByKeyValue","_clearInternal","_","count","_i","_a","keys","length","removeByKey","contains","getCount","getValue","areEqual","_removeInternal","get","getKeys","enumerable","configurable","getValues","InvalidOperationException","containsKey","ex","data","setValue","getAssuredValue","KeyNotFoundException","tryGetValue","out","assertModifiable","changed","_setValueInternal","_signalModification","_getEntry","containsValue","e","getEnumerator","moveNext","current","dispose","removeByValue","importEntries","pairs","_importEntries","forEach","pair","throwIfDisposed","ver","len","index","EnumeratorBase","_version","yielder","assertVersion","yieldReturn","yieldBreak","CollectionBase"],"mappings":"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","file":"DictionaryBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../../Compare\", \"../Enumeration/Enumerator\", \"../CollectionBase\", \"../Enumeration/EnumeratorBase\", \"../../Exceptions/ArgumentNullException\", \"../../Exceptions/InvalidOperationException\", \"../../KeyValueExtract\", \"../../../extends\", \"../KeyNotFoundException\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Compare_1 = require(\"../../Compare\");\n    var Enumerator_1 = require(\"../Enumeration/Enumerator\");\n    var CollectionBase_1 = require(\"../CollectionBase\");\n    var EnumeratorBase_1 = require(\"../Enumeration/EnumeratorBase\");\n    var ArgumentNullException_1 = require(\"../../Exceptions/ArgumentNullException\");\n    var InvalidOperationException_1 = require(\"../../Exceptions/InvalidOperationException\");\n    var KeyValueExtract_1 = require(\"../../KeyValueExtract\");\n    var extends_1 = require(\"../../../extends\");\n    var KeyNotFoundException_1 = require(\"../KeyNotFoundException\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var VOID0 = void 0;\n    // Design Note: Should DictionaryAbstractBase be IDisposable?\n    var DictionaryBase = /** @class */ (function (_super) {\n        __extends(DictionaryBase, _super);\n        function DictionaryBase(source) {\n            return _super.call(this, source) || this;\n        }\n        //noinspection JSUnusedLocalSymbols\n        DictionaryBase.prototype._onValueModified = function (key, value, old) {\n        };\n        DictionaryBase.prototype._addInternal = function (item) {\n            var _this = this;\n            if (!item)\n                throw new ArgumentNullException_1.ArgumentNullException('item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.');\n            return KeyValueExtract_1.extractKeyValue(item, function (key, value) { return _this.addByKeyValue(key, value); });\n        };\n        DictionaryBase.prototype._clearInternal = function () {\n            var _ = this;\n            var count = 0;\n            for (var _i = 0, _a = _.keys; _i < _a.length; _i++) {\n                var key = _a[_i];\n                if (_.removeByKey(key))\n                    count++;\n            }\n            return count;\n        };\n        DictionaryBase.prototype.contains = function (item) {\n            var _this = this;\n            // Should never have a null object in the collection.\n            if (!item || !this.getCount())\n                return false;\n            return KeyValueExtract_1.extractKeyValue(item, function (key, value) {\n                // Leave as variable for debugging...\n                var v = _this.getValue(key);\n                return Compare_1.areEqual(value, v);\n            });\n        };\n        DictionaryBase.prototype._removeInternal = function (item) {\n            var _this = this;\n            if (!item)\n                return 0;\n            return KeyValueExtract_1.extractKeyValue(item, function (key, value) {\n                // Leave as variable for debugging...\n                var v = _this.getValue(key);\n                return (Compare_1.areEqual(value, v) && _this.removeByKey(key))\n                    ? 1 : 0;\n            });\n        };\n        Object.defineProperty(DictionaryBase.prototype, \"keys\", {\n            get: function () { return this.getKeys(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DictionaryBase.prototype, \"values\", {\n            get: function () { return this.getValues(); },\n            enumerable: true,\n            configurable: true\n        });\n        DictionaryBase.prototype.addByKeyValue = function (key, value) {\n            if (value === VOID0)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Cannot add 'undefined' as a value.\");\n            var _ = this;\n            if (_.containsKey(key)) {\n                var ex = new InvalidOperationException_1.InvalidOperationException(\"Adding a key/value when the key already exists.\");\n                ex.data['key'] = key;\n                ex.data['value'] = value;\n                throw ex;\n            }\n            return _.setValue(key, value);\n        };\n        DictionaryBase.prototype.getAssuredValue = function (key) {\n            var value = this.getValue(key);\n            if (value === VOID0)\n                throw new KeyNotFoundException_1.KeyNotFoundException(\"Key '\" + key + \"' not found.\");\n            return value;\n        };\n        DictionaryBase.prototype.tryGetValue = function (key, out) {\n            var value = this.getValue(key);\n            if (value !== VOID0) {\n                out(value);\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Sets the value of an entry.\n         * It's important to know that 'undefined' cannot exist as a value in the dictionary and is used as a flag for removal.\n         * @param key\n         * @param value\n         * @returns {boolean}\n         */\n        DictionaryBase.prototype.setValue = function (key, value) {\n            // setValue shouldn't need to worry about recursion...\n            var _ = this;\n            _.assertModifiable();\n            var changed = false;\n            var old = _.getValue(key); // get the old value here and pass to internal.\n            if (!Compare_1.areEqual(value, old) && _._setValueInternal(key, value)) {\n                changed = true;\n                _._onValueModified(key, value, old);\n            }\n            _._signalModification(changed);\n            return changed;\n        };\n        DictionaryBase.prototype.containsKey = function (key) {\n            return !!this._getEntry(key);\n        };\n        DictionaryBase.prototype.containsValue = function (value) {\n            var e = this.getEnumerator();\n            while (e.moveNext()) {\n                if (Compare_1.areEqual(e.current, value, true)) {\n                    e.dispose();\n                    return true;\n                }\n            }\n            return false;\n        };\n        DictionaryBase.prototype.removeByKey = function (key) {\n            return this.setValue(key, VOID0);\n        };\n        DictionaryBase.prototype.removeByValue = function (value) {\n            var _ = this;\n            var count = 0;\n            for (var _i = 0, _a = _.getKeys(); _i < _a.length; _i++) {\n                var key = _a[_i];\n                if (Compare_1.areEqual(_.getValue(key), value, true)) {\n                    _.removeByKey(key);\n                    count++;\n                }\n            }\n            return count;\n        };\n        DictionaryBase.prototype.importEntries = function (pairs) {\n            // Allow piping through to trigger onModified properly.\n            return _super.prototype.importEntries.call(this, pairs);\n        };\n        DictionaryBase.prototype._importEntries = function (pairs) {\n            var _ = this;\n            if (!pairs)\n                return 0;\n            var changed = 0;\n            Enumerator_1.forEach(pairs, function (pair) { return KeyValueExtract_1.extractKeyValue(pair, function (key, value) {\n                if (_._setValueInternal(key, value))\n                    changed++;\n            }); });\n            return changed;\n        };\n        DictionaryBase.prototype.getEnumerator = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var ver, keys, len, index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(function () {\n                _.throwIfDisposed();\n                ver = _._version; // Track the version since getKeys is a copy.\n                keys = _.getKeys();\n                len = keys.length;\n            }, function (yielder) {\n                _.throwIfDisposed();\n                _.assertVersion(ver);\n                while (index < len) {\n                    var key = keys[index++], value = _.getValue(key);\n                    if (value !== VOID0)\n                        return yielder.yieldReturn({ key: key, value: value });\n                }\n                return yielder.yieldBreak();\n            });\n        };\n        return DictionaryBase;\n    }(CollectionBase_1.CollectionBase));\n    exports.DictionaryBase = DictionaryBase;\n    exports.default = DictionaryBase;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {areEqual} from \"../../Compare\";\r\nimport {forEach} from \"../Enumeration/Enumerator\";\r\nimport {CollectionBase} from \"../CollectionBase\";\r\nimport {EnumeratorBase} from \"../Enumeration/EnumeratorBase\";\r\nimport {ArgumentNullException} from \"../../Exceptions/ArgumentNullException\";\r\nimport {InvalidOperationException} from \"../../Exceptions/InvalidOperationException\";\r\nimport {extractKeyValue} from \"../../KeyValueExtract\";\r\nimport {IKeyValuePair, KeyValuePair} from \"../../KeyValuePair\";\r\nimport {IDictionary} from \"./IDictionary\";\r\nimport {IEnumerator} from \"../Enumeration/IEnumerator\";\r\nimport {IEnumerableOrArray} from \"../IEnumerableOrArray\";\r\nimport __extendsImport from \"../../../extends\";\r\nimport {KeyNotFoundException} from \"../KeyNotFoundException\";\r\nimport {Action} from \"../../FunctionTypes\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\n// Design Note: Should DictionaryAbstractBase be IDisposable?\r\nexport abstract class DictionaryBase<TKey, TValue>\r\nextends CollectionBase<IKeyValuePair<TKey,TValue>> implements IDictionary<TKey, TValue>\r\n{\r\n\tconstructor(source?:IEnumerableOrArray<IKeyValuePair<TKey,TValue>>)\r\n\t{\r\n\t\tsuper(source);\r\n\t}\r\n\r\n\r\n\t//noinspection JSUnusedLocalSymbols\r\n\tprotected _onValueModified(key:TKey, value:TValue|undefined, old:TValue|undefined):void\r\n\t{\r\n\t}\r\n\r\n\tprotected _addInternal(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\tif(!item)\r\n\t\t\tthrow new ArgumentNullException(\r\n\t\t\t\t'item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.'\r\n\t\t\t);\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value) => this.addByKeyValue(key, value));\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet count = 0;\r\n\r\n\t\tfor(let key of _.keys)\r\n\t\t{\r\n\t\t\tif(_.removeByKey(key)) count++;\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tcontains(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\t// Should never have a null object in the collection.\r\n\t\tif(!item || !this.getCount()) return false;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value) =>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn areEqual(value, v);\r\n\t\t\t});\r\n\r\n\t}\r\n\r\n\tprotected _removeInternal(item:IKeyValuePair<TKey, TValue>|[TKey,TValue]):number\r\n\t{\r\n\t\tif(!item) return 0;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value) =>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn (areEqual(value, v) && this.removeByKey(key))\r\n\t\t\t\t\t? 1 : 0;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// IDictionary<TKey,TValue>\r\n\t/////////////////////////////////////////\r\n\r\n\tprotected abstract getKeys():TKey[];\r\n\r\n\tget keys():TKey[] { return this.getKeys(); }\r\n\r\n\tprotected abstract getValues():TValue[];\r\n\r\n\tget values():TValue[] { return this.getValues(); }\r\n\r\n\r\n\taddByKeyValue(key:TKey, value:TValue):boolean\r\n\t{\r\n\t\tif(value===VOID0)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot add 'undefined' as a value.\");\r\n\r\n\t\tconst _ = this;\r\n\t\tif(_.containsKey(key))\r\n\t\t{\r\n\t\t\tconst ex = new InvalidOperationException(\"Adding a key/value when the key already exists.\");\r\n\t\t\tex.data['key'] = key;\r\n\t\t\tex.data['value'] = value;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\r\n\t\treturn _.setValue(key, value);\r\n\t}\r\n\r\n\tprotected abstract _getEntry(key:TKey):IKeyValuePair<TKey,TValue>|null;\r\n\r\n\tabstract getValue(key:TKey):TValue|undefined;\r\n\r\n\tgetAssuredValue(key:TKey):TValue\r\n\t{\r\n\t\tconst value = this.getValue(key);\r\n\t\tif(value===VOID0)\r\n\t\t\tthrow new KeyNotFoundException(`Key '${key}' not found.`);\r\n\t\treturn value;\r\n\t}\r\n\r\n\ttryGetValue(key:TKey, out:Action<TValue>):boolean\r\n\t{\r\n\t\tconst value = this.getValue(key);\r\n\t\tif(value!==VOID0)\r\n\t\t{\r\n\t\t\tout(value);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected abstract _setValueInternal(key:TKey, value:TValue|undefined):boolean;\r\n\r\n\t/**\r\n\t * Sets the value of an entry.\r\n\t * It's important to know that 'undefined' cannot exist as a value in the dictionary and is used as a flag for removal.\r\n\t * @param key\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\tsetValue(key:TKey, value:TValue|undefined):boolean\r\n\t{\r\n\t\t// setValue shouldn't need to worry about recursion...\r\n\t\tconst _ = this;\r\n\t\t_.assertModifiable();\r\n\r\n\t\tlet changed = false;\r\n\t\tconst old = _.getValue(key); // get the old value here and pass to internal.\r\n\t\tif(!areEqual(value, old) && _._setValueInternal(key, value))\r\n\t\t{\r\n\t\t\tchanged = true;\r\n\t\t\t_._onValueModified(key, value, old)\r\n\t\t}\r\n\r\n\t\t_._signalModification(changed);\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tcontainsKey(key:TKey):boolean\r\n\t{\r\n\t\treturn !!this._getEntry(key);\r\n\t}\r\n\r\n\tcontainsValue(value:TValue):boolean\r\n\t{\r\n\t\tconst e = this.getEnumerator();\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tif(areEqual(e.current, value, true))\r\n\t\t\t{\r\n\t\t\t\te.dispose();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveByKey(key:TKey):boolean\r\n\t{\r\n\t\treturn this.setValue(key, VOID0);\r\n\t}\r\n\r\n\tremoveByValue(value:TValue):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet count = 0;\r\n\t\tfor(let key of _.getKeys())\r\n\t\t{\r\n\t\t\tif(areEqual(_.getValue(key), value, true))\r\n\t\t\t{\r\n\t\t\t\t_.removeByKey(key);\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\timportEntries(pairs:IEnumerableOrArray<KeyValuePair<TKey, TValue>>|IEnumerator<KeyValuePair<TKey, TValue>>|null|undefined):number\r\n\t{\r\n\t\t// Allow piping through to trigger onModified properly.\r\n\t\treturn super.importEntries(<any>pairs);\r\n\t}\r\n\r\n\tprotected _importEntries(pairs:IEnumerableOrArray<KeyValuePair<TKey, TValue>>|IEnumerator<KeyValuePair<TKey, TValue>>|null|undefined):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tif(!pairs) return 0;\r\n\t\tlet changed:number = 0;\r\n\t\tforEach(pairs,\r\n\t\t\tpair => extractKeyValue(pair, (key, value) =>\r\n\t\t\t{\r\n\t\t\t\tif(_._setValueInternal(key, value))\r\n\t\t\t\t\tchanged++;\r\n\t\t\t})\r\n\t\t);\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tlet ver:number, keys:TKey[], len:number, index = 0;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\tver = _._version; // Track the version since getKeys is a copy.\r\n\t\t\t\tkeys = _.getKeys();\r\n\t\t\t\tlen = keys.length;\r\n\t\t\t},\r\n\r\n\t\t\t(yielder) =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\t_.assertVersion(ver);\r\n\r\n\t\t\t\twhile(index<len)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst key = keys[index++], value = _.getValue(key);\r\n\t\t\t\t\tif(value!==VOID0) // Still valid?\r\n\t\t\t\t\t\treturn yielder.yieldReturn({key: key, value: value});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport default DictionaryBase;"]}
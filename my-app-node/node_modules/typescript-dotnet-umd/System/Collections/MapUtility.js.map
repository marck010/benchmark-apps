{"version":3,"sources":["System/Collections/MapUtility.js","System/Collections/MapUtility.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","apply","target","source","result","key","hasOwnProperty","ensure","defaults","copy","merge","a","b","trim","keyMap","wipe","map","depth","_i","_a","Object","keys","length","defineProperty","value"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,WAAYN,IAEpC,SAAUI,EAASF,GAClB,YCAJ,SAAAM,GACCC,EACAC,GAEA,GAAMC,GAAaF,KACnB,KAAI,GAAMG,KAAOF,GAEbA,EAAOG,eAAeD,KAExBD,EAAOC,GAAaF,EAAQE,GAG9B,OAAOD,GASR,QAAAG,GACCL,EACAM,GAEA,GAAMJ,GAAaF,KACnB,KAAI,GAAMG,KAAOG,GAEbA,EAASF,eAAeD,KAASD,EAAOE,eAAeD,KAEzDD,EAAOC,GAAaG,EAAUH,GAGhC,OAAOD,GAQR,QAAAK,GAA0CN,GAEzC,MAAOF,MAAUE,GAUlB,QAAAO,GACCC,EACAC,GAEA,MAAOX,GAAMQ,EAAKE,GAAIC,GAQvB,QAAAC,GAAgDX,EAAkBY,GAEjE,IAAI,GAAMT,KAAOH,GAEZY,EAAOR,eAAeD,UAElBH,GAAOG,GAMjB,QAAAU,GAAqBC,EAAeC,GAEnC,GAFmC,SAAAA,IAAAA,EAAA,GAEhCD,GAAOC,EAET,IAAe,GAAAC,GAAA,EAAAC,EAAAC,OAAOC,KAAKL,GAAZE,EAAAC,EAAAG,OAAAJ,IAAgB,CAA3B,GAAIb,GAAGc,EAAAD,GAEJtB,EAAIoB,EAAIX,SACPW,GAAIX,GACXU,EAAKnB,EAAGqB,EAAQ,IDpFfG,OAAOG,eAAe5B,EAAS,cAAgB6B,OAAO,ICD1D7B,EAAAM,MAAAA,EAqBAN,EAAAY,OAAAA,EAoBAZ,EAAAc,KAAAA,EAYAd,EAAAe,MAAAA,EAYAf,EAAAkB,KAAAA,EAYAlB,EAAAoB,KAAAA","file":"MapUtility.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Takes a target object and applies all source values to it.\n     * @param target\n     * @param source\n     * @returns {any}\n     */\n    function apply(target, source) {\n        var result = target || {};\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                result[key] = source[key];\n            }\n        }\n        return result;\n    }\n    exports.apply = apply;\n    /**\n     * Takes a target object and ensures values exist.\n     * @param target\n     * @param defaults\n     * @returns {any}\n     */\n    function ensure(target, defaults) {\n        var result = target || {};\n        for (var key in defaults) {\n            if (defaults.hasOwnProperty(key) && !result.hasOwnProperty(key)) {\n                result[key] = defaults[key];\n            }\n        }\n        return result;\n    }\n    exports.ensure = ensure;\n    /**\n     * Make a copy of the source object.\n     * @param source\n     * @returns {Object}\n     */\n    function copy(source) {\n        return apply({}, source);\n    }\n    exports.copy = copy;\n    /**\n     * Takes two objects and creates another with the values of both.\n     * B overwrites A.\n     * @param a\n     * @param b\n     */\n    function merge(a, b) {\n        return apply(copy(a), b);\n    }\n    exports.merge = merge;\n    /**\n     * Removes any keys that don't exist on the keyMap.\n     * @param target\n     * @param keyMap\n     */\n    function trim(target, keyMap) {\n        for (var key in target) {\n            if (!keyMap.hasOwnProperty(key)) {\n                delete target[key];\n            }\n        }\n        //return <any>target;\n    }\n    exports.trim = trim;\n    function wipe(map, depth) {\n        if (depth === void 0) { depth = 1; }\n        if (map && depth) {\n            for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {\n                var key = _a[_i];\n                var v = map[key];\n                delete map[key];\n                wipe(v, depth - 1);\n            }\n        }\n    }\n    exports.wipe = wipe;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {IMap} from \"../../IMap\";\r\n\r\n/**\r\n * Takes a target object and applies all source values to it.\r\n * @param target\r\n * @param source\r\n * @returns {any}\r\n */\r\nexport function apply<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tsource:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in source)\r\n\t{\r\n\t\tif(source.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>source)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Takes a target object and ensures values exist.\r\n * @param target\r\n * @param defaults\r\n * @returns {any}\r\n */\r\nexport function ensure<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tdefaults:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in defaults)\r\n\t{\r\n\t\tif(defaults.hasOwnProperty(key) && !result.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>defaults)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Make a copy of the source object.\r\n * @param source\r\n * @returns {Object}\r\n */\r\nexport function copy<T extends IMap<any>>(source:T):T\r\n{\r\n\treturn apply({}, source);\r\n}\r\n\r\n\r\n/**\r\n * Takes two objects and creates another with the values of both.\r\n * B overwrites A.\r\n * @param a\r\n * @param b\r\n */\r\nexport function merge<A extends IMap<any>, B extends IMap<any>>(\r\n\ta:A,\r\n\tb:B):A & B\r\n{\r\n\treturn apply(copy(a), b);\r\n}\r\n\r\n/**\r\n * Removes any keys that don't exist on the keyMap.\r\n * @param target\r\n * @param keyMap\r\n */\r\nexport function trim<TResult extends IMap<any>>(target:IMap<any>, keyMap:TResult):void //Partial<TResult>\r\n{\r\n\tfor(const key in target)\r\n\t{\r\n\t\tif(!keyMap.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tdelete target[key];\r\n\t\t}\r\n\t}\r\n\t//return <any>target;\r\n}\r\n\r\nexport function wipe(map:IMap<any>, depth:number = 1):void\r\n{\r\n\tif(map && depth)\r\n\t{\r\n\t\tfor(let key of Object.keys(map))\r\n\t\t{\r\n\t\t\tconst v = map[key];\r\n\t\t\tdelete map[key];\r\n\t\t\twipe(v, depth - 1);\r\n\t\t}\r\n\t}\r\n}"]}
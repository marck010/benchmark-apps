{"version":3,"sources":["System/TypeValidator.js","System/TypeValidator.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","areInvalid","d","Compare_1","areEqual","memberType","TypeInfoHelper","contains","Object","defineProperty","value","Types_1","extends_1","__extends","_super","call","this","self","_value","prototype","descriptor","Function","isFunction","isObject","Array","isArray","String","isString","Number","isNumber","Boolean","isBoolean","type","isPrimitive","Type","isArrayLike","max","Math","min","length","i","targetKeys","keys","dKeys","_i","dKeys_1","key","indexOf","_a","dKeys_2","TypeInfo","TypeValidator","_typeDescriptor","freeze","isSubsetOf","o"],"mappings":";;;;CAkBA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,UAAW,YAAa,cAAeN,IAE1E,SAAUI,EAASF,GAClB,YC+EJ,SAAAM,GAAoBL,EAAOM,GAE1B,IAAIC,EAAAC,SAASR,EAAGM,GAChB,CACC,GAAIG,GAAa,GAAIC,GAAeV,EACpC,KAAIS,EAAWE,SAASL,GACvB,OAAO,EAET,OAAO,EDtFJM,OAAOC,eAAed,EAAS,cAAgBe,OAAO,GCT1D,IAAAC,GAAAd,EAAA,WACAM,EAAAN,EAAA,aACAe,EAAAf,EAAA,cAEMgB,EAAYD,EAAAA,WAGlBN,EAAA,SAAAQ,GAKC,QAAAR,GAAYI,GDMD,MCJVI,GAAAC,KAAAC,KAAMN,EAAO,SAAAO,GAAM,MAAAA,GAAKC,OAASR,KAAMM,KAuEzC,MA9EoCH,GAAAP,EAAAQ,GAUnCR,EAAAa,UAAAZ,SAAA,SAAsBa,GAGrB,GAAIV,GAAQM,KAAKE,MAEjB,IAAGR,IAAQU,EACV,OAAO,CAER,QAAOA,GAEN,IAAKC,UACJ,MAAOL,MAAKM,UACb,KAAKd,QACJ,MAAOQ,MAAKO,QACb,KAAKC,OACJ,MAAOR,MAAKS,OACb,KAAKC,QACJ,MAAOV,MAAKW,QACb,KAAKC,QACJ,MAAOZ,MAAKa,QACb,KAAKC,SACJ,MAAOd,MAAKe,UAGd,GAAGf,KAAKgB,YAAcZ,IAAcJ,KAAKiB,cAAgB9B,EAAAC,SAASM,EAAOU,GACxE,OAAO,CAGR,IAAGJ,KAAKS,SAAWd,EAAAuB,KAAKC,YAAYf,GACpC,CAGC,IAAI,GAFAgB,GAAMC,KAAKC,IAAIlB,EAAWmB,OAAQ7B,EAAM6B,QAEpCC,EAAI,EAAGA,EAAEJ,EAAKI,IAErB,GAAGvC,EAAWS,EAAM8B,GAAIpB,EAAWoB,IAClC,OAAO,CAGT,QAAO,EAGR,GAAGxB,KAAKO,SACR,CACC,GAAIkB,GAAajC,OAAOkC,KAAKhC,GACzBiC,EAAQnC,OAAOkC,KAAKtB,EAGxB,IAAGuB,EAAMJ,OAAOE,EAAWF,OAC1B,OAAO,CAGR,KAAe,GAAAK,GAAA,EAAAC,EAAAF,EAAAC,EAAAC,EAAAN,OAAAK,IAAK,CAAhB,GAAIE,GAAGD,EAAAD,EAEV,IAAGH,EAAWM,QAAQD,OACrB,OAAO,EAIT,IAAe,GAAAE,GAAA,EAAAC,EAAAN,EAAAK,EAAAC,EAAAV,OAAAS,IAAK,CAAhB,GAAIF,GAAGG,EAAAD,EAEV,IAAG/C,EAAWS,EAAMoC,GAAM1B,EAAW0B,IACpC,OAAO,GAIV,OAAO,GAGTxC,GA9EoCK,EAAAuC,SAAvBvD,GAAAW,eAAAA,CA2Fb,IAAA6C,GAAA,WAEC,QAAAA,GAA6BC,GAAApC,KAAAoC,gBAAAA,EAE5B5C,OAAO6C,OAAOrC,MAQhB,MALCmC,GAAAhC,UAAAmC,WAAA,SAAWC,GAEV,MAAO,IAAKjD,GAAeiD,GACzBhD,SAASS,KAAKoC,kBAElBD,IAZaxD,GAAAwD,cAAAA,EAcbxD,EAAAA,WAAewD","file":"TypeValidator.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n */\n/**\n * A descriptor is simply a JSON tree that either has an actual value or a type that identifies what the expect type should be at that leaf in the tree.\n *\n * var descriptor = {\n *      a : Object,\n *      b : String,\n *      c : {\n *          d : true ,\n *          e : Array,\n *          f : []\n *      },\n *      g : \"literal\"\n * }\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./Types\", \"./Compare\", \"../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Types_1 = require(\"./Types\");\n    var Compare_1 = require(\"./Compare\");\n    var extends_1 = require(\"../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var TypeInfoHelper = /** @class */ (function (_super) {\n        __extends(TypeInfoHelper, _super);\n        function TypeInfoHelper(value) {\n            return _super.call(this, value, function (self) { return self._value = value; }) || this;\n        }\n        TypeInfoHelper.prototype.contains = function (descriptor) {\n            var value = this._value;\n            if (value === descriptor)\n                return true;\n            switch (descriptor) {\n                case Function:\n                    return this.isFunction;\n                case Object:\n                    return this.isObject;\n                case Array:\n                    return this.isArray;\n                case String:\n                    return this.isString;\n                case Number:\n                    return this.isNumber;\n                case Boolean:\n                    return this.isBoolean;\n            }\n            if (this.type != typeof descriptor || this.isPrimitive && !Compare_1.areEqual(value, descriptor))\n                return false;\n            // Check array contents and confirm intersections.\n            if (this.isArray && Types_1.Type.isArrayLike(descriptor)) {\n                var max = Math.min(descriptor.length, value.length);\n                for (var i = 0; i < max; i++) {\n                    if (areInvalid(value[i], descriptor[i]))\n                        return false;\n                }\n                return true;\n            }\n            if (this.isObject) {\n                var targetKeys = Object.keys(value);\n                var dKeys = Object.keys(descriptor);\n                // Quick check...\n                if (dKeys.length > targetKeys.length)\n                    return false;\n                // Quick check #2...\n                for (var _i = 0, dKeys_1 = dKeys; _i < dKeys_1.length; _i++) {\n                    var key = dKeys_1[_i];\n                    if (targetKeys.indexOf(key) == -1)\n                        return false;\n                }\n                // Final pass with recursive...\n                for (var _a = 0, dKeys_2 = dKeys; _a < dKeys_2.length; _a++) {\n                    var key = dKeys_2[_a];\n                    if (areInvalid(value[key], descriptor[key]))\n                        return false;\n                }\n            }\n            return true;\n        };\n        return TypeInfoHelper;\n    }(Types_1.TypeInfo));\n    exports.TypeInfoHelper = TypeInfoHelper;\n    function areInvalid(v, d) {\n        if (!Compare_1.areEqual(v, d)) {\n            var memberType = new TypeInfoHelper(v);\n            if (!memberType.contains(d))\n                return true;\n        }\n        return false;\n    }\n    var TypeValidator = /** @class */ (function () {\n        function TypeValidator(_typeDescriptor) {\n            this._typeDescriptor = _typeDescriptor;\n            Object.freeze(this);\n        }\n        TypeValidator.prototype.isSubsetOf = function (o) {\n            return (new TypeInfoHelper(o))\n                .contains(this._typeDescriptor);\n        };\n        return TypeValidator;\n    }());\n    exports.TypeValidator = TypeValidator;\n    exports.default = TypeValidator;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n/**\r\n * A descriptor is simply a JSON tree that either has an actual value or a type that identifies what the expect type should be at that leaf in the tree.\r\n *\r\n * var descriptor = {\r\n *      a : Object,\r\n *      b : String,\r\n *      c : {\r\n *          d : true ,\r\n *          e : Array,\r\n *          f : []\r\n *      },\r\n *      g : \"literal\"\r\n * }\r\n */\r\n\r\nimport {Type, TypeInfo} from \"./Types\";\r\nimport {areEqual} from \"./Compare\";\r\nimport __extendsImport from \"../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\nexport class TypeInfoHelper extends TypeInfo\r\n{\r\n\r\n\tprivate _value:any;\r\n\r\n\tconstructor(value:any)\r\n\t{\r\n\t\tsuper(value, self=>self._value = value);\r\n\t}\r\n\r\n\tcontains<TDescriptor>(descriptor:any):this is TDescriptor\r\n\t{\r\n\r\n\t\tlet value = this._value;\r\n\r\n\t\tif(value===descriptor)\r\n\t\t\treturn true;\r\n\r\n\t\tswitch(descriptor)\r\n\t\t{\r\n\t\t\tcase Function:\r\n\t\t\t\treturn this.isFunction;\r\n\t\t\tcase Object:\r\n\t\t\t\treturn this.isObject;\r\n\t\t\tcase Array:\r\n\t\t\t\treturn this.isArray;\r\n\t\t\tcase String:\r\n\t\t\t\treturn this.isString;\r\n\t\t\tcase Number:\r\n\t\t\t\treturn this.isNumber;\r\n\t\t\tcase Boolean:\r\n\t\t\t\treturn this.isBoolean;\r\n\t\t}\r\n\r\n\t\tif(this.type!= typeof descriptor || this.isPrimitive && !areEqual(value, descriptor))\r\n\t\t\treturn false;\r\n\r\n\t\t// Check array contents and confirm intersections.\r\n\t\tif(this.isArray && Type.isArrayLike(descriptor))\r\n\t\t{\r\n\t\t\tlet max = Math.min(descriptor.length, value.length);\r\n\r\n\t\t\tfor(let i = 0; i<max; i++)\r\n\t\t\t{\r\n\t\t\t\tif(areInvalid(value[i], descriptor[i]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif(this.isObject)\r\n\t\t{\r\n\t\t\tlet targetKeys = Object.keys(value);\r\n\t\t\tlet dKeys = Object.keys(descriptor);\r\n\r\n\t\t\t// Quick check...\r\n\t\t\tif(dKeys.length>targetKeys.length)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// Quick check #2...\r\n\t\t\tfor(let key of dKeys)\r\n\t\t\t{\r\n\t\t\t\tif(targetKeys.indexOf(key)== -1)\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Final pass with recursive...\r\n\t\t\tfor(let key of dKeys)\r\n\t\t\t{\r\n\t\t\t\tif(areInvalid(value[key], descriptor[key]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\nfunction areInvalid(v:any, d:any)\r\n{\r\n\tif(!areEqual(v, d))\r\n\t{\r\n\t\tlet memberType = new TypeInfoHelper(v);\r\n\t\tif(!memberType.contains(d))\r\n\t\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nexport class TypeValidator<T>\r\n{\r\n\tconstructor(private readonly _typeDescriptor:any)\r\n\t{\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\tisSubsetOf(o:any):o is T\r\n\t{\r\n\t\treturn (new TypeInfoHelper(o))\r\n\t\t\t.contains(this._typeDescriptor);\r\n\t}\r\n}\r\n\r\nexport default TypeValidator;\r\n\r\n"]}
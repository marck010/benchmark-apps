{"version":3,"sources":["System/Types.js","System/Types.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Type","target","TypeInfo","Object","defineProperty","value","VOID0","_BOOLEAN","_NUMBER","_STRING","_SYMBOL","_OBJECT","_UNDEFINED","_FUNCTION","LENGTH","typeInfoRegistry","onBeforeFreeze","this","isBoolean","isNumber","isString","isTrueNaN","isObject","isFunction","isUndefined","isNull","isPrimitive","isSymbol","type","isNaN","isFinite","isValidNumber","isNullOrUndefined","isArray","freeze","prototype","member","name","t","getFor","info","is","as","ignoreNaN","allowUndefined","isPrimitiveOrSymbol","isPropertyKey","allowNull","numberOrNaN","NaN","of","hasMember","instance","property","ignoreUndefined","hasMemberOfType","hasMethod","isArrayLike","Array","BOOLEAN","NUMBER","STRING","OBJECT","SYMBOL","UNDEFINED","FUNCTION"],"mappings":"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","file":"Types.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var VOID0 = void (0), _BOOLEAN = typeof true, _NUMBER = typeof 0, _STRING = typeof \"\", _SYMBOL = \"symbol\", _OBJECT = typeof {}, _UNDEFINED = typeof VOID0, _FUNCTION = typeof function () { }, LENGTH = \"length\";\n    // Only used for primitives.\n    var typeInfoRegistry = {};\n    /**\n     * Exposes easy access to type information including inquiring about members.\n     */\n    var TypeInfo = /** @class */ (function () {\n        function TypeInfo(target, onBeforeFreeze) {\n            this.isBoolean = false;\n            this.isNumber = false;\n            this.isString = false;\n            this.isTrueNaN = false;\n            this.isObject = false;\n            this.isFunction = false;\n            this.isUndefined = false;\n            this.isNull = false;\n            this.isPrimitive = false;\n            this.isSymbol = false;\n            switch (this.type = typeof target) {\n                case _BOOLEAN:\n                    this.isBoolean = true;\n                    this.isPrimitive = true;\n                    break;\n                case _NUMBER:\n                    this.isNumber = true;\n                    this.isTrueNaN = isNaN(target);\n                    this.isFinite = isFinite(target);\n                    this.isValidNumber = !this.isTrueNaN;\n                    this.isPrimitive = true;\n                    break;\n                case _STRING:\n                    this.isString = true;\n                    this.isPrimitive = true;\n                    break;\n                case _SYMBOL:\n                    this.isSymbol = true;\n                    break;\n                case _OBJECT:\n                    this.target = target;\n                    if (target === null) {\n                        this.isNull = true;\n                        this.isNullOrUndefined = true;\n                        this.isPrimitive = true;\n                    }\n                    else {\n                        this.isArray = (target) instanceof (Array);\n                        this.isObject = true;\n                    }\n                    break;\n                case _FUNCTION:\n                    this.target = target;\n                    this.isFunction = true;\n                    break;\n                case _UNDEFINED:\n                    this.isUndefined = true;\n                    this.isNullOrUndefined = true;\n                    this.isPrimitive = true;\n                    break;\n                default:\n                    throw \"Fatal type failure.  Unknown type: \" + this.type;\n            }\n            if (onBeforeFreeze)\n                onBeforeFreeze(this);\n            Object.freeze(this);\n        }\n        /**\n         * Returns a TypeInfo for any member or non-member,\n         * where non-members are of type undefined.\n         * @param name\n         * @returns {TypeInfo}\n         */\n        TypeInfo.prototype.member = function (name) {\n            var t = this.target;\n            return TypeInfo.getFor(t && (name) in (t)\n                ? t[name]\n                : VOID0);\n        };\n        /**\n         * Returns a TypeInfo for any target object.\n         * If the target object is of a primitive type, it returns the TypeInfo instance assigned to that type.\n         * @param target\n         * @returns {TypeInfo}\n         */\n        TypeInfo.getFor = function (target) {\n            var type = typeof target;\n            switch (type) {\n                case _OBJECT:\n                case _FUNCTION:\n                    return new TypeInfo(target);\n            }\n            var info = typeInfoRegistry[type];\n            if (!info)\n                typeInfoRegistry[type] = info = new TypeInfo(target);\n            return info;\n        };\n        /**\n         * Returns true if the target matches the type (instanceof).\n         * @param type\n         * @returns {boolean}\n         */\n        TypeInfo.prototype.is = function (type) {\n            return this.target instanceof type;\n        };\n        /**\n         * Returns null if the target does not match the type (instanceof).\n         * Otherwise returns the target as the type.\n         * @param type\n         * @returns {T|null}\n         */\n        TypeInfo.prototype.as = function (type) {\n            return this.target instanceof type ? this.target : null;\n        };\n        return TypeInfo;\n    }());\n    exports.TypeInfo = TypeInfo;\n    function Type(target) {\n        return new TypeInfo(target);\n    }\n    exports.Type = Type;\n    (function (Type) {\n        /**\n         * typeof true\n         * @type {string}\n         */\n        Type.BOOLEAN = _BOOLEAN;\n        /**\n         * typeof 0\n         * @type {string}\n         */\n        Type.NUMBER = _NUMBER;\n        /**\n         * typeof \"\"\n         * @type {string}\n         */\n        Type.STRING = _STRING;\n        /**\n         * typeof {}\n         * @type {string}\n         */\n        Type.OBJECT = _OBJECT;\n        /**\n         * typeof Symbol\n         * @type {string}\n         */\n        Type.SYMBOL = _SYMBOL;\n        /**\n         * typeof undefined\n         * @type {string}\n         */\n        Type.UNDEFINED = _UNDEFINED;\n        /**\n         * typeof function\n         * @type {string}\n         */\n        Type.FUNCTION = _FUNCTION;\n        /**\n         * Returns true if the target matches the type (instanceof).\n         * @param target\n         * @param type\n         * @returns {T|null}\n         */\n        function is(target, type) {\n            return target instanceof type;\n        }\n        Type.is = is;\n        /**\n         * Returns null if the target does not match the type (instanceof).\n         * Otherwise returns the target as the type.\n         * @param target\n         * @param type\n         * @returns {T|null}\n         */\n        function as(target, type) {\n            return target instanceof type ? target : null;\n        }\n        Type.as = as;\n        /**\n         * Returns true if the value parameter is null or undefined.\n         * @param value\n         * @returns {boolean}\n         */\n        function isNullOrUndefined(value) {\n            return value == null;\n        }\n        Type.isNullOrUndefined = isNullOrUndefined;\n        /**\n         * Returns true if the value parameter is a boolean.\n         * @param value\n         * @returns {boolean}\n         */\n        function isBoolean(value) {\n            return typeof value === _BOOLEAN;\n        }\n        Type.isBoolean = isBoolean;\n        /**\n         * Returns true if the value parameter is a number.\n         * @param value\n         * @param ignoreNaN Default is false. When true, NaN is not considered a number and will return false.\n         * @returns {boolean}\n         */\n        function isNumber(value, ignoreNaN) {\n            if (ignoreNaN === void 0) { ignoreNaN = false; }\n            return typeof value === _NUMBER && (!ignoreNaN || !isNaN(value));\n        }\n        Type.isNumber = isNumber;\n        /**\n         * Returns true if is a number and is NaN.\n         * @param value\n         * @returns {boolean}\n         */\n        function isTrueNaN(value) {\n            return typeof value === _NUMBER && isNaN(value);\n        }\n        Type.isTrueNaN = isTrueNaN;\n        /**\n         * Returns true if the value parameter is a string.\n         * @param value\n         * @returns {boolean}\n         */\n        function isString(value) {\n            return typeof value === _STRING;\n        }\n        Type.isString = isString;\n        /**\n         * Returns true if the value is a boolean, string, number, null, or undefined.\n         * @param value\n         * @param allowUndefined if set to true will return true if the value is undefined.\n         * @returns {boolean}\n         */\n        function isPrimitive(value, allowUndefined) {\n            if (allowUndefined === void 0) { allowUndefined = false; }\n            var t = typeof value;\n            switch (t) {\n                case _BOOLEAN:\n                case _STRING:\n                case _NUMBER:\n                    return true;\n                case _UNDEFINED:\n                    return allowUndefined;\n                case _OBJECT:\n                    return value === null;\n            }\n            return false;\n        }\n        Type.isPrimitive = isPrimitive;\n        /**\n         * For detecting if the value can be used as a key.\n         * @param value\n         * @param allowUndefined\n         * @returns {boolean|boolean}\n         */\n        function isPrimitiveOrSymbol(value, allowUndefined) {\n            if (allowUndefined === void 0) { allowUndefined = false; }\n            return typeof value === _SYMBOL ? true : isPrimitive(value, allowUndefined);\n        }\n        Type.isPrimitiveOrSymbol = isPrimitiveOrSymbol;\n        /**\n         * Returns true if the value is a string, number, or symbol.\n         * @param value\n         * @returns {boolean}\n         */\n        function isPropertyKey(value) {\n            var t = typeof value;\n            switch (t) {\n                case _STRING:\n                case _NUMBER:\n                case _SYMBOL:\n                    return true;\n            }\n            return false;\n        }\n        Type.isPropertyKey = isPropertyKey;\n        /**\n         * Returns true if the value parameter is a function.\n         * @param value\n         * @returns {boolean}\n         */\n        function isFunction(value) {\n            return typeof value === _FUNCTION;\n        }\n        Type.isFunction = isFunction;\n        /**\n         * Returns true if the value parameter is an object.\n         * @param value\n         * @param allowNull If false (default) null is not considered an object.\n         * @returns {boolean}\n         */\n        function isObject(value, allowNull) {\n            if (allowNull === void 0) { allowNull = false; }\n            return typeof value === _OBJECT && (allowNull || value !== null);\n        }\n        Type.isObject = isObject;\n        /**\n         * Guarantees a number value or NaN instead.\n         * @param value\n         * @returns {number}\n         */\n        function numberOrNaN(value) {\n            return isNaN(value) ? NaN : value;\n        }\n        Type.numberOrNaN = numberOrNaN;\n        /**\n         * Returns a TypeInfo object for the target.\n         * @param target\n         * @returns {TypeInfo}\n         */\n        function of(target) {\n            return TypeInfo.getFor(target);\n        }\n        Type.of = of;\n        /**\n         * Will detect if a member exists (using 'in').\n         * Returns true if a property or method exists on the object or its prototype.\n         * @param instance\n         * @param property Name of the member.\n         * @param ignoreUndefined When ignoreUndefined is true, if the member exists but is undefined, it will return false.\n         * @returns {boolean}\n         */\n        function hasMember(instance, property, ignoreUndefined) {\n            if (ignoreUndefined === void 0) { ignoreUndefined = true; }\n            return instance && !isPrimitive(instance) && (property) in (instance) && (ignoreUndefined || instance[property] !== VOID0);\n        }\n        Type.hasMember = hasMember;\n        /**\n         * Returns true if the member matches the type.\n         * @param instance\n         * @param property\n         * @param type\n         * @returns {boolean}\n         */\n        function hasMemberOfType(instance, property, type) {\n            return hasMember(instance, property) && typeof (instance[property]) === type;\n        }\n        Type.hasMemberOfType = hasMemberOfType;\n        function hasMethod(instance, property) {\n            return hasMemberOfType(instance, property, _FUNCTION);\n        }\n        Type.hasMethod = hasMethod;\n        function isArrayLike(instance) {\n            /*\n             * NOTE:\n             *\n             * Functions:\n             * Enumerating a function although it has a .length property will yield nothing or unexpected results.\n             * Effectively, a function is not like an array.\n             *\n             * Strings:\n             * Behave like arrays but don't have the same exact methods.\n             */\n            return instance instanceof Array\n                || Type.isString(instance)\n                || !Type.isFunction(instance) && hasMember(instance, LENGTH);\n        }\n        Type.isArrayLike = isArrayLike;\n    })(Type = exports.Type || (exports.Type = {}));\n    Object.freeze(Type);\n    exports.default = Type;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Primitive} from \"./Primitive\";\r\nimport {TypeValue} from \"./TypeValue\";\r\nimport {ArrayLikeWritable} from \"./Collections/Array/ArrayLikeWritable\";\r\n\r\nconst\r\n\tVOID0      = <undefined>void(0),\r\n\t_BOOLEAN   = <TypeValue.Boolean>typeof true,\r\n\t_NUMBER    = <TypeValue.Number>typeof 0,\r\n\t_STRING    = <TypeValue.String>typeof \"\",\r\n\t_SYMBOL    = <TypeValue.Symbol>\"symbol\",\r\n\t_OBJECT    = <TypeValue.Object>typeof {},\r\n\t_UNDEFINED = <TypeValue.Undefined>typeof VOID0,\r\n\t_FUNCTION  = <TypeValue.Function>typeof function() {},\r\n\tLENGTH     = <string>\"length\";\r\n\r\n// Only used for primitives.\r\nconst typeInfoRegistry:{[key:string]:TypeInfo} = {};\r\n\r\n/**\r\n * Exposes easy access to type information including inquiring about members.\r\n */\r\nexport class TypeInfo\r\n{\r\n\t// Not retained for primitives. Since they have no members.\r\n\tprotected readonly target:any;\r\n\r\n\treadonly type:string;\r\n\r\n\treadonly isBoolean:boolean;\r\n\treadonly isNumber:boolean;\r\n\treadonly isFinite:boolean;\r\n\treadonly isValidNumber:boolean;\r\n\treadonly isString:boolean;\r\n\treadonly isTrueNaN:boolean;\r\n\treadonly isObject:boolean;\r\n\treadonly isArray:boolean;\r\n\treadonly isFunction:boolean;\r\n\treadonly isUndefined:boolean;\r\n\treadonly isNull:boolean;\r\n\treadonly isNullOrUndefined:boolean;\r\n\treadonly isPrimitive:boolean;\r\n\treadonly isSymbol:boolean;\r\n\r\n\tconstructor(target:any, onBeforeFreeze?:(instance:any)=>void)\r\n\t{\r\n\t\tthis.isBoolean = false;\r\n\t\tthis.isNumber = false;\r\n\t\tthis.isString = false;\r\n\t\tthis.isTrueNaN = false;\r\n\t\tthis.isObject = false;\r\n\t\tthis.isFunction = false;\r\n\t\tthis.isUndefined = false;\r\n\t\tthis.isNull = false;\r\n\t\tthis.isPrimitive = false;\r\n\t\tthis.isSymbol = false;\r\n\r\n\t\tswitch(this.type = typeof target)\r\n\t\t{\r\n\t\t\tcase _BOOLEAN:\r\n\t\t\t\tthis.isBoolean = true;\r\n\t\t\t\tthis.isPrimitive = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase _NUMBER:\r\n\t\t\t\tthis.isNumber = true;\r\n\t\t\t\tthis.isTrueNaN = isNaN(target);\r\n\t\t\t\tthis.isFinite = isFinite(target);\r\n\t\t\t\tthis.isValidNumber = !this.isTrueNaN;\r\n\t\t\t\tthis.isPrimitive = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase _STRING:\r\n\t\t\t\tthis.isString = true;\r\n\t\t\t\tthis.isPrimitive = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase _SYMBOL:\r\n\t\t\t\tthis.isSymbol = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase _OBJECT:\r\n\t\t\t\tthis.target = target;\r\n\t\t\t\tif(target===null)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.isNull = true;\r\n\t\t\t\t\tthis.isNullOrUndefined = true;\r\n\t\t\t\t\tthis.isPrimitive = true;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.isArray = (target) instanceof (Array);\r\n\t\t\t\t\tthis.isObject = true;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase _FUNCTION:\r\n\t\t\t\tthis.target = target;\r\n\t\t\t\tthis.isFunction = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase _UNDEFINED:\r\n\t\t\t\tthis.isUndefined = true;\r\n\t\t\t\tthis.isNullOrUndefined = true;\r\n\t\t\t\tthis.isPrimitive = true;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow \"Fatal type failure.  Unknown type: \" + this.type;\r\n\t\t}\r\n\r\n\t\tif(onBeforeFreeze) onBeforeFreeze(this);\r\n\t\tObject.freeze(this);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a TypeInfo for any member or non-member,\r\n\t * where non-members are of type undefined.\r\n\t * @param name\r\n\t * @returns {TypeInfo}\r\n\t */\r\n\tmember(name:string|number|symbol):TypeInfo\r\n\t{\r\n\t\tconst t = this.target;\r\n\t\treturn TypeInfo.getFor(\r\n\t\t\tt && (name) in (t)\r\n\t\t\t\t? t[name]\r\n\t\t\t\t: VOID0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a TypeInfo for any target object.\r\n\t * If the target object is of a primitive type, it returns the TypeInfo instance assigned to that type.\r\n\t * @param target\r\n\t * @returns {TypeInfo}\r\n\t */\r\n\tstatic getFor(target:any):TypeInfo\r\n\t{\r\n\t\tconst type:string = typeof target;\r\n\t\tswitch(type)\r\n\t\t{\r\n\t\t\tcase _OBJECT:\r\n\t\t\tcase _FUNCTION:\r\n\t\t\t\treturn new TypeInfo(target);\r\n\t\t}\r\n\t\tlet info = typeInfoRegistry[type];\r\n\t\tif(!info) typeInfoRegistry[type] = info = new TypeInfo(target);\r\n\t\treturn info;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the target matches the type (instanceof).\r\n\t * @param type\r\n\t * @returns {boolean}\r\n\t */\r\n\tis<T>(type:{new (...params:any[]):T}):boolean\r\n\t{\r\n\t\treturn this.target instanceof type;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns null if the target does not match the type (instanceof).\r\n\t * Otherwise returns the target as the type.\r\n\t * @param type\r\n\t * @returns {T|null}\r\n\t */\r\n\tas<T>(type:{new (...params:any[]):T}):T|null\r\n\t{\r\n\t\treturn this.target instanceof type ? this.target : null\r\n\t}\r\n\r\n}\r\n\r\nexport function Type(target:any):TypeInfo\r\n{\r\n\treturn new TypeInfo(target);\r\n}\r\n\r\nexport module Type\r\n{\r\n\t/**\r\n\t * typeof true\r\n\t * @type {string}\r\n\t */\r\n\texport const BOOLEAN:TypeValue.Boolean = _BOOLEAN;\r\n\r\n\t/**\r\n\t * typeof 0\r\n\t * @type {string}\r\n\t */\r\n\texport const NUMBER:TypeValue.Number = _NUMBER;\r\n\r\n\t/**\r\n\t * typeof \"\"\r\n\t * @type {string}\r\n\t */\r\n\texport const STRING:TypeValue.String = _STRING;\r\n\r\n\t/**\r\n\t * typeof {}\r\n\t * @type {string}\r\n\t */\r\n\texport const OBJECT:TypeValue.Object = _OBJECT;\r\n\r\n\r\n\t/**\r\n\t * typeof Symbol\r\n\t * @type {string}\r\n\t */\r\n\texport const SYMBOL:TypeValue.Symbol = _SYMBOL;\r\n\r\n\t/**\r\n\t * typeof undefined\r\n\t * @type {string}\r\n\t */\r\n\texport const UNDEFINED:TypeValue.Undefined = _UNDEFINED;\r\n\r\n\t/**\r\n\t * typeof function\r\n\t * @type {string}\r\n\t */\r\n\texport const FUNCTION:TypeValue.Function = _FUNCTION;\r\n\r\n\t/**\r\n\t * Returns true if the target matches the type (instanceof).\r\n\t * @param target\r\n\t * @param type\r\n\t * @returns {T|null}\r\n\t */\r\n\texport function is<T>(target:Object, type:{new (...params:any[]):T}):target is T\r\n\t{\r\n\t\treturn target instanceof type;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns null if the target does not match the type (instanceof).\r\n\t * Otherwise returns the target as the type.\r\n\t * @param target\r\n\t * @param type\r\n\t * @returns {T|null}\r\n\t */\r\n\texport function as<T>(target:Object, type:{new (...params:any[]):T}):T|null\r\n\t{\r\n\t\treturn target instanceof type ? target : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is null or undefined.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isNullOrUndefined(value:any):value is null|undefined\r\n\t{\r\n\t\treturn value==null;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is a boolean.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isBoolean(value:any):value is boolean\r\n\t{\r\n\t\treturn typeof value===_BOOLEAN;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is a number.\r\n\t * @param value\r\n\t * @param ignoreNaN Default is false. When true, NaN is not considered a number and will return false.\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isNumber(value:any, ignoreNaN:boolean = false):value is number\r\n\t{\r\n\t\treturn typeof value===_NUMBER && (!ignoreNaN || !isNaN(value));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if is a number and is NaN.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isTrueNaN(value:any):value is number\r\n\t{\r\n\t\treturn typeof value===_NUMBER && isNaN(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is a string.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isString(value:any):value is string\r\n\t{\r\n\t\treturn typeof value===_STRING;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value is a boolean, string, number, null, or undefined.\r\n\t * @param value\r\n\t * @param allowUndefined if set to true will return true if the value is undefined.\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isPrimitive(value:any, allowUndefined:boolean = false):value is Primitive\r\n\t{\r\n\t\tconst t = typeof value;\r\n\t\tswitch(t)\r\n\t\t{\r\n\t\t\tcase _BOOLEAN:\r\n\t\t\tcase _STRING:\r\n\t\t\tcase _NUMBER:\r\n\t\t\t\treturn true;\r\n\t\t\tcase _UNDEFINED:\r\n\t\t\t\treturn allowUndefined;\r\n\t\t\tcase _OBJECT:\r\n\t\t\t\treturn value===null;\r\n\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * For detecting if the value can be used as a key.\r\n\t * @param value\r\n\t * @param allowUndefined\r\n\t * @returns {boolean|boolean}\r\n\t */\r\n\texport function isPrimitiveOrSymbol(\r\n\t\tvalue:any,\r\n\t\tallowUndefined:boolean = false):value is Primitive|symbol\r\n\t{\r\n\t\treturn typeof value===_SYMBOL ? true : isPrimitive(value, allowUndefined);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value is a string, number, or symbol.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isPropertyKey(value:any):value is string|number|symbol\r\n\t{\r\n\t\tconst t = typeof value;\r\n\t\tswitch(t)\r\n\t\t{\r\n\t\t\tcase _STRING:\r\n\t\t\tcase _NUMBER:\r\n\t\t\tcase _SYMBOL:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is a function.\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isFunction(value:any):value is Function\r\n\t{\r\n\t\treturn typeof value===_FUNCTION;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value parameter is an object.\r\n\t * @param value\r\n\t * @param allowNull If false (default) null is not considered an object.\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function isObject(value:any, allowNull:boolean = false):boolean\r\n\t{\r\n\t\treturn typeof value===_OBJECT && (allowNull || value!==null);\r\n\t}\r\n\r\n\t/**\r\n\t * Guarantees a number value or NaN instead.\r\n\t * @param value\r\n\t * @returns {number}\r\n\t */\r\n\texport function numberOrNaN(value:any):number\r\n\t{\r\n\t\treturn isNaN(value) ? NaN : value;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a TypeInfo object for the target.\r\n\t * @param target\r\n\t * @returns {TypeInfo}\r\n\t */\r\n\texport function of(target:any):TypeInfo\r\n\t{\r\n\t\treturn TypeInfo.getFor(target);\r\n\t}\r\n\r\n\t/**\r\n\t * Will detect if a member exists (using 'in').\r\n\t * Returns true if a property or method exists on the object or its prototype.\r\n\t * @param instance\r\n\t * @param property Name of the member.\r\n\t * @param ignoreUndefined When ignoreUndefined is true, if the member exists but is undefined, it will return false.\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function hasMember(instance:any, property:string, ignoreUndefined:boolean = true):boolean\r\n\t{\r\n\t\treturn instance && !isPrimitive(instance) && (property) in (instance) && (ignoreUndefined || instance[property]!==VOID0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the member matches the type.\r\n\t * @param instance\r\n\t * @param property\r\n\t * @param type\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function hasMemberOfType<T>(\r\n\t\tinstance:any, property:string,\r\n\t\ttype:TypeValue.Any):instance is T\r\n\t{\r\n\t\treturn hasMember(instance, property) && typeof(instance[property])===type;\r\n\t}\r\n\r\n\texport function hasMethod<T>(instance:any, property:string):instance is T\r\n\t{\r\n\t\treturn hasMemberOfType<T>(instance, property, _FUNCTION);\r\n\t}\r\n\r\n\texport function isArrayLike<T>(instance:any):instance is ArrayLikeWritable<T>\r\n\t{\r\n\t\t/*\r\n\t\t * NOTE:\r\n\t\t *\r\n\t\t * Functions:\r\n\t\t * Enumerating a function although it has a .length property will yield nothing or unexpected results.\r\n\t\t * Effectively, a function is not like an array.\r\n\t\t *\r\n\t\t * Strings:\r\n\t\t * Behave like arrays but don't have the same exact methods.\r\n\t\t */\r\n\t\treturn instance instanceof Array\r\n\t\t\t|| Type.isString(instance)\r\n\t\t\t|| !Type.isFunction(instance) && hasMember(instance, LENGTH);\r\n\t}\r\n}\r\n\r\nObject.freeze(Type);\r\n\r\nexport default Type;\r\n\r\n"]}
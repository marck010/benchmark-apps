{"version":3,"sources":["System/Compare.js","System/Compare.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","areEqual","a","b","strict","isTrueNaN","compare","Types_1","Type","hasMember","COMPARE_TO","compareTo","VOID0","NaN","areEquivalent","nullEquivalency","extraDepth","isObject","Object","keys","length","aKeys","bKeys","len","sort","i","key","_i","aKeys_1","defineProperty","value"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,WAAYN,IAE/C,SAAUI,EAASF,GAClB,YCOJ,SAAAM,GAAyBC,EAAOC,EAAOC,GAEtC,MAFsC,UAAAA,IAAAA,GAAA,GAE/BF,IAAIC,IACNC,GAAUF,GAAGC,GACdE,EAAUH,IAAMG,EAAUF,GAY/B,QAAAG,GAAwBJ,EAAOC,EAAOC,GAGrC,MAHqC,UAAAA,IAAAA,GAAA,GAGlCH,EAASC,EAAGC,EAAGC,GACX,EAEJF,GAAKK,EAAAC,KAAKC,UAAUP,EAAGQ,GAClBR,EAAES,UAAUR,GACZA,GAAKI,EAAAC,KAAKC,UAAUN,EAAGO,IACtBP,EAAEQ,UAAUT,GAIlBA,EAAEC,GAAKC,IAAe,IAAJF,GAAY,GAAHC,GAAY,OAAJD,GAAYC,IAAIS,GAC/C,EAEJT,EAAED,GAAKE,IAAe,IAAJD,GAAY,GAAHD,GAAY,OAAJC,GAAYD,IAAIU,MAG/CC,IAWR,QAAAC,GACCZ,EAAOC,EAAOY,EACdC,GAIA,GALc,SAAAD,IAAAA,GAAA,GACd,SAAAC,IAAAA,EAAA,GAIGf,EAASC,EAAGC,GAAG,GAAO,OAAO,CAEhC,IAAM,MAAHD,GAAc,MAAHC,EAEb,QAAIY,IAEDR,EAAAC,KAAKS,SAASf,IAERgB,OAAOC,KAAKjB,GAAGkB,OAGrBb,EAAAC,KAAKS,SAASd,IAERe,OAAOC,KAAKhB,GAAGiB,OAGd,MAAHlB,GAAc,MAAHC,EAGnB,IAAGI,EAAAC,KAAKS,SAASf,IAAMK,EAAAC,KAAKS,SAASd,GACrC,CAEC,GAAMkB,GAAQH,OAAOC,KAAKjB,GAAIoB,EAAQJ,OAAOC,KAAKhB,GAAIoB,EAAMF,EAAMD,MAClE,IAAGG,GAAKD,EAAMF,OACb,OAAO,CAERC,GAAMG,OACNF,EAAME,MAEN,KAAI,GAAIC,GAAI,EAAGA,EAAEF,EAAKE,IACtB,CACC,GAAIC,GAAML,EAAMI,EAChB,IAAGC,IAAMJ,EAAMG,KAAOxB,EAASC,EAAEwB,GAAMvB,EAAEuB,IAAM,GAAO,OAAO,EAI9D,GAAGV,EAAW,EAGb,IAAe,GAAAW,GAAA,EAAAC,EAAAP,EAAAM,EAAAC,EAAAR,OAAAO,IAAK,CAAhB,GAAID,GAAGE,EAAAD,EAEV,KAAIb,EAAcZ,EAAEwB,GAAMvB,EAAEuB,GAAMX,EAAiBC,EAAa,GAAI,OAAO,EAI7E,OAAO,EAGR,OAAO,ED1GJE,OAAOW,eAAelC,EAAS,cAAgBmC,OAAO,GCT1D,IAAAvB,GAAAV,EAAA,WAIOQ,EAAYE,EAAAC,KAAKH,UAElBO,EAAkB,MASxBjB,GAAAM,SAAAA,CAOA,IAAMS,GAAa,WASnBf,GAAAW,QAAAA,EA8BAX,EAAAmB,cAAAA","file":"Compare.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./Types\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Types_1 = require(\"./Types\");\n    var isTrueNaN = Types_1.Type.isTrueNaN;\n    var VOID0 = void 0;\n    /**\n     * Used for special comparison including NaN.\n     * @param a\n     * @param b\n     * @param strict\n     * @returns {boolean|any}\n     */\n    function areEqual(a, b, strict) {\n        if (strict === void 0) { strict = true; }\n        return a === b\n            || !strict && a == b\n            || isTrueNaN(a) && isTrueNaN(b);\n    }\n    exports.areEqual = areEqual;\n    var COMPARE_TO = \"compareTo\";\n    function compare(a, b, strict) {\n        if (strict === void 0) { strict = true; }\n        if (areEqual(a, b, strict))\n            return 0 /* Equal */;\n        if (a && Types_1.Type.hasMember(a, COMPARE_TO))\n            return a.compareTo(b); // If a has compareTo, use it.\n        else if (b && Types_1.Type.hasMember(b, COMPARE_TO))\n            return -b.compareTo(a); // a doesn't have compareTo? check if b does and invert.\n        // Allow for special inequality..\n        if (a > b || strict && (a === 0 && b == 0 || a === null && b === VOID0))\n            return 1 /* Greater */;\n        if (b > a || strict && (b === 0 && a == 0 || b === null && a === VOID0))\n            return -1 /* Less */;\n        return NaN;\n    }\n    exports.compare = compare;\n    /**\n     * Determines if two primitives are equal or if two objects have the same key/value combinations.\n     * @param a\n     * @param b\n     * @param nullEquivalency If true, null/undefined will be equivalent to an empty object {}.\n     * @param extraDepth\n     * @returns {boolean}\n     */\n    function areEquivalent(a, b, nullEquivalency, extraDepth) {\n        if (nullEquivalency === void 0) { nullEquivalency = true; }\n        if (extraDepth === void 0) { extraDepth = 0; }\n        // Take a step by step approach to ensure efficiency.\n        if (areEqual(a, b, true))\n            return true;\n        if (a == null || b == null) {\n            if (!nullEquivalency)\n                return false;\n            if (Types_1.Type.isObject(a)) {\n                return !Object.keys(a).length;\n            }\n            if (Types_1.Type.isObject(b)) {\n                return !Object.keys(b).length;\n            }\n            return a == null && b == null;\n        }\n        if (Types_1.Type.isObject(a) && Types_1.Type.isObject(b)) {\n            var aKeys = Object.keys(a), bKeys = Object.keys(b), len = aKeys.length;\n            if (len != bKeys.length)\n                return false;\n            aKeys.sort();\n            bKeys.sort();\n            for (var i = 0; i < len; i++) {\n                var key = aKeys[i];\n                if (key !== bKeys[i] || !areEqual(a[key], b[key], true))\n                    return false;\n            }\n            // Doesn't track circular references but allows for controlling the amount of recursion.\n            if (extraDepth > 0) {\n                for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {\n                    var key = aKeys_1[_i];\n                    if (!areEquivalent(a[key], b[key], nullEquivalency, extraDepth - 1))\n                        return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    exports.areEquivalent = areEquivalent;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"./Types\";\r\nimport {Primitive} from \"./Primitive\";\r\nimport {IComparable} from \"./IComparable\";\r\nimport {CompareResult} from \"./CompareResult\";\r\nimport isTrueNaN = Type.isTrueNaN;\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\n/**\r\n * Used for special comparison including NaN.\r\n * @param a\r\n * @param b\r\n * @param strict\r\n * @returns {boolean|any}\r\n */\r\nexport function areEqual(a:any, b:any, strict:boolean = true):boolean\r\n{\r\n\treturn a===b\r\n\t\t|| !strict && a==b\r\n\t\t|| isTrueNaN(a) && isTrueNaN(b);\r\n}\r\n\r\nconst COMPARE_TO = \"compareTo\";\r\n\r\n/**\r\n * Compares two comparable objects or primitives.\r\n * @param a\r\n * @param b\r\n */\r\nexport function compare<T>(a:IComparable<T>, b:IComparable<T>):number;\r\nexport function compare<T extends Primitive>(a:T, b:T, strict?:boolean):CompareResult;\r\nexport function compare(a:any, b:any, strict:boolean = true):CompareResult\r\n{\r\n\r\n\tif(areEqual(a, b, strict))\r\n\t\treturn CompareResult.Equal;\r\n\r\n\tif(a && Type.hasMember(a, COMPARE_TO))\r\n\t\treturn a.compareTo(b); // If a has compareTo, use it.\r\n\telse if(b && Type.hasMember(b, COMPARE_TO))\r\n\t\treturn -b.compareTo(a); // a doesn't have compareTo? check if b does and invert.\r\n\r\n\t// Allow for special inequality..\r\n\r\n\tif(a>b || strict && (a===0 && b==0 || a===null && b===VOID0))\r\n\t\treturn CompareResult.Greater;\r\n\r\n\tif(b>a || strict && (b===0 && a==0 || b===null && a===VOID0))\r\n\t\treturn CompareResult.Less;\r\n\r\n\treturn NaN;\r\n}\r\n\r\n/**\r\n * Determines if two primitives are equal or if two objects have the same key/value combinations.\r\n * @param a\r\n * @param b\r\n * @param nullEquivalency If true, null/undefined will be equivalent to an empty object {}.\r\n * @param extraDepth\r\n * @returns {boolean}\r\n */\r\nexport function areEquivalent(\r\n\ta:any, b:any, nullEquivalency:boolean = true,\r\n\textraDepth:number = 0):boolean\r\n{\r\n\r\n\t// Take a step by step approach to ensure efficiency.\r\n\tif(areEqual(a, b, true)) return true;\r\n\r\n\tif(a==null || b==null)\r\n\t{\r\n\t\tif(!nullEquivalency) return false;\r\n\r\n\t\tif(Type.isObject(a))\r\n\t\t{\r\n\t\t\treturn !Object.keys(a).length;\r\n\t\t}\r\n\r\n\t\tif(Type.isObject(b))\r\n\t\t{\r\n\t\t\treturn !Object.keys(b).length;\r\n\t\t}\r\n\r\n\t\treturn a==null && b==null;\r\n\t}\r\n\r\n\tif(Type.isObject(a) && Type.isObject(b))\r\n\t{\r\n\r\n\t\tconst aKeys = Object.keys(a), bKeys = Object.keys(b), len = aKeys.length;\r\n\t\tif(len!=bKeys.length)\r\n\t\t\treturn false;\r\n\r\n\t\taKeys.sort();\r\n\t\tbKeys.sort();\r\n\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tlet key = aKeys[i];\r\n\t\t\tif(key!==bKeys[i] || !areEqual(a[key], b[key], true)) return false;\r\n\t\t}\r\n\r\n\t\t// Doesn't track circular references but allows for controlling the amount of recursion.\r\n\t\tif(extraDepth>0)\r\n\t\t{\r\n\r\n\t\t\tfor(let key of aKeys)\r\n\t\t\t{\r\n\t\t\t\tif(!areEquivalent(a[key], b[key], nullEquivalency, extraDepth - 1)) return false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n"]}
{"version":3,"sources":["System/Threading/defer.js","System/Threading/defer.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","defer","task","delay","payload","Defer","interval","count","Infinity","DeferInterval","Object","defineProperty","value","extends_1","__extends","DeferBase","prototype","dispose","this","cancel","_super","_this","call","_id","setTimeout","handler","id","clearTimeout","d","_remaining","setInterval","clearInterval"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,iBAAkBN,IAErD,SAAUI,EAASF,GAClB,YC2FJ,SAAAM,GACCC,EACAC,EACAC,GAEA,MAAO,IAAIC,GAAMH,EAAMC,EAAOC,GAG/B,QAAAE,GACCJ,EACAI,EACAC,GAEA,MAFA,UAAAA,IAAAA,EAAAC,EAAAA,GAEO,GAAIC,GAAcP,EAAMI,EAAUC,GDvGtCG,OAAOC,eAAehB,EAAS,cAAgBiB,OAAO,GCP1D,IAAAC,GAAAhB,EAAA,iBAEMiB,EAAYD,EAAAA,WAElBE,EAAA,WAAA,QAAAA,MAWA,MAJCA,GAAAC,UAAAC,QAAA,WAECC,KAAKC,UAEPJ,KAEAV,EAAA,SAAAe,GAIC,QAAAf,GAAYH,EAAeC,EAAkBC,GAAlB,SAAAD,IAAAA,EAAA,EAA3B,IAAAkB,GAECD,EAAAE,KAAAJ,OAAOA,IDIG,OCHLf,GAAM,IAAIA,EAAQ,GACvBkB,EAAKE,IAAMC,WAAWnB,EAAMoB,QAAStB,EAAOD,EAAMmB,EAAMjB,GDEvCiB,ECoBnB,MA9BoBP,GAAAT,EAAAe,GAWnBf,EAAAW,UAAAG,OAAA,WAEC,GAAMO,GAAKR,KAAKK,GAChB,SAAGG,IAEFC,aAAaD,GACbR,KAAKK,IAAM,MACJ,IAMMlB,EAAAoB,QAAf,SAAuBvB,EAAe0B,EAASxB,GAE9CwB,EAAET,SACFjB,EAAKE,IAGPC,GA9BoBU,GAgCpBN,EAAA,SAAAW,GAIC,QAAAX,GACCP,EACAI,EACQuB,GAAA,SAAAA,IAAAA,EAAArB,EAAAA,EAHT,IAAAa,GAKCD,EAAAE,KAAAJ,OAAOA,IACP,IAHQG,EAAAQ,WAAAA,EAGK,MAAVvB,EACF,KAAM,oCACP,IAAGA,EAAS,EACX,KAAM,gCDNG,OCQVe,GAAKE,IAAMO,YAAYrB,EAAcgB,QAASnB,EAAUJ,EAAMmB,GDR7CA,EC6BnB,MApC4BP,GAAAL,EAAAW,GAkB3BX,EAAAO,UAAAG,OAAA,WAEC,GAAMO,GAAKR,KAAKK,GAChB,SAAGG,IAEFK,cAAcL,GACdR,KAAKK,IAAM,MACJ,IAKMd,EAAAgB,QAAf,SAAuBvB,EAAe0B,KAE9BA,EAAEC,YAAaD,EAAET,SACxBjB,KAGFO,GApC4BM,EAgD5BpB,GAAAM,MAAAA,EAQAN,EAAAW,SAAAA,EAQAX,EAAAA,WAAeM","file":"defer.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var extends_1 = require(\"../../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var DeferBase = /** @class */ (function () {\n        function DeferBase() {\n        }\n        DeferBase.prototype.dispose = function () {\n            this.cancel();\n        };\n        return DeferBase;\n    }());\n    var Defer = /** @class */ (function (_super) {\n        __extends(Defer, _super);\n        function Defer(task, delay, payload) {\n            if (delay === void 0) { delay = 0; }\n            var _this = _super.call(this) || this;\n            if (!(delay > 0))\n                delay = 0; // covers undefined and null.\n            _this._id = setTimeout(Defer.handler, delay, task, _this, payload);\n            return _this;\n        }\n        Defer.prototype.cancel = function () {\n            var id = this._id;\n            if (id) {\n                clearTimeout(id);\n                this._id = null;\n                return true;\n            }\n            return false;\n        };\n        // Use a static function here to avoid recreating a new function every time.\n        Defer.handler = function (task, d, payload) {\n            d.cancel();\n            task(payload);\n        };\n        return Defer;\n    }(DeferBase));\n    var DeferInterval = /** @class */ (function (_super) {\n        __extends(DeferInterval, _super);\n        function DeferInterval(task, interval, _remaining) {\n            if (_remaining === void 0) { _remaining = Infinity; }\n            var _this = _super.call(this) || this;\n            _this._remaining = _remaining;\n            if (interval == null)\n                throw \"'interval' must be a valid number.\";\n            if (interval < 0)\n                throw \"'interval' cannot be negative.\";\n            _this._id = setInterval(DeferInterval.handler, interval, task, _this);\n            return _this;\n        }\n        DeferInterval.prototype.cancel = function () {\n            var id = this._id;\n            if (id) {\n                clearInterval(id);\n                this._id = null;\n                return true;\n            }\n            return false;\n        };\n        DeferInterval.handler = function (task, d) {\n            if (!(--d._remaining))\n                d.cancel();\n            task();\n        };\n        return DeferInterval;\n    }(DeferBase));\n    function defer(task, delay, payload) {\n        return new Defer(task, delay, payload);\n    }\n    exports.defer = defer;\n    function interval(task, interval, count) {\n        if (count === void 0) { count = Infinity; }\n        return new DeferInterval(task, interval, count);\n    }\n    exports.interval = interval;\n    exports.default = defer;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {ICancellable} from \"./ICancellable\";\r\nimport {Closure, Func} from \"../FunctionTypes\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nabstract class DeferBase implements ICancellable\r\n{\r\n\t// It may be a Timer in node, should not be restricted to number.\r\n\tprotected _id:any;\r\n\r\n\tabstract cancel():boolean;\r\n\r\n\tdispose():void\r\n\t{\r\n\t\tthis.cancel();\r\n\t}\r\n}\r\n\r\nclass Defer extends DeferBase\r\n{\r\n\r\n\r\n\tconstructor(task:Function, delay:number = 0, payload?:any)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!(delay>0)) delay = 0; // covers undefined and null.\r\n\t\tthis._id = setTimeout(Defer.handler, delay, task, this, payload);\r\n\t}\r\n\r\n\tcancel():boolean\r\n\t{\r\n\t\tconst id = this._id;\r\n\t\tif(id)\r\n\t\t{\r\n\t\t\tclearTimeout(id);\r\n\t\t\tthis._id = null;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Use a static function here to avoid recreating a new function every time.\r\n\tprivate static handler(task:Function, d:Defer, payload?:any):void\r\n\t{\r\n\t\td.cancel();\r\n\t\ttask(payload);\r\n\t}\r\n\r\n}\r\n\r\nclass DeferInterval extends DeferBase\r\n{\r\n\r\n\r\n\tconstructor(\r\n\t\ttask:Function,\r\n\t\tinterval:number,\r\n\t\tprivate _remaining:number = Infinity)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(interval==null)\r\n\t\t\tthrow \"'interval' must be a valid number.\";\r\n\t\tif(interval<0)\r\n\t\t\tthrow \"'interval' cannot be negative.\";\r\n\r\n\t\tthis._id = setInterval(DeferInterval.handler, interval, task, this);\r\n\t}\r\n\r\n\tcancel():boolean\r\n\t{\r\n\t\tconst id = this._id;\r\n\t\tif(id)\r\n\t\t{\r\n\t\t\tclearInterval(id);\r\n\t\t\tthis._id = null;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate static handler(task:Function, d:DeferInterval):void\r\n\t{\r\n\t\tif(!(--d._remaining)) d.cancel();\r\n\t\ttask();\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport function defer(\r\n\ttask:Closure,\r\n\tdelay?:number):ICancellable;\r\n\r\nexport function defer<T>(\r\n\ttask:Func<T>,\r\n\tdelay?:number,\r\n\tpayload?:T):ICancellable\r\n\r\nexport function defer<T>(\r\n\ttask:Function,\r\n\tdelay?:number,\r\n\tpayload?:any):ICancellable\r\n{\r\n\treturn new Defer(task, delay, payload);\r\n}\r\n\r\nexport function interval(\r\n\ttask:Function,\r\n\tinterval:number,\r\n\tcount:number = Infinity):ICancellable\r\n{\r\n\treturn new DeferInterval(task, interval, count);\r\n}\r\n\r\nexport default defer;"]}
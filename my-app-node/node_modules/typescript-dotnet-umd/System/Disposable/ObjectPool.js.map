{"version":3,"sources":["System/Disposable/ObjectPool.js","System/Disposable/ObjectPool.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Object","defineProperty","value","dispose_1","DisposableBase_1","TaskHandler_1","ArgumentOutOfRangeException_1","ArgumentException_1","extends_1","__extends","OBJECT_POOL","_MAX_SIZE","ABSOLUTE_MAX_SIZE","MUST_BE_GT1","MUST_BE_LTM","ObjectPool","_super","_maxSize","_generator","_recycler","_this","call","this","autoClearTimeout","isNaN","ArgumentOutOfRangeException","_localAbsMaxSize","Math","min","_","_disposableObjectName","_pool","_trimmer","TaskHandler","_trim","clear","_clear","_flusher","_autoFlusher","prototype","get","enumerable","configurable","p","length","pool","dispose","single","pop","trim","defer","throwIfDisposed","start","cancel","these","noCopy","toArrayAndClear","dump","_onDispose","extendAutoClear","t","isFinite","isScheduled","add","o","push","m","_onTaken","len","tryTake","take","ArgumentException","DisposableBase"],"mappings":"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","file":"ObjectPool.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Based upon ObjectPool from Parallel Extension Extras and other ObjectPool implementations.\n * Uses .add(T) and .take():T\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./dispose\", \"./DisposableBase\", \"../Threading/Tasks/TaskHandler\", \"../Exceptions/ArgumentOutOfRangeException\", \"../Exceptions/ArgumentException\", \"../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var dispose_1 = require(\"./dispose\");\n    var DisposableBase_1 = require(\"./DisposableBase\");\n    var TaskHandler_1 = require(\"../Threading/Tasks/TaskHandler\");\n    var ArgumentOutOfRangeException_1 = require(\"../Exceptions/ArgumentOutOfRangeException\");\n    var ArgumentException_1 = require(\"../Exceptions/ArgumentException\");\n    var extends_1 = require(\"../../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var OBJECT_POOL = \"ObjectPool\", _MAX_SIZE = \"_maxSize\", ABSOLUTE_MAX_SIZE = 65536, MUST_BE_GT1 = \"Must be at valid number least 1.\", MUST_BE_LTM = \"Must be less than or equal to \" + ABSOLUTE_MAX_SIZE + \".\";\n    var ObjectPool = /** @class */ (function (_super) {\n        __extends(ObjectPool, _super);\n        function ObjectPool(_maxSize, _generator, _recycler) {\n            var _this = _super.call(this) || this;\n            _this._maxSize = _maxSize;\n            _this._generator = _generator;\n            _this._recycler = _recycler;\n            /**\n             * By default will clear after 5 seconds of non-use.\n             */\n            _this.autoClearTimeout = 5000;\n            if (isNaN(_maxSize) || _maxSize < 1)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(_MAX_SIZE, _maxSize, MUST_BE_GT1);\n            if (_maxSize > ABSOLUTE_MAX_SIZE)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(_MAX_SIZE, _maxSize, MUST_BE_LTM);\n            _this._localAbsMaxSize = Math.min(_maxSize * 2, ABSOLUTE_MAX_SIZE);\n            var _ = _this;\n            _._disposableObjectName = OBJECT_POOL;\n            _._pool = [];\n            _._trimmer = new TaskHandler_1.TaskHandler(function () { return _._trim(); });\n            var clear = function () { return _._clear(); };\n            _._flusher = new TaskHandler_1.TaskHandler(clear);\n            _._autoFlusher = new TaskHandler_1.TaskHandler(clear);\n            return _this;\n        }\n        Object.defineProperty(ObjectPool.prototype, \"maxSize\", {\n            /**\n             * Defines the maximum at which trimming should allow.\n             * @returns {number}\n             */\n            get: function () {\n                return this._maxSize;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ObjectPool.prototype, \"count\", {\n            /**\n             * Current number of objects in pool.\n             * @returns {number}\n             */\n            get: function () {\n                var p = this._pool;\n                return p ? p.length : 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ObjectPool.prototype._trim = function () {\n            var pool = this._pool;\n            while (pool.length > this._maxSize) {\n                dispose_1.dispose.single(pool.pop(), true);\n            }\n        };\n        /**\n         * Will trim ensure the pool is less than the maxSize.\n         * @param defer A delay before trimming.  Will be overridden by later calls.\n         */\n        ObjectPool.prototype.trim = function (defer) {\n            this.throwIfDisposed();\n            this._trimmer.start(defer);\n        };\n        ObjectPool.prototype._clear = function () {\n            var _ = this;\n            var p = _._pool;\n            _._trimmer.cancel();\n            _._flusher.cancel();\n            _._autoFlusher.cancel();\n            dispose_1.dispose.these.noCopy(p, true);\n            p.length = 0;\n        };\n        /**\n         * Will clear out the pool.\n         * Cancels any scheduled trims when executed.\n         * @param defer A delay before clearing.  Will be overridden by later calls.\n         */\n        ObjectPool.prototype.clear = function (defer) {\n            this.throwIfDisposed();\n            this._flusher.start(defer);\n        };\n        ObjectPool.prototype.toArrayAndClear = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            _._trimmer.cancel();\n            _._flusher.cancel();\n            var p = _._pool;\n            _._pool = [];\n            return p;\n        };\n        /**\n         * Shortcut for toArrayAndClear();\n         */\n        ObjectPool.prototype.dump = function () {\n            return this.toArrayAndClear();\n        };\n        ObjectPool.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            var _ = this;\n            _._generator = null;\n            _._recycler = null;\n            dispose_1.dispose(_._trimmer, _._flusher, _._autoFlusher);\n            _._trimmer = null;\n            _._flusher = null;\n            _._autoFlusher = null;\n            _._pool.length = 0;\n            _._pool = null;\n        };\n        ObjectPool.prototype.extendAutoClear = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var t = _.autoClearTimeout;\n            if (isFinite(t) && !_._autoFlusher.isScheduled)\n                _._autoFlusher.start(t);\n        };\n        ObjectPool.prototype.add = function (o) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (_._pool.length >= _._localAbsMaxSize) {\n                // Getting too big, dispose immediately...\n                dispose_1.dispose(o);\n            }\n            else {\n                if (_._recycler)\n                    _._recycler(o);\n                _._pool.push(o);\n                var m = _._maxSize;\n                if (m < ABSOLUTE_MAX_SIZE && _._pool.length > m)\n                    _._trimmer.start(500);\n            }\n            _.extendAutoClear();\n        };\n        ObjectPool.prototype._onTaken = function () {\n            var _ = this, len = _._pool.length;\n            if (len <= _._maxSize)\n                _._trimmer.cancel();\n            if (len)\n                _.extendAutoClear();\n        };\n        ObjectPool.prototype.tryTake = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            try {\n                return _._pool.pop();\n            }\n            finally {\n                _._onTaken();\n            }\n        };\n        ObjectPool.prototype.take = function (factory) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!_._generator && !factory)\n                throw new ArgumentException_1.ArgumentException('factory', \"Must provide a factory if on was not provided at construction time.\");\n            try {\n                return _._pool.pop() || factory && factory() || _._generator();\n            }\n            finally {\n                _._onTaken();\n            }\n        };\n        return ObjectPool;\n    }(DisposableBase_1.DisposableBase));\n    exports.ObjectPool = ObjectPool;\n    exports.default = ObjectPool;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based upon ObjectPool from Parallel Extension Extras and other ObjectPool implementations.\r\n * Uses .add(T) and .take():T\r\n */\r\n\r\nimport {dispose} from \"./dispose\";\r\nimport {DisposableBase} from \"./DisposableBase\";\r\nimport {TaskHandler} from \"../Threading/Tasks/TaskHandler\";\r\nimport {ArgumentOutOfRangeException} from \"../Exceptions/ArgumentOutOfRangeException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst\r\n\tOBJECT_POOL       = \"ObjectPool\",\r\n\t_MAX_SIZE         = \"_maxSize\",\r\n\tABSOLUTE_MAX_SIZE = 65536,\r\n\tMUST_BE_GT1       = \"Must be at valid number least 1.\",\r\n\tMUST_BE_LTM       = `Must be less than or equal to ${ABSOLUTE_MAX_SIZE}.`;\r\n\r\nexport class ObjectPool<T> extends DisposableBase\r\n{\r\n\r\n\tprivate _pool:T[];\r\n\tprivate _trimmer:TaskHandler;\r\n\tprivate _flusher:TaskHandler;\r\n\tprivate _autoFlusher:TaskHandler;\r\n\r\n\t/**\r\n\t * A transient amount of object to exist over _maxSize until trim() is called.\r\n\t * But any added objects over _localAbsMaxSize will be disposed immediately.\r\n\t */\r\n\tprivate _localAbsMaxSize:number;\r\n\r\n\t/**\r\n\t * By default will clear after 5 seconds of non-use.\r\n\t */\r\n\tautoClearTimeout:number = 5000;\r\n\r\n\tconstructor(\r\n\t\tprivate _maxSize:number,\r\n\t\tprivate _generator?:(...args:any[])=>T,\r\n\t\tprivate _recycler?:(o:T)=>void)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(isNaN(_maxSize) || _maxSize<1)\r\n\t\t\tthrow new ArgumentOutOfRangeException(_MAX_SIZE, _maxSize, MUST_BE_GT1);\r\n\t\tif(_maxSize>ABSOLUTE_MAX_SIZE)\r\n\t\t\tthrow new ArgumentOutOfRangeException(_MAX_SIZE, _maxSize, MUST_BE_LTM);\r\n\r\n\t\tthis._localAbsMaxSize = Math.min(_maxSize*2, ABSOLUTE_MAX_SIZE);\r\n\r\n\t\tconst _ = this;\r\n\t\t_._disposableObjectName = OBJECT_POOL;\r\n\t\t_._pool = [];\r\n\t\t_._trimmer = new TaskHandler(()=>_._trim());\r\n\t\tconst clear = () => _._clear();\r\n\t\t_._flusher = new TaskHandler(clear);\r\n\t\t_._autoFlusher = new TaskHandler(clear);\r\n\t}\r\n\r\n\t/**\r\n\t * Defines the maximum at which trimming should allow.\r\n\t * @returns {number}\r\n\t */\r\n\tget maxSize():number\r\n\t{\r\n\t\treturn this._maxSize;\r\n\t}\r\n\r\n\t/**\r\n\t * Current number of objects in pool.\r\n\t * @returns {number}\r\n\t */\r\n\tget count():number\r\n\t{\r\n\t\tconst p = this._pool;\r\n\t\treturn p ? p.length : 0;\r\n\t}\r\n\r\n\tprotected _trim():void\r\n\t{\r\n\t\tconst pool = this._pool;\r\n\t\twhile(pool.length>this._maxSize)\r\n\t\t{\r\n\t\t\tdispose.single(<any>pool.pop(),true);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Will trim ensure the pool is less than the maxSize.\r\n\t * @param defer A delay before trimming.  Will be overridden by later calls.\r\n\t */\r\n\ttrim(defer?:number):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tthis._trimmer.start(defer);\r\n\t}\r\n\r\n\tprotected _clear():void\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst p = _._pool;\r\n\t\t_._trimmer.cancel();\r\n\t\t_._flusher.cancel();\r\n\t\t_._autoFlusher.cancel();\r\n\t\tdispose.these.noCopy(<any>p, true);\r\n\t\tp.length = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Will clear out the pool.\r\n\t * Cancels any scheduled trims when executed.\r\n\t * @param defer A delay before clearing.  Will be overridden by later calls.\r\n\t */\r\n\tclear(defer?:number):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tthis._flusher.start(defer);\r\n\t}\r\n\r\n\ttoArrayAndClear():T[]\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\t_._trimmer.cancel();\r\n\t\t_._flusher.cancel();\r\n\t\tconst p = _._pool;\r\n\t\t_._pool = [];\r\n\t\treturn p;\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut for toArrayAndClear();\r\n\t */\r\n\tdump():T[]\r\n\t{\r\n\t\treturn this.toArrayAndClear();\r\n\t}\r\n\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tconst _:any = this;\r\n\t\t_._generator = null;\r\n\t\t_._recycler = null;\r\n\t\tdispose(\r\n\t\t\t_._trimmer,\r\n\t\t\t_._flusher,\r\n\t\t\t_._autoFlusher\r\n\t\t);\r\n\t\t_._trimmer = null;\r\n\t\t_._flusher = null;\r\n\t\t_._autoFlusher = null;\r\n\r\n\t\t_._pool.length = 0;\r\n\t\t_._pool = null;\r\n\t}\r\n\r\n\textendAutoClear():void\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tconst t = _.autoClearTimeout;\r\n\t\tif(isFinite(t) && !_._autoFlusher.isScheduled)\r\n\t\t\t_._autoFlusher.start(t);\r\n\t}\r\n\r\n\tadd(o:T):void\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tif(_._pool.length>=_._localAbsMaxSize)\r\n\t\t{\r\n\t\t\t// Getting too big, dispose immediately...\r\n\t\t\tdispose(<any>o);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(_._recycler) _._recycler(o);\r\n\t\t\t_._pool.push(o);\r\n\t\t\tconst m = _._maxSize;\r\n\t\t\tif(m<ABSOLUTE_MAX_SIZE && _._pool.length>m)\r\n\t\t\t\t_._trimmer.start(500);\r\n\t\t}\r\n\t\t_.extendAutoClear();\r\n\r\n\t}\r\n\r\n\tprivate _onTaken():void\r\n\t{\r\n\t\tconst _ = this, len = _._pool.length;\r\n\t\tif(len<=_._maxSize)\r\n\t\t\t_._trimmer.cancel();\r\n\t\tif(len)\r\n\t\t\t_.extendAutoClear();\r\n\t}\r\n\r\n\ttryTake():T|undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\treturn _._pool.pop();\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\t_._onTaken();\r\n\t\t}\r\n\t}\r\n\r\n\ttake(factory?:()=>T):T\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tif(!_._generator && !factory)\r\n\t\t\tthrow new ArgumentException('factory', \"Must provide a factory if on was not provided at construction time.\");\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\treturn _._pool.pop() || factory && factory() || _._generator!();\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\t_._onTaken();\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport default ObjectPool;\r\n"]}
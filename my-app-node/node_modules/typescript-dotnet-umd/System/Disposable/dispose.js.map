{"version":3,"sources":["System/Disposable/dispose.js","System/Disposable/dispose.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","dispose","disposables","_i","arguments","length","disposeTheseInternal","using","disposable","closure","disposeSingle","trapExceptions","Types_1","Type","OBJECT","ex","index","exceptions","len","next","push","success","Object","defineProperty","value","single","deferred","these","withoutException","slice","delay","setTimeout","noCopy"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,YAAaN,IAEhD,SAAUI,EAASF,GAClB,YCOJ,SAAAM,KDMQ,ICNgB,GAAAC,MAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,GAAAC,UAAAD,EAGvBG,GAAqBJ,GAAa,GA0FnC,QAAAK,GACCC,EACAC,GAEA,IAEC,MAAOA,GAAQD,GDIT,QCANE,EAAcF,GAAY,IAS5B,QAAAE,GACCF,EACAG,GAEA,GACCH,SACUA,IAAYI,EAAAC,KAAKC,QACQ,kBAAzBN,GAAoB,QAG9B,GAAGG,EAEF,IAECH,EAAWP,UAEZ,MAAMc,GAEL,MAAOA,OAIRP,GAAWP,SAGb,OAAO,MAMR,QAAAK,GACCJ,EACAS,EACAK,GAAA,SAAAA,IAAAA,EAAA,EAKA,KAHA,GAAIC,GACEC,EAAMhB,EAAcA,EAAYG,OAAS,EAEzCW,EAAME,EAAKF,IACjB,CACC,GAAIG,GAAOjB,EAAac,EACxB,IAAIG,EACJ,GAAGR,EACH,CACC,GAAMI,GAAKL,EAAcS,GAAM,EAC5BJ,KAEEE,IAAYA,MAChBA,EAAWG,KAAKL,QAIlB,CACC,GAAIM,IAAU,CACd,KAECX,EAAcS,GAAM,GACpBE,GAAU,EDhBE,SCqBRA,GAAWL,EAAQ,EAAEE,GAIxBZ,EAAqBJ,GAAa,EAAOc,EAAQ,GAInD,IAAIK,EAAS,OAIf,MAAOJ,GDjMJK,OAAOC,eAAe5B,EAAS,cAAgB6B,OAAO,GCT1D,IAAAZ,GAAAf,EAAA,WAeAF,GAAAM,QAAAA,EAMA,SAAcA,GAQb,QAAAwB,GAAuBjB,EAA2BG,GAAA,SAAAA,IAAAA,GAAA,GAE9CH,GACFE,EAAcF,EAAWG,GAG3B,QAAAe,KDOW,ICPc,GAAAxB,MAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,GAAAC,UAAAD,EAExBwB,GAAMD,SAASxB,GAUhB,QAAA0B,KDSW,ICTsB,GAAA1B,MAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,GAAAC,UAAAD,EAGhC,OAAOG,GAAqBJ,GAAa,GAS1C,QAAAyB,GAAsBzB,EAAiCS,GAEtD,MAAOT,IAAeA,EAAYG,OAC/BC,EAAqBJ,EAAY2B,QAASlB,GAC1C,OAlCYV,EAAAwB,OAAMA,EAMNxB,EAAAyB,SAAQA,EAYRzB,EAAA2B,iBAAgBA,EAYhB3B,EAAA0B,MAAKA,EAOrB,SAAcA,GAEb,QAAAD,GAAyBxB,EAAiC4B,GAAA,SAAAA,IAAAA,EAAA,GAEtD5B,GAAeA,EAAYG,SAExByB,GAAO,IAAIA,EAAQ,GACxBC,WAAWzB,EAAsBwB,EAAO5B,EAAY2B,SAAS,IAU/D,QAAAG,GAAuB9B,EAAiCS,GAEvD,MAAOT,IAAeA,EAAYG,OAC/BC,EAAqBJ,EAAaS,GAClC,OAnBYgB,EAAAD,SAAQA,EAeRC,EAAAK,OAAMA,GAjBTL,EAAA1B,EAAA0B,QAAA1B,EAAA0B,YA7CD1B,EAAAN,EAAAM,UAAAN,EAAAM,aAuFdN,EAAAY,MAAAA,EAiGAZ,EAAAA,WAAeM","file":"dispose.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../Types\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Types_1 = require(\"../Types\");\n    /**\n     * Takes any number of disposables as arguments and attempts to dispose them.\n     * Any exceptions thrown within a dispose are not trapped.\n     * Use 'disposeWithoutException' to automatically trap exceptions.\n     *\n     * Can accept <any> and will ignore objects that don't have a dispose() method.\n     * @param disposables\n     */\n    function dispose() {\n        var disposables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            disposables[_i] = arguments[_i];\n        }\n        // The disposables arguments array is effectively localized so it's safe.\n        disposeTheseInternal(disposables, false);\n    }\n    exports.dispose = dispose;\n    (function (dispose) {\n        /**\n         * Use this when only disposing one object to avoid creation of arrays.\n         * @param disposable\n         * @param trapExceptions\n         */\n        function single(disposable, trapExceptions) {\n            if (trapExceptions === void 0) { trapExceptions = false; }\n            if (disposable)\n                disposeSingle(disposable, trapExceptions);\n        }\n        dispose.single = single;\n        function deferred() {\n            var disposables = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                disposables[_i] = arguments[_i];\n            }\n            these.deferred(disposables);\n        }\n        dispose.deferred = deferred;\n        /**\n         * Takes any number of disposables and traps any errors that occur when disposing.\n         * Returns an array of the exceptions thrown.\n         * @param disposables\n         * @returns {any[]} Returns an array of exceptions that occurred, if there are any.\n         */\n        function withoutException() {\n            var disposables = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                disposables[_i] = arguments[_i];\n            }\n            // The disposables arguments array is effectively localized so it's safe.\n            return disposeTheseInternal(disposables, true);\n        }\n        dispose.withoutException = withoutException;\n        /**\n         * Takes an array of disposable objects and ensures they are disposed.\n         * @param disposables\n         * @param trapExceptions If true, prevents exceptions from being thrown when disposing.\n         * @returns {any[]} If 'trapExceptions' is true, returns an array of exceptions that occurred, if there are any.\n         */\n        function these(disposables, trapExceptions) {\n            return disposables && disposables.length\n                ? disposeTheseInternal(disposables.slice(), trapExceptions)\n                : void 0;\n        }\n        dispose.these = these;\n        (function (these) {\n            function deferred(disposables, delay) {\n                if (delay === void 0) { delay = 0; }\n                if (disposables && disposables.length) {\n                    if (!(delay >= 0))\n                        delay = 0;\n                    setTimeout(disposeTheseInternal, delay, disposables.slice(), true);\n                }\n            }\n            these.deferred = deferred;\n            /**\n             * Use this unsafe method when guaranteed not to cause events that will make modifications to the disposables array.\n             * @param disposables\n             * @param trapExceptions\n             * @returns {any[]}\n             */\n            function noCopy(disposables, trapExceptions) {\n                return disposables && disposables.length\n                    ? disposeTheseInternal(disposables, trapExceptions)\n                    : void 0;\n            }\n            these.noCopy = noCopy;\n        })(these = dispose.these || (dispose.these = {}));\n    })(dispose = exports.dispose || (exports.dispose = {}));\n    /**\n     * Just like in C# this 'using' function will ensure the passed disposable is disposed when the closure has finished.\n     *\n     * Usage:\n     * ```typescript\n     * using(new DisposableObject(),(myObj)=>{\n         *   // do work with myObj\n         * });\n     * // myObj automatically has it's dispose method called.\n     * ```\n     *\n     * @param disposable Object to be disposed.\n     * @param closure Function call to execute.\n     * @returns {TReturn} Returns whatever the closure's return value is.\n     */\n    function using(disposable, closure) {\n        try {\n            return closure(disposable);\n        }\n        finally {\n            disposeSingle(disposable, false);\n        }\n    }\n    exports.using = using;\n    /**\n     * This private function makes disposing more robust for when there's no type checking.\n     * If trapExceptions is 'true' it catches and returns any exception instead of throwing.\n     */\n    function disposeSingle(disposable, trapExceptions) {\n        if (disposable\n            && typeof disposable == Types_1.Type.OBJECT\n            && typeof disposable['dispose'] == \"function\") {\n            if (trapExceptions) {\n                try {\n                    disposable.dispose();\n                }\n                catch (ex) {\n                    return ex;\n                }\n            }\n            else\n                disposable.dispose();\n        }\n        return null;\n    }\n    /**\n     * This dispose method assumes it's working on a local arrayCopy and is unsafe for external use.\n     */\n    function disposeTheseInternal(disposables, trapExceptions, index) {\n        if (index === void 0) { index = 0; }\n        var exceptions;\n        var len = disposables ? disposables.length : 0;\n        for (; index < len; index++) {\n            var next = disposables[index];\n            if (!next)\n                continue;\n            if (trapExceptions) {\n                var ex = disposeSingle(next, true);\n                if (ex) {\n                    if (!exceptions)\n                        exceptions = [];\n                    exceptions.push(ex);\n                }\n            }\n            else {\n                var success = false;\n                try {\n                    disposeSingle(next, false);\n                    success = true;\n                }\n                finally {\n                    if (!success && index + 1 < len) {\n                        /* If code is 'continued' by the debugger,\n                         * need to ensure the rest of the disposables are cared for. */\n                        disposeTheseInternal(disposables, false, index + 1);\n                    }\n                }\n                // Just in case...  Should never happen, but asserts the intention.\n                if (!success)\n                    break;\n            }\n        }\n        return exceptions;\n    }\n    exports.default = dispose;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../Types\";\r\nimport {IDisposable} from \"./IDisposable\";\r\n\r\n// Allows for more flexible parameters.\r\nexport type DisposableItem = IDisposable|null|undefined;\r\nexport type DisposableItemArray = Array<DisposableItem>|null|undefined;\r\n\r\n/**\r\n * Takes any number of disposables as arguments and attempts to dispose them.\r\n * Any exceptions thrown within a dispose are not trapped.\r\n * Use 'disposeWithoutException' to automatically trap exceptions.\r\n *\r\n * Can accept <any> and will ignore objects that don't have a dispose() method.\r\n * @param disposables\r\n */\r\nexport function dispose(...disposables:DisposableItem[]):void\r\n{\r\n\t// The disposables arguments array is effectively localized so it's safe.\r\n\tdisposeTheseInternal(disposables, false);\r\n}\r\n\r\nexport module dispose\r\n{\r\n\r\n\t/**\r\n\t * Use this when only disposing one object to avoid creation of arrays.\r\n\t * @param disposable\r\n\t * @param trapExceptions\r\n\t */\r\n\texport function single(disposable:DisposableItem, trapExceptions:boolean = false):void\r\n\t{\r\n\t\tif(disposable)\r\n\t\t\tdisposeSingle(disposable,trapExceptions);\r\n\t}\r\n\r\n\texport function deferred(...disposables:DisposableItem[]):void\r\n\t{\r\n\t\tthese.deferred(disposables);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Takes any number of disposables and traps any errors that occur when disposing.\r\n\t * Returns an array of the exceptions thrown.\r\n\t * @param disposables\r\n\t * @returns {any[]} Returns an array of exceptions that occurred, if there are any.\r\n\t */\r\n\texport function withoutException(...disposables:DisposableItem[]):any[]|undefined\r\n\t{\r\n\t\t// The disposables arguments array is effectively localized so it's safe.\r\n\t\treturn disposeTheseInternal(disposables, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an array of disposable objects and ensures they are disposed.\r\n\t * @param disposables\r\n\t * @param trapExceptions If true, prevents exceptions from being thrown when disposing.\r\n\t * @returns {any[]} If 'trapExceptions' is true, returns an array of exceptions that occurred, if there are any.\r\n\t */\r\n\texport function these(disposables:DisposableItemArray, trapExceptions?:boolean):any[]|undefined\r\n\t{\r\n\t\treturn disposables && disposables.length\r\n\t\t\t? disposeTheseInternal(disposables.slice(), trapExceptions)\r\n\t\t\t: void 0;\r\n\t}\r\n\r\n\texport module these\r\n\t{\r\n\t\texport function deferred(disposables:DisposableItemArray, delay:number = 0):void\r\n\t\t{\r\n\t\t\tif(disposables && disposables.length)\r\n\t\t\t{\r\n\t\t\t\tif(!(delay>=0)) delay = 0;\r\n\t\t\t\tsetTimeout(disposeTheseInternal, delay, disposables.slice(), true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Use this unsafe method when guaranteed not to cause events that will make modifications to the disposables array.\r\n\t\t * @param disposables\r\n\t\t * @param trapExceptions\r\n\t\t * @returns {any[]}\r\n\t\t */\r\n\t\texport function noCopy(disposables:DisposableItemArray, trapExceptions?:boolean):any[]|undefined\r\n\t\t{\r\n\t\t\treturn disposables && disposables.length\r\n\t\t\t\t? disposeTheseInternal(disposables, trapExceptions)\r\n\t\t\t\t: void 0;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Just like in C# this 'using' function will ensure the passed disposable is disposed when the closure has finished.\r\n *\r\n * Usage:\r\n * ```typescript\r\n * using(new DisposableObject(),(myObj)=>{\r\n     *   // do work with myObj\r\n     * });\r\n * // myObj automatically has it's dispose method called.\r\n * ```\r\n *\r\n * @param disposable Object to be disposed.\r\n * @param closure Function call to execute.\r\n * @returns {TReturn} Returns whatever the closure's return value is.\r\n */\r\nexport function using<TDisposable extends IDisposable,TReturn>(\r\n\tdisposable:TDisposable,\r\n\tclosure:(disposable:TDisposable) => TReturn):TReturn\r\n{\r\n\ttry\r\n\t{\r\n\t\treturn closure(disposable);\r\n\t}\r\n\tfinally\r\n\t{\r\n\t\tdisposeSingle(disposable, false);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * This private function makes disposing more robust for when there's no type checking.\r\n * If trapExceptions is 'true' it catches and returns any exception instead of throwing.\r\n */\r\nfunction disposeSingle(\r\n\tdisposable:IDisposable,\r\n\ttrapExceptions:boolean):any\r\n{\r\n\tif(\r\n\t\tdisposable\r\n\t\t&& typeof disposable==Type.OBJECT\r\n\t\t&& typeof disposable['dispose'] == \"function\"\r\n\t)\r\n\t{\r\n\t\tif(trapExceptions)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdisposable.dispose();\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\treturn ex;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tdisposable.dispose();\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * This dispose method assumes it's working on a local arrayCopy and is unsafe for external use.\r\n */\r\nfunction disposeTheseInternal(\r\n\tdisposables:DisposableItemArray,\r\n\ttrapExceptions?:boolean,\r\n\tindex:number = 0):any[]|undefined\r\n{\r\n\tlet exceptions:any[]|undefined;\r\n\tconst len = disposables ? disposables.length : 0;\r\n\r\n\tfor(; index<len; index++)\r\n\t{\r\n\t\tlet next = disposables![index];\r\n\t\tif(!next) continue;\r\n\t\tif(trapExceptions)\r\n\t\t{\r\n\t\t\tconst ex = disposeSingle(next, true);\r\n\t\t\tif(ex)\r\n\t\t\t{\r\n\t\t\t\tif(!exceptions) exceptions = [];\r\n\t\t\t\texceptions.push(ex);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlet success = false;\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdisposeSingle(next, false);\r\n\t\t\t\tsuccess = true;\r\n\t\t\t}\r\n\t\t\t\t// Don't trap the exception in order to allow it to propagate the stack trace.\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\tif(!success && index + 1<len)\r\n\t\t\t\t{\r\n\t\t\t\t\t/* If code is 'continued' by the debugger,\r\n\t\t\t\t\t * need to ensure the rest of the disposables are cared for. */\r\n\t\t\t\t\tdisposeTheseInternal(disposables, false, index + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Just in case...  Should never happen, but asserts the intention.\r\n\t\t\tif(!success) break;\r\n\t\t}\r\n\t}\r\n\r\n\treturn exceptions;\r\n}\r\n\r\nexport default dispose;"]}
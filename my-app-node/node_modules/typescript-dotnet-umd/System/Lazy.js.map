{"version":3,"sources":["System/Lazy.js","System/Lazy.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Object","defineProperty","value","ResolverBase_1","extends_1","__extends","Lazy","_super","valueFactory","trapExceptions","allowReset","_this","call","this","_disposableObjectName","_isValueCreated","prototype","get","enumerable","configurable","getValue","equals","other","valueEquals","create","ResolverBase","ResettableLazy"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QACfG,UAANF,IAAiBF,OAAOC,QAAUC,OAEf,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,iBAAkB,cAAeN,IAEpE,SAAUI,EAASF,GAClB,YACAM,QAAOC,eAAeP,EAAS,cAAgBQ,OAAO,GCP1D,IAAAC,GAAAP,EAAA,kBACAQ,EAAAR,EAAA,cAEMS,EAAYD,EAAAA,WAIlBE,EAAA,SAAAC,GAGC,QAAAD,GAAYE,EAAsBC,EAAgCC,GAAhC,SAAAD,IAAAA,GAAA,GAAgC,SAAAC,IAAAA,GAAA,EAAlE,IAAAC,GAECJ,EAAAK,KAAAC,KAAML,EAAcC,EAAgBC,IAAWG,IDSrC,OCRVF,GAAKG,sBAAwB,OAC7BH,EAAKI,iBAAkB,EDONJ,ECqBnB,MAnC6BN,GAAAC,EAAAC,GAU5BP,OAAAC,eAAIK,EAAAU,UAAA,kBDOOC,ICPX,WAEC,QAASJ,KAAKE,iBDQJG,YAAY,EACZC,cAAc,ICNzBnB,OAAAC,eAAIK,EAAAU,UAAA,SDSOC,ICTX,WAEC,MAAOJ,MAAKO,YDUFF,YAAY,EACZC,cAAc,ICRzBb,EAAAU,UAAAK,OAAA,SAAOC,GAEN,MAAOT,OAAMS,GAGdhB,EAAAU,UAAAO,YAAA,SAAYD,GAEX,MAAOT,MAAKQ,OAAOC,IAAUT,KAAKX,QAAQoB,EAAMpB,OAG1CI,EAAAkB,OAAP,SAAiBhB,EAAsBC,EAAgCC,GAEtE,MAFsC,UAAAD,IAAAA,GAAA,GAAgC,SAAAC,IAAAA,GAAA,GAE/D,GAAIJ,GAAQE,EAAcC,EAAgBC,IAGnDJ,GAnC6BH,EAAAsB,aAAhB/B,GAAAY,KAAAA,CAqCb,IAAAoB,GAAA,SAAAnB,GAEC,QAAAmB,GAAYlB,EAAsBC,GAAA,SAAAA,IAAAA,GAAA,EAAlC,IAAAE,GAECJ,EAAAK,KAAAC,KAAML,EAAcC,GAAgB,IAAKI,IDS/B,OCRVF,GAAKG,sBAAwB,iBDQZH,ECDnB,MAZuCN,GAAAqB,EAAAnB,GAQ/BmB,EAAAF,OAAP,SAAiBhB,EAAsBC,GAEtC,MAFsC,UAAAA,IAAAA,GAAA,GAE/B,GAAIiB,GAAkBlB,EAAcC,IAE7CiB,GAZuCpB,EAA1BZ,GAAAgC,eAAAA,EAcbhC,EAAAA,WAAeY","file":"Lazy.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./ResolverBase\", \"../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ResolverBase_1 = require(\"./ResolverBase\");\n    var extends_1 = require(\"../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    // We need a non-resettable lazy to ensure it can be passed safely around.\n    var Lazy = /** @class */ (function (_super) {\n        __extends(Lazy, _super);\n        function Lazy(valueFactory, trapExceptions, allowReset) {\n            if (trapExceptions === void 0) { trapExceptions = false; }\n            if (allowReset === void 0) { allowReset = false; }\n            var _this = _super.call(this, valueFactory, trapExceptions, allowReset) || this;\n            _this._disposableObjectName = 'Lazy';\n            _this._isValueCreated = false;\n            return _this;\n        }\n        Object.defineProperty(Lazy.prototype, \"isValueCreated\", {\n            get: function () {\n                return !!this._isValueCreated;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Lazy.prototype, \"value\", {\n            get: function () {\n                return this.getValue();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Lazy.prototype.equals = function (other) {\n            return this == other;\n        };\n        Lazy.prototype.valueEquals = function (other) {\n            return this.equals(other) || this.value === other.value;\n        };\n        Lazy.create = function (valueFactory, trapExceptions, allowReset) {\n            if (trapExceptions === void 0) { trapExceptions = false; }\n            if (allowReset === void 0) { allowReset = false; }\n            return new Lazy(valueFactory, trapExceptions, allowReset);\n        };\n        return Lazy;\n    }(ResolverBase_1.ResolverBase));\n    exports.Lazy = Lazy;\n    var ResettableLazy = /** @class */ (function (_super) {\n        __extends(ResettableLazy, _super);\n        function ResettableLazy(valueFactory, trapExceptions) {\n            if (trapExceptions === void 0) { trapExceptions = false; }\n            var _this = _super.call(this, valueFactory, trapExceptions, true) || this;\n            _this._disposableObjectName = 'ResettableLazy';\n            return _this;\n        }\n        ResettableLazy.create = function (valueFactory, trapExceptions) {\n            if (trapExceptions === void 0) { trapExceptions = false; }\n            return new ResettableLazy(valueFactory, trapExceptions);\n        };\n        return ResettableLazy;\n    }(Lazy));\n    exports.ResettableLazy = ResettableLazy;\n    exports.default = Lazy;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {ILazy} from \"./ILazy\";\r\nimport {Func} from \"./FunctionTypes\";\r\nimport {ResolverBase} from \"./ResolverBase\";\r\nimport __extendsImport from \"../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\n// We need a non-resettable lazy to ensure it can be passed safely around.\r\nexport class Lazy<T> extends ResolverBase<T> implements ILazy<T>\r\n{\r\n\r\n\tconstructor(valueFactory:Func<T>, trapExceptions:boolean = false, allowReset:boolean = false)\r\n\t{\r\n\t\tsuper(valueFactory, trapExceptions, allowReset);\r\n\t\tthis._disposableObjectName = 'Lazy';\r\n\t\tthis._isValueCreated = false;\r\n\t}\r\n\r\n\tget isValueCreated():boolean\r\n\t{\r\n\t\treturn !!this._isValueCreated;\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this.getValue();\r\n\t}\r\n\r\n\tequals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this==other;\r\n\t}\r\n\r\n\tvalueEquals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this.equals(other) || this.value===other.value;\r\n\t}\r\n\r\n\tstatic create<T>(valueFactory:Func<T>, trapExceptions:boolean = false, allowReset:boolean = false)\r\n\t{\r\n\t\treturn new Lazy<T>(valueFactory, trapExceptions, allowReset);\r\n\t}\r\n\r\n}\r\n\r\nexport class ResettableLazy<T> extends Lazy<T>\r\n{\r\n\tconstructor(valueFactory:Func<T>, trapExceptions:boolean = false)\r\n\t{\r\n\t\tsuper(valueFactory, trapExceptions, true);\r\n\t\tthis._disposableObjectName = 'ResettableLazy';\r\n\t}\r\n\r\n\tstatic create<T>(valueFactory:Func<T>, trapExceptions:boolean = false)\r\n\t{\r\n\t\treturn new ResettableLazy<T>(valueFactory, trapExceptions);\r\n\t}\r\n}\r\n\r\nexport default Lazy;"]}
{"version":3,"sources":["System/Uri/QueryParams.js","System/Uri/QueryParams.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","encode","values","prefixIfNotEmpty","EMPTY","entries","Enumerator_1","isEnumerableOrArrayLike","forEach","entry","KeyValueExtract_1","extractKeyValue","key","value","appendKeyValue","Object","keys","length","QUERY_SEPARATOR","join","ENTRY_SEPARATOR","appendKeyValueSingle","push","KEY_VALUE_SEPARATOR","encodeValue","isUriComponentFormattable","toUriComponent","indexOf","encodeURIComponent","Serialize","toString","instance","Types_1","Type","hasMemberOfType","TO_URI_COMPONENT","FUNCTION","parse","query","entryHandler","deserialize","decodeValues","replace","split","_i","entries_1","si","substring","decodeURIComponent","toPrimitive","parseToMap","result","prev","parseToArray","defineProperty","Separator","Query","Entry","KeyValue","freeze"],"mappings":"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","file":"QueryParams.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../Serialization/Utility\", \"../Types\", \"../KeyValueExtract\", \"../Collections/Enumeration/Enumerator\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Serialize = require(\"../Serialization/Utility\");\n    var Types_1 = require(\"../Types\");\n    var KeyValueExtract_1 = require(\"../KeyValueExtract\");\n    var Enumerator_1 = require(\"../Collections/Enumeration/Enumerator\");\n    /*\n     * This module is provided as a lighter weight utility for acquiring query params.\n     * If more detailed operations are necessary, consider importing QueryBuilder.\n     */\n    var EMPTY = \"\", QUERY_SEPARATOR = \"?\", ENTRY_SEPARATOR = \"&\", KEY_VALUE_SEPARATOR = \"=\", TO_URI_COMPONENT = \"toUriComponent\";\n    /**\n     * Returns the encoded URI string\n     * @param values\n     * @param prefixIfNotEmpty\n     * @returns {string}\n     */\n    function encode(values, prefixIfNotEmpty) {\n        if (!values)\n            return EMPTY;\n        var entries = [];\n        if (Enumerator_1.isEnumerableOrArrayLike(values)) {\n            Enumerator_1.forEach(values, function (entry) {\n                return KeyValueExtract_1.extractKeyValue(entry, function (key, value) { return appendKeyValue(entries, key, value); });\n            });\n        }\n        else {\n            Object.keys(values).forEach(function (key) { return appendKeyValue(entries, key, values[key]); });\n        }\n        return (entries.length && prefixIfNotEmpty ? QUERY_SEPARATOR : EMPTY)\n            + entries.join(ENTRY_SEPARATOR);\n    }\n    exports.encode = encode;\n    function appendKeyValueSingle(entries, key, value) {\n        entries.push(key + KEY_VALUE_SEPARATOR + encodeValue(value));\n    }\n    // According to spec, if there is an array of values with the same key, then each value is replicated with that key.\n    function appendKeyValue(entries, key, value) {\n        if (Enumerator_1.isEnumerableOrArrayLike(value)) {\n            Enumerator_1.forEach(value, function (v) { return appendKeyValueSingle(entries, key, v); });\n        }\n        else {\n            appendKeyValueSingle(entries, key, value);\n        }\n    }\n    /**\n     * Converts any primitive, serializable or uri-component object to an encoded string.\n     * @param value\n     * @returns {string}\n     */\n    function encodeValue(value) {\n        if (isUriComponentFormattable(value)) {\n            var v = value.toUriComponent();\n            if (v && v.indexOf(ENTRY_SEPARATOR) != 1)\n                throw '.toUriComponent() did not encode the value.';\n            return v;\n        }\n        else {\n            return encodeURIComponent(Serialize.toString(value));\n        }\n    }\n    exports.encodeValue = encodeValue;\n    /**\n     * A shortcut for identifying an UriComponent.Formattable object.\n     * @param instance\n     * @returns {boolean}\n     */\n    function isUriComponentFormattable(instance) {\n        return Types_1.Type.hasMemberOfType(instance, TO_URI_COMPONENT, Types_1.Type.FUNCTION);\n    }\n    exports.isUriComponentFormattable = isUriComponentFormattable;\n    /**\n     * Parses a string for valid query param entries and pipes them through a handler.\n     * @param query\n     * @param entryHandler\n     * @param deserialize Default is true.\n     * @param decodeValues Default is true.\n     */\n    function parse(query, entryHandler, deserialize, decodeValues) {\n        if (deserialize === void 0) { deserialize = true; }\n        if (decodeValues === void 0) { decodeValues = true; }\n        if (query && (query = query.replace(/^\\s*\\?+/, ''))) {\n            var entries = query.split(ENTRY_SEPARATOR);\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                var entry = entries_1[_i];\n                /*\n                 * Since it is technically possible to have multiple '=' we need to identify the first one.\n                 * And if there is no '=' then the entry is ignored.\n                 */\n                var si = entry.indexOf(KEY_VALUE_SEPARATOR);\n                if (si != -1) {\n                    var key = entry.substring(0, si);\n                    var value = entry.substring(si + 1);\n                    if (decodeValues)\n                        value = decodeURIComponent(value);\n                    if (deserialize)\n                        value = Serialize.toPrimitive(value);\n                    entryHandler(key, value);\n                }\n            }\n        }\n    }\n    exports.parse = parse;\n    /**\n     * Parses a string for valid query params and returns a key-value map of the entries.\n     * @param query\n     * @param deserialize Default is true.\n     * @param decodeValues Default is true.\n     * @returns {IMap<Primitive>}\n     */\n    function parseToMap(query, deserialize, decodeValues) {\n        if (deserialize === void 0) { deserialize = true; }\n        if (decodeValues === void 0) { decodeValues = true; }\n        var result = {};\n        parse(query, function (key, value) {\n            if ((key) in (result)) {\n                var prev = result[key];\n                if (!((prev) instanceof (Array)))\n                    result[key] = prev = [prev];\n                prev.push(value);\n            }\n            else\n                result[key] = value;\n        }, deserialize, decodeValues);\n        return result;\n    }\n    exports.parseToMap = parseToMap;\n    /**\n     * Parses a string for valid query params and returns a key-value pair array of the entries.\n     * @param query\n     * @param deserialize Default is true.\n     * @param decodeValues Default is true.\n     * @returns {IKeyValuePair<string, Primitive>[]}\n     */\n    function parseToArray(query, deserialize, decodeValues) {\n        if (deserialize === void 0) { deserialize = true; }\n        if (decodeValues === void 0) { decodeValues = true; }\n        var result = [];\n        parse(query, function (key, value) { result.push({ key: key, value: value }); }, deserialize, decodeValues);\n        return result;\n    }\n    exports.parseToArray = parseToArray;\n    var Separator;\n    (function (Separator) {\n        Separator.Query = QUERY_SEPARATOR;\n        Separator.Entry = ENTRY_SEPARATOR;\n        Separator.KeyValue = KEY_VALUE_SEPARATOR;\n    })(Separator = exports.Separator || (exports.Separator = {}));\n    Object.freeze(Separator);\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport * as Serialize from \"../Serialization/Utility\";\r\nimport {UriComponent} from \"./UriComponent\";\r\nimport {QueryParam} from \"./QueryParam\";\r\nimport {Type} from \"../Types\";\r\nimport {extractKeyValue} from \"../KeyValueExtract\";\r\nimport {forEach, isEnumerableOrArrayLike} from \"../Collections/Enumeration/Enumerator\";\r\nimport {IMap} from \"../../IMap\";\r\nimport {Primitive} from \"../Primitive\";\r\nimport {IStringKeyValuePair} from \"../KeyValuePair\";\r\nimport {IEnumerableOrArray} from \"../Collections/IEnumerableOrArray\";\r\n\r\n/*\r\n * This module is provided as a lighter weight utility for acquiring query params.\r\n * If more detailed operations are necessary, consider importing QueryBuilder.\r\n */\r\n\r\nconst\r\n\tEMPTY               = \"\",\r\n\tQUERY_SEPARATOR     = \"?\",\r\n\tENTRY_SEPARATOR     = \"&\",\r\n\tKEY_VALUE_SEPARATOR = \"=\",\r\n\tTO_URI_COMPONENT    = \"toUriComponent\";\r\n\r\n\r\n/**\r\n * Returns the encoded URI string\r\n * @param values\r\n * @param prefixIfNotEmpty\r\n * @returns {string}\r\n */\r\nexport function encode(\r\n\tvalues:UriComponent.Map | QueryParam.EnumerableOrArray,\r\n\tprefixIfNotEmpty?:boolean):string\r\n{\r\n\tif(!values) return EMPTY;\r\n\tconst entries:string[] = [];\r\n\r\n\tif(isEnumerableOrArrayLike(values))\r\n\t{\r\n\t\tforEach(values, entry=>\r\n\t\t\textractKeyValue(entry,\r\n\t\t\t\t(key, value)=> appendKeyValue(entries, key, value))\r\n\t\t);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tObject.keys(values).forEach(\r\n\t\t\tkey=> appendKeyValue(entries, key, values[key])\r\n\t\t);\r\n\t}\r\n\r\n\treturn (entries.length && prefixIfNotEmpty ? QUERY_SEPARATOR : EMPTY)\r\n\t\t+ entries.join(ENTRY_SEPARATOR);\r\n}\r\n\r\nfunction appendKeyValueSingle(\r\n\tentries:string[],\r\n\tkey:string,\r\n\tvalue:UriComponent.Value):void\r\n{\r\n\tentries.push(key + KEY_VALUE_SEPARATOR + encodeValue(value));\r\n}\r\n\r\n// According to spec, if there is an array of values with the same key, then each value is replicated with that key.\r\nfunction appendKeyValue(\r\n\tentries:string[],\r\n\tkey:string,\r\n\tvalue:UriComponent.Value|IEnumerableOrArray<UriComponent.Value>):void\r\n{\r\n\tif(isEnumerableOrArrayLike(value))\r\n\t{\r\n\t\tforEach(value, v=> appendKeyValueSingle(entries, key, v));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tappendKeyValueSingle(entries, key, value)\r\n\t}\r\n}\r\n\r\n/**\r\n * Converts any primitive, serializable or uri-component object to an encoded string.\r\n * @param value\r\n * @returns {string}\r\n */\r\nexport function encodeValue(value:UriComponent.Value):string\r\n{\r\n\tif(isUriComponentFormattable(value))\r\n\t{\r\n\t\tconst v:string = value.toUriComponent();\r\n\t\tif(v && v.indexOf(ENTRY_SEPARATOR)!=1)\r\n\t\t\tthrow '.toUriComponent() did not encode the value.';\r\n\t\treturn v;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn encodeURIComponent(Serialize.toString(value));\r\n\t}\r\n}\r\n\r\n/**\r\n * A shortcut for identifying an UriComponent.Formattable object.\r\n * @param instance\r\n * @returns {boolean}\r\n */\r\nexport function isUriComponentFormattable(instance:any):instance is UriComponent.Formattable\r\n{\r\n\treturn Type.hasMemberOfType<UriComponent.Formattable>(instance, TO_URI_COMPONENT, Type.FUNCTION);\r\n}\r\n\r\n/**\r\n * Parses a string for valid query param entries and pipes them through a handler.\r\n * @param query\r\n * @param entryHandler\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n */\r\nexport function parse(\r\n\tquery:string,\r\n\tentryHandler:(key:string, value:Primitive)=>void,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):void\r\n{\r\n\tif(query && (query = query.replace(/^\\s*\\?+/, '')))\r\n\t{\r\n\t\tconst entries = query.split(ENTRY_SEPARATOR);\r\n\t\tfor(let entry of entries)\r\n\t\t{\r\n\t\t\t/*\r\n\t\t\t * Since it is technically possible to have multiple '=' we need to identify the first one.\r\n\t\t\t * And if there is no '=' then the entry is ignored.\r\n\t\t\t */\r\n\t\t\tconst si = entry.indexOf(KEY_VALUE_SEPARATOR);\r\n\t\t\tif(si!= -1)\r\n\t\t\t{\r\n\t\t\t\tlet key = entry.substring(0, si);\r\n\t\t\t\tlet value = <any>entry.substring(si + 1);\r\n\t\t\t\tif(decodeValues) value = decodeURIComponent(value);\r\n\t\t\t\tif(deserialize) value = Serialize.toPrimitive(value);\r\n\t\t\t\tentryHandler(key, value);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Parses a string for valid query params and returns a key-value map of the entries.\r\n * @param query\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n * @returns {IMap<Primitive>}\r\n */\r\nexport function parseToMap(\r\n\tquery:string,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):IMap<Primitive|Primitive[]>\r\n{\r\n\tconst result:IMap<Primitive|Primitive[]> = {};\r\n\tparse(query,\r\n\t\t(key, value)=>\r\n\t\t{\r\n\t\t\tif((key) in (result))\r\n\t\t\t{\r\n\t\t\t\tlet prev:any = result[key];\r\n\t\t\t\tif(!((prev)instanceof(Array)))\r\n\t\t\t\t\tresult[key] = prev = [prev];\r\n\t\t\t\tprev.push(value);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tresult[key] = value;\r\n\t\t},\r\n\t\tdeserialize,\r\n\t\tdecodeValues);\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Parses a string for valid query params and returns a key-value pair array of the entries.\r\n * @param query\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n * @returns {IKeyValuePair<string, Primitive>[]}\r\n */\r\nexport function parseToArray(\r\n\tquery:string,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):IStringKeyValuePair<Primitive>[]\r\n{\r\n\tconst result:IStringKeyValuePair<Primitive>[] = [];\r\n\tparse(query,\r\n\t\t(key, value)=> {result.push({key: key, value: value});},\r\n\t\tdeserialize,\r\n\t\tdecodeValues\r\n\t);\r\n\treturn result;\r\n}\r\n\r\n\r\nexport module Separator\r\n{\r\n\texport const Query:string = QUERY_SEPARATOR;\r\n\texport const Entry:string = ENTRY_SEPARATOR;\r\n\texport const KeyValue:string = KEY_VALUE_SEPARATOR;\r\n}\r\nObject.freeze(Separator);\r\n\r\n"]}
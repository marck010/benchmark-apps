{"version":3,"sources":["System/Uri/Uri.js","System/Uri/Uri.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","copyUri","from","to","field","i","Fields","value","getScheme","scheme","s","Types_1","Type","isString","Utility_1","trim","toLowerCase","replace","EMPTY","Scheme_1","Scheme","isValid","ArgumentOutOfRangeException_1","ArgumentOutOfRangeException","getPort","port","p","isNumber","isFinite","parseInt","isNaN","ArgumentException_1","ArgumentException","getAuthority","uri","host","userInfo","result","AT","SLASH2","formatQuery","query","indexOf","QM","formatFragment","fragment","HASH","getPathAndQuery","path","uriToString","authority","pathAndQuery","part1","part2","SLASH","tryParse","url","out","substring","VOID0","c","test","ex","Object","defineProperty","QueryParams_1","Uri","_","this","encode","freeze","queryParams","parseToMap","absoluteUri","getAbsoluteUri","baseUri","prototype","equals","other","toString","defaults","u","parse","throwIfInvalid","copyOf","map","copyTo","updateQuery","toMap","get","match","enumerable","configurable","Separator","Query"],"mappings":"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","file":"Uri.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Based on: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../Types\", \"./Scheme\", \"./QueryParams\", \"../Text/Utility\", \"../Exceptions/ArgumentException\", \"../Exceptions/ArgumentOutOfRangeException\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Types_1 = require(\"../Types\");\n    var Scheme_1 = require(\"./Scheme\");\n    var QueryParams_1 = require(\"./QueryParams\");\n    var Utility_1 = require(\"../Text/Utility\");\n    var ArgumentException_1 = require(\"../Exceptions/ArgumentException\");\n    var ArgumentOutOfRangeException_1 = require(\"../Exceptions/ArgumentOutOfRangeException\");\n    var VOID0 = void 0;\n    /**\n     * Provides an read-only model representation of a uniform resource identifier (URI) and easy access to the parts of the URI.\n     *\n     * The read-only model (frozen) is easier for debugging than exposing accessors for each property.\n     * ICloneable&lt;Uri&gt; is not used to prevent unnecessary copying of values that won't change.\n     */\n    var Uri = /** @class */ (function () {\n        /**\n         * @param scheme The user name, password, or other user-specific information associated with the specified URI.\n         * @param userInfo The host component of this instance.\n         * @param host The port number of this URI.\n         * @param port The absolute path of the URI.\n         * @param path The absolute path of the URI.\n         * @param query Any query information included in the specified URI.\n         * @param fragment The escaped URI fragment.\n         */\n        function Uri(scheme, userInfo, host, port, path, query, fragment) {\n            var _ = this;\n            this.scheme = getScheme(scheme) || null;\n            this.userInfo = userInfo || null;\n            this.host = host || null;\n            this.port = getPort(port);\n            this.authority = _.getAuthority() || null;\n            this.path = path || null;\n            if (!Types_1.Type.isString(query))\n                query = QueryParams_1.encode(query);\n            this.query = formatQuery(query) || null;\n            Object.freeze(this.queryParams\n                = _.query\n                    ? QueryParams_1.parseToMap(_.query)\n                    : {});\n            this.pathAndQuery = _.getPathAndQuery() || null;\n            this.fragment = formatFragment(fragment) || null;\n            // This should validate the uri...\n            this.absoluteUri = _.getAbsoluteUri();\n            this.baseUri = _.absoluteUri.replace(/[?#].*/, '');\n            // Intended to be read-only.  Call .toMap() to get a writable copy.\n            Object.freeze(this);\n        }\n        /**\n         *  Compares the values of another IUri via toString comparison.\n         * @param other\n         * @returns {boolean}\n         */\n        Uri.prototype.equals = function (other) {\n            return this === other || this.absoluteUri == Uri.toString(other);\n        };\n        /**\n         * Parses or clones values from existing Uri values.\n         * @param uri\n         * @param defaults\n         * @returns {Uri}\n         */\n        Uri.from = function (uri, defaults) {\n            var u = Types_1.Type.isString(uri)\n                ? Uri.parse(uri) // Parsing a string should throw errors.  Null or undefined simply means empty.\n                : uri;\n            return new Uri(u && u.scheme || defaults && defaults.scheme, u && u.userInfo || defaults && defaults.userInfo, u && u.host || defaults && defaults.host, u && Types_1.Type.isNumber(u.port, true) ? u.port : defaults && defaults.port, u && u.path || defaults && defaults.path, u && u.query || defaults && defaults.query, u && u.fragment || defaults && defaults.fragment);\n        };\n        Uri.parse = function (url, throwIfInvalid) {\n            if (throwIfInvalid === void 0) { throwIfInvalid = true; }\n            var result = null;\n            var ex = tryParse(url, function (out) { result = out; });\n            if (throwIfInvalid && ex)\n                throw ex;\n            return result;\n        };\n        /**\n         * Parses a URL into it's components.\n         * @param url The url to parse.\n         * @param out A delegate to capture the value.\n         * @returns {boolean} True if valid.  False if invalid.\n         */\n        Uri.tryParse = function (url, out) {\n            return !tryParse(url, out); // return type is Exception.\n        };\n        Uri.copyOf = function (map) {\n            return copyUri(map);\n        };\n        Uri.prototype.copyTo = function (map) {\n            return copyUri(this, map);\n        };\n        Uri.prototype.updateQuery = function (query) {\n            var map = this.toMap();\n            map.query = query;\n            return Uri.from(map);\n        };\n        /**\n         * Is provided for sub classes to override this value.\n         */\n        Uri.prototype.getAbsoluteUri = function () {\n            return uriToString(this);\n        };\n        /**\n         * Is provided for sub classes to override this value.\n         */\n        Uri.prototype.getAuthority = function () {\n            return getAuthority(this);\n        };\n        /**\n         * Is provided for sub classes to override this value.\n         */\n        Uri.prototype.getPathAndQuery = function () {\n            return getPathAndQuery(this);\n        };\n        Object.defineProperty(Uri.prototype, \"pathSegments\", {\n            /**\n             * The segments that represent a path.<br/>\n             * https://msdn.microsoft.com/en-us/library/system.uri.segments%28v=vs.110%29.aspx\n             *\n             * <h5><b>Example:</b></h5>\n             * If the path value equals: ```/tree/node/index.html```<br/>\n             * The result will be: ```['/','tree/','node/','index.html']```\n             * @returns {string[]}\n             */\n            get: function () {\n                return this.path\n                    && this.path.match(/^[/]|[^/]*[/]|[^/]+$/g)\n                    || [];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Creates a writable copy.\n         * @returns {IUri}\n         */\n        Uri.prototype.toMap = function () {\n            return this.copyTo({});\n        };\n        /**\n         * @returns {string} The full absolute uri.\n         */\n        Uri.prototype.toString = function () {\n            return this.absoluteUri;\n        };\n        /**\n         * Properly converts an existing URI to a string.\n         * @param uri\n         * @returns {string}\n         */\n        Uri.toString = function (uri) {\n            return uri instanceof Uri\n                ? uri.absoluteUri\n                : uriToString(uri);\n        };\n        /**\n         * Returns the authority segment of an URI.\n         * @param uri\n         * @returns {string}\n         */\n        Uri.getAuthority = function (uri) {\n            return getAuthority(uri);\n        };\n        return Uri;\n    }());\n    exports.Uri = Uri;\n    var Fields;\n    (function (Fields) {\n        Fields[Fields[\"scheme\"] = 0] = \"scheme\";\n        Fields[Fields[\"userInfo\"] = 1] = \"userInfo\";\n        Fields[Fields[\"host\"] = 2] = \"host\";\n        Fields[Fields[\"port\"] = 3] = \"port\";\n        Fields[Fields[\"path\"] = 4] = \"path\";\n        Fields[Fields[\"query\"] = 5] = \"query\";\n        Fields[Fields[\"fragment\"] = 6] = \"fragment\";\n    })(Fields = exports.Fields || (exports.Fields = {}));\n    Object.freeze(Fields);\n    function copyUri(from, to) {\n        var i = 0, field;\n        if (!to)\n            to = {};\n        while (field = Fields[i++]) {\n            var value = from[field];\n            if (value)\n                to[field] = value;\n        }\n        return to;\n    }\n    var SLASH = '/', SLASH2 = '//', QM = QueryParams_1.Separator.Query, HASH = '#', EMPTY = '', AT = '@';\n    function getScheme(scheme) {\n        var s = scheme;\n        if (Types_1.Type.isString(s)) {\n            if (!s)\n                return null;\n            s = Utility_1.trim(s)\n                .toLowerCase()\n                .replace(/[^a-z0-9+.-]+$/g, EMPTY);\n            if (!s)\n                return null;\n            if (Scheme_1.Scheme.isValid(s))\n                return s;\n        }\n        else {\n            if (s == null)\n                return s;\n        }\n        throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('scheme', scheme, 'Invalid scheme.');\n    }\n    function getPort(port) {\n        if (port === 0)\n            return port;\n        if (!port)\n            return null;\n        var p;\n        if (Types_1.Type.isNumber(port)) {\n            p = port;\n            if (p >= 0 && isFinite(p))\n                return p;\n        }\n        else if (Types_1.Type.isString(port) && (p = parseInt(port)) && !isNaN(p)) {\n            return getPort(p);\n        }\n        throw new ArgumentException_1.ArgumentException(\"port\", \"invalid value\");\n    }\n    function getAuthority(uri) {\n        if (!uri.host) {\n            if (uri.userInfo)\n                throw new ArgumentException_1.ArgumentException('host', 'Cannot include user info when there is no host.');\n            if (Types_1.Type.isNumber(uri.port, true))\n                throw new ArgumentException_1.ArgumentException('host', 'Cannot include a port when there is no host.');\n        }\n        /*\n         * [//[user:password@]host[:port]]\n         */\n        var result = uri.host || EMPTY;\n        if (result) {\n            if (uri.userInfo)\n                result = uri.userInfo + AT + result;\n            if (!isNaN((uri.port)))\n                result += ':' + uri.port;\n            result = SLASH2 + result;\n        }\n        return result;\n    }\n    function formatQuery(query) {\n        return query && ((query.indexOf(QM) !== 0 ? QM : EMPTY) + query);\n    }\n    function formatFragment(fragment) {\n        return fragment && ((fragment.indexOf(HASH) !== 0 ? HASH : EMPTY) + fragment);\n    }\n    function getPathAndQuery(uri) {\n        var path = uri.path, query = uri.query;\n        return EMPTY\n            + (path || EMPTY)\n            + (formatQuery(query) || EMPTY);\n    }\n    function uriToString(uri) {\n        // scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\n        // {scheme}{authority}{path}{query}{fragment}\n        var scheme = getScheme(uri.scheme);\n        var authority = getAuthority(uri);\n        var pathAndQuery = getPathAndQuery(uri), fragment = formatFragment(uri.fragment);\n        var part1 = EMPTY\n            + ((scheme && (scheme + ':')) || EMPTY)\n            + (authority || EMPTY);\n        var part2 = EMPTY\n            + (pathAndQuery || EMPTY)\n            + (fragment || EMPTY);\n        if (part1 && part2 && scheme && !authority)\n            throw new ArgumentException_1.ArgumentException('authority', \"Cannot format schemed Uri with missing authority.\");\n        if (part1 && pathAndQuery && pathAndQuery.indexOf(SLASH) !== 0)\n            part2 = SLASH + part2;\n        return part1 + part2;\n    }\n    function tryParse(url, out) {\n        if (!url)\n            return new ArgumentException_1.ArgumentException('url', 'Nothing to parse.');\n        // Could use a regex here, but well follow some rules instead.\n        // The intention is to 'gather' the pieces.  This isn't validation (yet).\n        // scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\n        var i;\n        var result = {};\n        // Anything after the first # is the fragment.\n        i = url.indexOf(HASH);\n        if (i != -1) {\n            result.fragment = url.substring(i + 1) || VOID0;\n            url = url.substring(0, i);\n        }\n        // Anything after the first ? is the query.\n        i = url.indexOf(QM);\n        if (i != -1) {\n            result.query = url.substring(i + 1) || VOID0;\n            url = url.substring(0, i);\n        }\n        // Guarantees a separation.\n        i = url.indexOf(SLASH2);\n        if (i != -1) {\n            var scheme = Utility_1.trim(url.substring(0, i));\n            var c = /:$/;\n            if (!c.test(scheme))\n                return new ArgumentException_1.ArgumentException('url', 'Scheme was improperly formatted');\n            scheme = Utility_1.trim(scheme.replace(c, EMPTY));\n            try {\n                result.scheme = getScheme(scheme) || VOID0;\n            }\n            catch (ex) {\n                return ex;\n            }\n            url = url.substring(i + 2);\n        }\n        // Find any path information.\n        i = url.indexOf(SLASH);\n        if (i != -1) {\n            result.path = url.substring(i);\n            url = url.substring(0, i);\n        }\n        // Separate user info.\n        i = url.indexOf(AT);\n        if (i != -1) {\n            result.userInfo = url.substring(0, i) || VOID0;\n            url = url.substring(i + 1);\n        }\n        // Remaining is host and port.\n        i = url.indexOf(':');\n        if (i != -1) {\n            var port = parseInt(Utility_1.trim(url.substring(i + 1)));\n            if (isNaN(port))\n                return new ArgumentException_1.ArgumentException('url', 'Port was invalid.');\n            result.port = port;\n            url = url.substring(0, i);\n        }\n        url = Utility_1.trim(url);\n        if (url)\n            result.host = url;\n        out(copyUri(result));\n        // null is good! (here)\n        return null;\n    }\n    exports.default = Uri;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier\r\n */\r\n\r\nimport {Type} from \"../Types\";\r\nimport {UriComponent} from \"./UriComponent\";\r\nimport {Scheme} from \"./Scheme\";\r\nimport {SchemeValue} from \"./SchemeValue\";\r\nimport {QueryParam} from \"./QueryParam\";\r\nimport {encode, parseToMap, Separator} from \"./QueryParams\";\r\nimport {trim} from \"../Text/Utility\";\r\nimport {Exception} from \"../Exception\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentOutOfRangeException} from \"../Exceptions/ArgumentOutOfRangeException\";\r\nimport {IUri} from \"./IUri\";\r\nimport {IMap} from \"../../IMap\";\r\nimport {Primitive} from \"../Primitive\";\r\nimport {StringKeyValuePair} from \"../KeyValuePair\";\r\nimport {IEquatable} from \"../IEquatable\";\r\nimport {Action} from \"../FunctionTypes\";\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\n/**\r\n * Provides an read-only model representation of a uniform resource identifier (URI) and easy access to the parts of the URI.\r\n *\r\n * The read-only model (frozen) is easier for debugging than exposing accessors for each property.\r\n * ICloneable&lt;Uri&gt; is not used to prevent unnecessary copying of values that won't change.\r\n */\r\nexport class Uri implements IUri, IEquatable<IUri>\r\n{\r\n\r\n\treadonly scheme:SchemeValue.Any | null;\r\n\treadonly userInfo:string | null;\r\n\treadonly host:string | null;\r\n\treadonly port:number | null;\r\n\treadonly path:string | null;\r\n\treadonly query:string | null;\r\n\treadonly fragment:string | null;\r\n\r\n\treadonly queryParams:IMap<Primitive|Primitive[]>;//Readonly<IMap<Primitive|Primitive[]>>;\r\n\r\n\t/**\r\n\t * @param scheme The user name, password, or other user-specific information associated with the specified URI.\r\n\t * @param userInfo The host component of this instance.\r\n\t * @param host The port number of this URI.\r\n\t * @param port The absolute path of the URI.\r\n\t * @param path The absolute path of the URI.\r\n\t * @param query Any query information included in the specified URI.\r\n\t * @param fragment The escaped URI fragment.\r\n\t */\r\n\tconstructor(\r\n\t\tscheme:SchemeValue.Any|null,\r\n\t\tuserInfo:string|null,\r\n\t\thost:string|null,\r\n\t\tport:number|null,\r\n\t\tpath:string|null,\r\n\t\tquery?:QueryParam.Convertible,\r\n\t\tfragment?:string)\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tthis.scheme = getScheme(scheme) || null;\r\n\t\tthis.userInfo = userInfo || null;\r\n\t\tthis.host = host || null;\r\n\r\n\t\tthis.port = getPort(port);\r\n\r\n\t\tthis.authority = _.getAuthority() || null;\r\n\r\n\t\tthis.path = path || null;\r\n\r\n\r\n\t\tif(!Type.isString(query))\r\n\t\t\tquery = encode(<UriComponent.Map|StringKeyValuePair<Primitive>[]>query);\r\n\r\n\t\tthis.query = formatQuery(<string>query) || null;\r\n\t\tObject.freeze(this.queryParams\r\n\t\t\t= _.query\r\n\t\t\t? parseToMap(_.query)\r\n\t\t\t: {});\r\n\r\n\t\tthis.pathAndQuery = _.getPathAndQuery() || null;\r\n\r\n\t\tthis.fragment = formatFragment(fragment) || null;\r\n\r\n\t\t// This should validate the uri...\r\n\t\tthis.absoluteUri = _.getAbsoluteUri();\r\n\r\n\t\tthis.baseUri = _.absoluteUri.replace(/[?#].*/, '');\r\n\r\n\t\t// Intended to be read-only.  Call .toMap() to get a writable copy.\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\t/**\r\n\t *  Compares the values of another IUri via toString comparison.\r\n\t * @param other\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(other:IUri):boolean\r\n\t{\r\n\t\treturn this===other || this.absoluteUri==Uri.toString(other);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Parses or clones values from existing Uri values.\r\n\t * @param uri\r\n\t * @param defaults\r\n\t * @returns {Uri}\r\n\t */\r\n\tstatic from(uri:string|IUri|null|undefined, defaults?:IUri):Uri\r\n\t{\r\n\t\tconst u = Type.isString(uri)\r\n\t\t\t? Uri.parse(<string>uri) // Parsing a string should throw errors.  Null or undefined simply means empty.\r\n\t\t\t: <IUri>uri;\r\n\r\n\t\treturn new Uri(\r\n\t\t\tu && u.scheme || defaults && <any>defaults.scheme,\r\n\t\t\tu && u.userInfo || defaults && <any>defaults.userInfo,\r\n\t\t\tu && u.host || defaults && <any>defaults.host,\r\n\t\t\tu && Type.isNumber(u.port,true) ? u.port : defaults && <any>defaults.port,\r\n\t\t\tu && u.path || defaults && <any>defaults.path,\r\n\t\t\tu && u.query || defaults && <any>defaults.query,\r\n\t\t\tu && u.fragment || defaults && <any>defaults.fragment\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Parses a URL into it's components.\r\n\t * @param url The url to parse.\r\n\t * @returns {IUri} Will throw an exception if not able to parse.\r\n\t */\r\n\tstatic parse(url:string):IUri\r\n\r\n\tstatic parse(url:string, throwIfInvalid:true):IUri\r\n\r\n\t/**\r\n\t * Parses a URL into it's components.\r\n\t * @param url The url to parse.\r\n\t * @param throwIfInvalid Defaults to true.\r\n\t * @returns {IUri} Returns a map of the values or *null* if invalid and *throwIfInvalid* is <b>false</b>.\r\n\t */\r\n\tstatic parse(url:string, throwIfInvalid:boolean):IUri|null\r\n\tstatic parse(url:string, throwIfInvalid:boolean = true):IUri|null\r\n\t{\r\n\t\tlet result:IUri|null = null;\r\n\t\tconst ex = tryParse(url, (out) => {result = out;});\r\n\t\tif(throwIfInvalid && ex) throw ex;\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses a URL into it's components.\r\n\t * @param url The url to parse.\r\n\t * @param out A delegate to capture the value.\r\n\t * @returns {boolean} True if valid.  False if invalid.\r\n\t */\r\n\tstatic tryParse(url:string, out:(result:IUri)=>void):boolean\r\n\t{\r\n\t\treturn !tryParse(url, out); // return type is Exception.\r\n\t}\r\n\r\n\tstatic copyOf(map:IUri):IUri\r\n\t{\r\n\t\treturn copyUri(map);\r\n\t}\r\n\r\n\tcopyTo(map:IUri):IUri\r\n\t{\r\n\t\treturn copyUri(this, map);\r\n\t}\r\n\r\n\tupdateQuery(query:QueryParam.Convertible):Uri\r\n\t{\r\n\t\tconst map = this.toMap();\r\n\t\tmap.query = <any>query;\r\n\t\treturn Uri.from(map);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getAbsoluteUri():string\r\n\t{\r\n\t\treturn uriToString(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getAuthority():string\r\n\t{\r\n\t\treturn getAuthority(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getPathAndQuery():string\r\n\t{\r\n\t\treturn getPathAndQuery(this);\r\n\t}\r\n\r\n\t/**\r\n\t * The absolute URI.\r\n\t */\r\n\tabsoluteUri:string;\r\n\r\n\t/**\r\n\t * Gets the Domain Name System (DNS) host name or IP address and the port number for a server.\r\n\t */\r\n\treadonly authority:string | null;\r\n\r\n\t/**\r\n\t * Gets the path and Query properties separated by a question mark (?).\r\n\t */\r\n\treadonly pathAndQuery:string | null;\r\n\r\n\t/**\r\n\t * Gets the full path without the query or fragment.\r\n\t */\r\n\treadonly baseUri:string;\r\n\r\n\t/**\r\n\t * The segments that represent a path.<br/>\r\n\t * https://msdn.microsoft.com/en-us/library/system.uri.segments%28v=vs.110%29.aspx\r\n\t *\r\n\t * <h5><b>Example:</b></h5>\r\n\t * If the path value equals: ```/tree/node/index.html```<br/>\r\n\t * The result will be: ```['/','tree/','node/','index.html']```\r\n\t * @returns {string[]}\r\n\t */\r\n\tget pathSegments():string[]\r\n\t{\r\n\t\treturn this.path\r\n\t\t\t&& this.path.match(/^[/]|[^/]*[/]|[^/]+$/g)\r\n\t\t\t|| [];\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a writable copy.\r\n\t * @returns {IUri}\r\n\t */\r\n\ttoMap():IUri\r\n\t{\r\n\t\treturn this.copyTo({});\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {string} The full absolute uri.\r\n\t */\r\n\ttoString():string\r\n\t{\r\n\t\treturn this.absoluteUri;\r\n\t}\r\n\r\n\t/**\r\n\t * Properly converts an existing URI to a string.\r\n\t * @param uri\r\n\t * @returns {string}\r\n\t */\r\n\tstatic toString(uri:IUri):string\r\n\t{\r\n\t\treturn uri instanceof <any>Uri\r\n\t\t\t? (<Uri>uri).absoluteUri\r\n\t\t\t: uriToString(uri);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the authority segment of an URI.\r\n\t * @param uri\r\n\t * @returns {string}\r\n\t */\r\n\tstatic getAuthority(uri:IUri):string\r\n\t{\r\n\t\treturn getAuthority(uri);\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport enum Fields {\r\n\tscheme,\r\n\tuserInfo,\r\n\thost,\r\n\tport,\r\n\tpath,\r\n\tquery,\r\n\tfragment\r\n}\r\nObject.freeze(Fields);\r\n\r\nfunction copyUri(from:IUri, to?:IUri)\r\n{\r\n\tlet i = 0, field:string;\r\n\tif(!to) to = {};\r\n\twhile(field = Fields[i++])\r\n\t{\r\n\t\tconst value = (<any>from)[field];\r\n\t\tif(value) (<any>to)[field] = value;\r\n\t}\r\n\treturn to;\r\n}\r\n\r\nconst SLASH = '/', SLASH2 = '//', QM = Separator.Query, HASH = '#', EMPTY = '', AT = '@';\r\n\r\nfunction getScheme(scheme:SchemeValue.Any|string|null|undefined):SchemeValue.Any|null\r\n{\r\n\tlet s:any = scheme;\r\n\tif(Type.isString(s))\r\n\t{\r\n\t\tif(!s) return null;\r\n\t\ts = trim(s)\r\n\t\t\t.toLowerCase()\r\n\t\t\t.replace(/[^a-z0-9+.-]+$/g, EMPTY);\r\n\t\tif(!s) return null;\r\n\t\tif(Scheme.isValid(s)) return s;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif(s==null) return s;\r\n\t}\r\n\tthrow new ArgumentOutOfRangeException('scheme', scheme, 'Invalid scheme.');\r\n}\r\n\r\nfunction getPort(port:number|string|null|undefined):number|null\r\n{\r\n\tif(port===0) return <number>port;\r\n\tif(!port) return null;\r\n\tlet p:number;\r\n\r\n\tif(Type.isNumber(port))\r\n\t{\r\n\t\tp = <number>port;\r\n\t\tif(p>=0 && isFinite(p))\r\n\t\t\treturn p;\r\n\t}\r\n\telse if(Type.isString(port) && (p = parseInt(<string>port)) && !isNaN(p))\r\n\t{\r\n\t\treturn getPort(p);\r\n\t}\r\n\r\n\tthrow new ArgumentException(\"port\", \"invalid value\");\r\n}\r\n\r\nfunction getAuthority(uri:IUri):string\r\n{\r\n\r\n\tif(!uri.host)\r\n\t{\r\n\t\tif(uri.userInfo)\r\n\t\t\tthrow new ArgumentException('host', 'Cannot include user info when there is no host.');\r\n\r\n\t\tif(Type.isNumber(uri.port, true))\r\n\t\t\tthrow new ArgumentException('host', 'Cannot include a port when there is no host.');\r\n\t}\r\n\r\n\t/*\r\n\t * [//[user:password@]host[:port]]\r\n\t */\r\n\r\n\tlet result = uri.host || EMPTY;\r\n\r\n\tif(result)\r\n\t{\r\n\t\tif(uri.userInfo) result = uri.userInfo + AT + result;\r\n\t\tif(!isNaN(<any>(uri.port))) result += ':' + uri.port;\r\n\t\tresult = SLASH2 + result;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction formatQuery(query:string|null|undefined):string|null|undefined\r\n{\r\n\treturn query && ((query.indexOf(QM)!==0 ? QM : EMPTY) + query);\r\n}\r\n\r\nfunction formatFragment(fragment:string|null|undefined):string|null|undefined\r\n{\r\n\treturn fragment && ((fragment.indexOf(HASH)!==0 ? HASH : EMPTY) + fragment);\r\n}\r\n\r\nfunction getPathAndQuery(uri:IUri):string\r\n{\r\n\r\n\tconst path  = uri.path,\r\n\t      query = uri.query;\r\n\r\n\treturn EMPTY\r\n\t\t+ (path || EMPTY)\r\n\t\t+ (formatQuery(query) || EMPTY);\r\n\r\n}\r\n\r\nfunction uriToString(uri:IUri):string\r\n{\r\n\t// scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\r\n\t// {scheme}{authority}{path}{query}{fragment}\r\n\r\n\tconst scheme = getScheme(uri.scheme);\r\n\tlet authority = getAuthority(uri);\r\n\tconst pathAndQuery = getPathAndQuery(uri),\r\n\t      fragment     = formatFragment(uri.fragment);\r\n\r\n\tconst part1 = EMPTY\r\n\t\t+ ((scheme && (scheme + ':')) || EMPTY)\r\n\t\t+ (authority || EMPTY);\r\n\r\n\tlet part2 = EMPTY\r\n\t\t+ (pathAndQuery || EMPTY)\r\n\t\t+ (fragment || EMPTY);\r\n\r\n\tif(part1 && part2 && scheme && !authority)\r\n\t\tthrow new ArgumentException('authority', \"Cannot format schemed Uri with missing authority.\");\r\n\r\n\tif(part1 && pathAndQuery && pathAndQuery.indexOf(SLASH)!==0)\r\n\t\tpart2 = SLASH + part2;\r\n\r\n\treturn part1 + part2;\r\n\r\n}\r\n\r\n\r\nfunction tryParse(url:string, out:Action<IUri>):null|Exception\r\n{\r\n\tif(!url)\r\n\t\treturn new ArgumentException('url', 'Nothing to parse.');\r\n\r\n\r\n\t// Could use a regex here, but well follow some rules instead.\r\n\t// The intention is to 'gather' the pieces.  This isn't validation (yet).\r\n\r\n\t// scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\r\n\tlet i:number;\r\n\tconst result:IUri = {};\r\n\r\n\t// Anything after the first # is the fragment.\r\n\ti = url.indexOf(HASH);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.fragment = url.substring(i + 1) || VOID0;\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Anything after the first ? is the query.\r\n\ti = url.indexOf(QM);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.query = url.substring(i + 1) || VOID0;\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Guarantees a separation.\r\n\ti = url.indexOf(SLASH2);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tlet scheme = trim(url.substring(0, i));\r\n\t\tconst c = /:$/;\r\n\t\tif(!c.test(scheme))\r\n\t\t\treturn new ArgumentException('url', 'Scheme was improperly formatted');\r\n\r\n\t\tscheme = trim(scheme.replace(c, EMPTY));\r\n\t\ttry\r\n\t\t{\r\n\t\t\tresult.scheme = getScheme(scheme) || VOID0;\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\treturn ex;\r\n\t\t}\r\n\r\n\t\turl = url.substring(i + 2);\r\n\t}\r\n\r\n\t// Find any path information.\r\n\ti = url.indexOf(SLASH);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.path = url.substring(i);\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Separate user info.\r\n\ti = url.indexOf(AT);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.userInfo = url.substring(0, i) || VOID0;\r\n\t\turl = url.substring(i + 1);\r\n\t}\r\n\r\n\t// Remaining is host and port.\r\n\ti = url.indexOf(':');\r\n\tif(i!= -1)\r\n\t{\r\n\t\tconst port = parseInt(trim(url.substring(i + 1)));\r\n\t\tif(isNaN(port))\r\n\t\t\treturn new ArgumentException('url', 'Port was invalid.');\r\n\r\n\t\tresult.port = port;\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\turl = trim(url);\r\n\tif(url)\r\n\t\tresult.host = url;\r\n\r\n\tout(copyUri(result));\r\n\r\n\t// null is good! (here)\r\n\treturn null;\r\n\r\n}\r\n\r\nexport default Uri;"]}
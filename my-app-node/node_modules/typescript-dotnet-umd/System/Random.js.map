{"version":3,"sources":["System/Random.js","System/Random.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Object","defineProperty","value","Random","Integer_1","initialize_1","shuffle_1","assert","Integer","r","maxExclusive","Math","floor","random","nr","boundary","inclusive","a","abs","arrayCopy","source","len","length","result","initialize","i","integer","next","generate","integers","count","s","shuffle","target","copy","select","maxCount","Infinity","assertZeroOrGreater","one","float","Number","MAX_VALUE","isNaN","inRange","min","max","range","throwIfEmpty"],"mappings":"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","file":"Random.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./Integer\", \"./Collections/Array/initialize\", \"./Collections/Array/shuffle\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Integer_1 = require(\"./Integer\");\n    var initialize_1 = require(\"./Collections/Array/initialize\");\n    var shuffle_1 = require(\"./Collections/Array/shuffle\");\n    var assert = Integer_1.Integer.assert;\n    /**\n     * This module only acts as a utility API for getting random numbers from Math.random().\n     * If you need repeatable seeded random numbers then you'll need a separate utility.\n     * Highly recommended: https://github.com/ckknight/random-js which has typings under @types/random-js.\n     */\n    var Random;\n    (function (Random) {\n        function r(maxExclusive) {\n            if (maxExclusive === void 0) { maxExclusive = 1; }\n            return Math.floor(Math.random() * maxExclusive);\n        }\n        function nr(boundary, inclusive) {\n            var a = Math.abs(boundary);\n            if (a === 0 || a === 1 && !inclusive)\n                return 0;\n            if (inclusive)\n                boundary += boundary / a;\n            return r(boundary);\n        }\n        function arrayCopy(source) {\n            var len = source.length;\n            var result = initialize_1.initialize(len);\n            for (var i = 0; i < len; i++) {\n                result[i] = source[i];\n            }\n            return result;\n        }\n        /**\n         * Returns a random integer from 0 to the maxExclusive.\n         * Negative numbers are allowed.\n         *\n         * @param maxExclusive\n         * @returns {number}\n         */\n        function integer(maxExclusive) {\n            return next(maxExclusive);\n        }\n        Random.integer = integer;\n        /**\n         * Returns a function that generates random floating point numbers up to the maxExclusive value.\n         * Useful for generating a random and memoizable set for use with other enumerables.\n         * @param maxExclusive\n         * @returns {()=>number}\n         */\n        function generate(maxExclusive) {\n            if (maxExclusive === void 0) { maxExclusive = 1; }\n            return function () { return r(maxExclusive); };\n        }\n        Random.generate = generate;\n        (function (generate) {\n            /**\n             * Returns a function that generates random integers up to the boundary.\n             * Useful for generating a random and memoizable set for use with other enumerables.\n             * @param boundary\n             * @param inclusive\n             * @returns {()=>number}\n             */\n            function integers(boundary, inclusive) {\n                return function () { return nr(boundary, inclusive); };\n            }\n            generate.integers = integers;\n        })(generate = Random.generate || (Random.generate = {}));\n        /**\n         * Returns a random integer from 0 to the boundary.\n         * Return value will be less than the boundary unless inclusive is set to true.\n         * Negative numbers are allowed.\n         *\n         * @param boundary\n         * @param inclusive\n         * @returns {number}\n         */\n        function next(boundary, inclusive) {\n            assert(boundary, 'boundary');\n            return nr(boundary, inclusive);\n        }\n        Random.next = next;\n        (function (next) {\n            function integer(boundary, inclusive) {\n                return Random.next(boundary, inclusive);\n            }\n            next.integer = integer;\n            function float(boundary) {\n                if (boundary === void 0) { boundary = Number.MAX_VALUE; }\n                if (isNaN(boundary))\n                    throw \"'boundary' is not a number.\";\n                return Math.random() * boundary;\n            }\n            next.float = float;\n            function inRange(min, max, inclusive) {\n                assert(min, 'min');\n                assert(max, 'max');\n                var range = max - min;\n                if (range === 0)\n                    return min;\n                if (inclusive)\n                    range += range / Math.abs(range);\n                return min + r(range);\n            }\n            next.inRange = inRange;\n        })(next = Random.next || (Random.next = {}));\n        /**\n         * Returns an array of random integers.\n         * @param count\n         * @param boundary\n         * @param inclusive\n         * @returns {number[]}\n         */\n        function integers(count, boundary, inclusive) {\n            assert(count);\n            var s = [];\n            s.length = count;\n            for (var i = 0; i < count; i++) {\n                s[i] = nr(boundary, inclusive);\n            }\n            return s;\n        }\n        Random.integers = integers;\n        /**\n         * Shuffles an array.\n         * @param target\n         * @returns {T}\n         */\n        function shuffle(target) {\n            return shuffle_1.shuffle(target);\n        }\n        Random.shuffle = shuffle;\n        /**\n         * Creates a copy of an array-like  and returns it shuffled.\n         * @param source\n         * @returns {T[]}\n         */\n        function copy(source) {\n            return shuffle_1.shuffle(arrayCopy(source));\n        }\n        Random.copy = copy;\n        /**\n         * Returns a distinct random set from the source array up to the maxCount or the full length of the array.\n         * @param source\n         * @param maxCount\n         * @returns {any}\n         */\n        function select(source, maxCount) {\n            if (maxCount !== Infinity)\n                Integer_1.Integer.assertZeroOrGreater(maxCount);\n            switch (maxCount) {\n                case 0:\n                    return [];\n                case 1:\n                    return [select.one(source, true)];\n                default:\n                    var result = shuffle_1.shuffle(arrayCopy(source));\n                    if (maxCount < result.length)\n                        result.length = maxCount;\n                    return result;\n            }\n        }\n        Random.select = select;\n        (function (select) {\n            function one(source, throwIfEmpty) {\n                if (source && source.length)\n                    return source[r(source.length)];\n                if (throwIfEmpty)\n                    throw \"Cannot select from an empty set.\";\n            }\n            select.one = one;\n        })(select = Random.select || (Random.select = {}));\n    })(Random = exports.Random || (exports.Random = {}));\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n\r\nimport {Integer} from \"./Integer\";\r\nimport {initialize} from \"./Collections/Array/initialize\";\r\nimport {shuffle as arrayShuffle} from \"./Collections/Array/shuffle\";\r\nimport {ArrayLikeWritable} from \"./Collections/Array/ArrayLikeWritable\";\r\nimport assert = Integer.assert;\r\n\r\n/**\r\n * This module only acts as a utility API for getting random numbers from Math.random().\r\n * If you need repeatable seeded random numbers then you'll need a separate utility.\r\n * Highly recommended: https://github.com/ckknight/random-js which has typings under @types/random-js.\r\n */\r\nexport module Random\r\n{\r\n\r\n\tfunction r(maxExclusive:number = 1):number\r\n\t{\r\n\t\treturn Math.floor(Math.random()*maxExclusive);\r\n\t}\r\n\r\n\tfunction nr(\r\n\t\tboundary:number,\r\n\t\tinclusive?:boolean):number\r\n\t{\r\n\t\tconst a = Math.abs(boundary);\r\n\t\tif(a===0 || a===1 && !inclusive) return 0;\r\n\t\tif(inclusive) boundary += boundary/a;\r\n\t\treturn r(boundary);\r\n\t}\r\n\r\n\tfunction arrayCopy<T>(source:ArrayLike<T>):T[]\r\n\t{\r\n\t\tconst len = source.length;\r\n\t\tconst result = initialize<T>(len);\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tresult[i] = source[i];\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a random integer from 0 to the maxExclusive.\r\n\t * Negative numbers are allowed.\r\n\t *\r\n\t * @param maxExclusive\r\n\t * @returns {number}\r\n\t */\r\n\texport function integer(maxExclusive:number):number\r\n\t{\r\n\t\treturn next(maxExclusive);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a function that generates random floating point numbers up to the maxExclusive value.\r\n\t * Useful for generating a random and memoizable set for use with other enumerables.\r\n\t * @param maxExclusive\r\n\t * @returns {()=>number}\r\n\t */\r\n\texport function generate(maxExclusive:number = 1):()=>number\r\n\t{\r\n\t\treturn ()=> r(maxExclusive);\r\n\t}\r\n\r\n\texport module generate\r\n\t{\r\n\t\t/**\r\n\t\t * Returns a function that generates random integers up to the boundary.\r\n\t\t * Useful for generating a random and memoizable set for use with other enumerables.\r\n\t\t * @param boundary\r\n\t\t * @param inclusive\r\n\t\t * @returns {()=>number}\r\n\t\t */\r\n\t\texport function integers(\r\n\t\t\tboundary:number,\r\n\t\t\tinclusive?:boolean):()=>number\r\n\t\t{\r\n\t\t\treturn ()=> nr(boundary,inclusive);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a random integer from 0 to the boundary.\r\n\t * Return value will be less than the boundary unless inclusive is set to true.\r\n\t * Negative numbers are allowed.\r\n\t *\r\n\t * @param boundary\r\n\t * @param inclusive\r\n\t * @returns {number}\r\n\t */\r\n\texport function next(\r\n\t\tboundary:number,\r\n\t\tinclusive?:boolean):number\r\n\t{\r\n\t\tassert(boundary, 'boundary');\r\n\t\treturn nr(boundary, inclusive);\r\n\t}\r\n\r\n\texport module next\r\n\t{\r\n\t\texport function integer(\r\n\t\t\tboundary:number,\r\n\t\t\tinclusive?:boolean):number\r\n\t\t{\r\n\t\t\treturn Random.next(boundary, inclusive);\r\n\t\t}\r\n\r\n\t\texport function float(boundary:number = Number.MAX_VALUE):number\r\n\t\t{\r\n\t\t\tif(isNaN(boundary))\r\n\t\t\t\tthrow \"'boundary' is not a number.\";\r\n\t\t\treturn Math.random()*boundary;\r\n\t\t}\r\n\r\n\t\texport function inRange(\r\n\t\t\tmin:number,\r\n\t\t\tmax:number,\r\n\t\t\tinclusive?:boolean):number\r\n\t\t{\r\n\t\t\tassert(min, 'min');\r\n\t\t\tassert(max, 'max');\r\n\t\t\tlet range = max - min;\r\n\t\t\tif(range===0) return min;\r\n\t\t\tif(inclusive) range += range/Math.abs(range);\r\n\t\t\treturn min + r(range);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns an array of random integers.\r\n\t * @param count\r\n\t * @param boundary\r\n\t * @param inclusive\r\n\t * @returns {number[]}\r\n\t */\r\n\texport function integers(\r\n\t\tcount:number,\r\n\t\tboundary:number,\r\n\t\tinclusive?:boolean):number[]\r\n\t{\r\n\t\tassert(count);\r\n\t\tconst s:number[] = [];\r\n\t\ts.length = count;\r\n\t\tfor(let i = 0; i<count; i++)\r\n\t\t{\r\n\t\t\ts[i] = nr(boundary, inclusive);\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\r\n\t/**\r\n\t * Shuffles an array.\r\n\t * @param target\r\n\t * @returns {T}\r\n\t */\r\n\texport function shuffle<T extends ArrayLikeWritable<any>>(target:T):T\r\n\t{\r\n\t\treturn arrayShuffle(target);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a copy of an array-like  and returns it shuffled.\r\n\t * @param source\r\n\t * @returns {T[]}\r\n\t */\r\n\texport function copy<T>(source:ArrayLike<T>):T[]\r\n\t{\r\n\t\treturn arrayShuffle(arrayCopy(source));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a distinct random set from the source array up to the maxCount or the full length of the array.\r\n\t * @param source\r\n\t * @param maxCount\r\n\t * @returns {any}\r\n\t */\r\n\texport function select<T>(source:ArrayLike<T>, maxCount:number):T[]\r\n\t{\r\n\t\tif(maxCount!==Infinity) Integer.assertZeroOrGreater(maxCount);\r\n\t\tswitch (maxCount) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn [];\r\n\t\t\tcase 1:\r\n\t\t\t\treturn [select.one(source, true)];\r\n\t\t\tdefault:\r\n\t\t\t\tlet result = arrayShuffle(arrayCopy(source));\r\n\t\t\t\tif(maxCount<result.length)\r\n\t\t\t\t\tresult.length = maxCount;\r\n\t\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\texport module select\r\n\t{\r\n\t\t/**\r\n\t\t * Returns random value from an array.\r\n\t\t * @param source\r\n\t\t * @param throwIfEmpty\r\n\t\t */\r\n\t\texport function one<T>(source:ArrayLike<T>, throwIfEmpty:true):T\r\n\t\texport function one<T>(source:ArrayLike<T>, throwIfEmpty?:boolean):T|undefined\r\n\t\texport function one<T>(source:ArrayLike<T>, throwIfEmpty?:boolean):T|undefined\r\n\t\t{\r\n\t\t\tif(source && source.length)\r\n\t\t\t\treturn source[r(source.length)];\r\n\r\n\t\t\tif(throwIfEmpty)\r\n\t\t\t\tthrow \"Cannot select from an empty set.\";\r\n\t\t}\r\n\t}\r\n\r\n\r\n}"]}